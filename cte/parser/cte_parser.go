// Code generated from /home/karl/Projects/go-concise-encoding/codegen/cte/CTEParser.g4 by ANTLR 4.12.0. DO NOT EDIT.

package parser // CTEParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CTEParser struct {
	*antlr.BaseParser
}

var cteparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cteparserParserInit() {
	staticData := &cteparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "", "'['", "']'", "", "'}'", "'='", "'('", "')'",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "'|'", "", "'$\"'", "", "", "'>'", "'@\"'", "'@('",
	}
	staticData.symbolicNames = []string{
		"", "VERSION", "CTE_VERSION", "WSL", "COMMENT_LINE", "COMMENT_BLOCK",
		"LIST_BEGIN", "LIST_END", "MAP_BEGIN", "MAP_OR_RECORD_END", "KV_SEPARATOR",
		"NODE_BEGIN", "EDGE_OR_NODE_END", "NULL", "TRUE", "FALSE", "PINT_BIN",
		"NINT_BIN", "PINT_DEC", "NINT_DEC", "PINT_OCT", "NINT_OCT", "PINT_HEX",
		"NINT_HEX", "FLOAT_DEC", "FLOAT_HEX", "FLOAT_INF", "FLOAT_NINF", "FLOAT_NAN",
		"FLOAT_SNAN", "DATE", "TIME", "VALUE_UID", "ARRAY_BEGIN", "STRING_BEGIN",
		"RREF_BEGIN", "MARKER", "REFERENCE", "RECORD_TYPE_END", "RID_BEGIN",
		"EDGE_BEGIN", "RECORD_TYPE_BEGIN", "RECORD_BEGIN", "ARRAY_TYPE_I8",
		"ARRAY_TYPE_I8_EMPTY", "ARRAY_TYPE_I8B", "ARRAY_TYPE_I8O", "ARRAY_TYPE_I8X",
		"ARRAY_TYPE_I16", "ARRAY_TYPE_I16_EMPTY", "ARRAY_TYPE_I16B", "ARRAY_TYPE_I16O",
		"ARRAY_TYPE_I16X", "ARRAY_TYPE_I32", "ARRAY_TYPE_I32_EMPTY", "ARRAY_TYPE_I32B",
		"ARRAY_TYPE_I32O", "ARRAY_TYPE_I32X", "ARRAY_TYPE_I64", "ARRAY_TYPE_I64_EMPTY",
		"ARRAY_TYPE_I64B", "ARRAY_TYPE_I64O", "ARRAY_TYPE_I64X", "ARRAY_TYPE_U8",
		"ARRAY_TYPE_U8_EMPTY", "ARRAY_TYPE_U8B", "ARRAY_TYPE_U8O", "ARRAY_TYPE_U8X",
		"ARRAY_TYPE_U16", "ARRAY_TYPE_U16_EMPTY", "ARRAY_TYPE_U16B", "ARRAY_TYPE_U16O",
		"ARRAY_TYPE_U16X", "ARRAY_TYPE_U32", "ARRAY_TYPE_U32_EMPTY", "ARRAY_TYPE_U32B",
		"ARRAY_TYPE_U32O", "ARRAY_TYPE_U32X", "ARRAY_TYPE_U64", "ARRAY_TYPE_U64_EMPTY",
		"ARRAY_TYPE_U64B", "ARRAY_TYPE_U64O", "ARRAY_TYPE_U64X", "ARRAY_TYPE_F16",
		"ARRAY_TYPE_F16_EMPTY", "ARRAY_TYPE_F16X", "ARRAY_TYPE_F32", "ARRAY_TYPE_F32_EMPTY",
		"ARRAY_TYPE_F32X", "ARRAY_TYPE_F64", "ARRAY_TYPE_F64_EMPTY", "ARRAY_TYPE_F64X",
		"ARRAY_TYPE_UID", "ARRAY_TYPE_UID_EMPTY", "ARRAY_TYPE_BIT", "ARRAY_TYPE_BIT_EMPTY",
		"ARRAY_TYPE_CUSTOM", "ARRAY_TYPE_MEDIA", "ARRAY_I_ELEM_B", "ARRAY_I_ELEM_O",
		"ARRAY_I_ELEM_H", "ARRAY_I_ELEM_D", "ARRAY_I_END", "ARRAY_I_WSL", "ARRAY_U_ELEM_B",
		"ARRAY_U_ELEM_O", "ARRAY_U_ELEM_H", "ARRAY_U_ELEM_D", "ARRAY_U_END",
		"ARRAY_U_WSL", "ARRAY_F_ELEM_D", "ARRAY_F_ELEM_H", "ARRAY_F_NAN", "ARRAY_F_SNAN",
		"ARRAY_F_INF", "ARRAY_F_NINF", "ARRAY_F_END", "ARRAY_F_WSL", "ARRAY_F_X_ELEM",
		"ARRAY_F_X_NAN", "ARRAY_F_X_SNAN", "ARRAY_F_X_INF", "ARRAY_F_X_NINF",
		"ARRAY_F_X_END", "ARRAY_F_X_WSL", "ARRAY_I_B_ELEM", "ARRAY_I_B_END",
		"ARRAY_I_B_WSL", "ARRAY_I_O_ELEM", "ARRAY_I_O_END", "ARRAY_I_O_WSL",
		"ARRAY_I_X_ELEM", "ARRAY_I_X_END", "ARRAY_I_X_WSL", "ARRAY_U_B_ELEM",
		"ARRAY_U_B_END", "ARRAY_U_B_WSL", "ARRAY_U_O_ELEM", "ARRAY_U_O_END",
		"ARRAY_U_O_WSL", "ARRAY_U_X_ELEM", "ARRAY_U_X_END", "ARRAY_U_X_WSL",
		"ARRAY_UID_ELEM", "ARRAY_UID_END", "ARRAY_UID_WSL", "ARRAY_BIT_BITS",
		"ARRAY_BIT_END", "ARRAY_BIT_WSL", "BYTES_ELEM", "BYTES_END", "BYTES_WS",
		"STRING_END", "STRING_ESCAPE", "STRING_CONTENTS", "VERBATIM_INIT", "CODEPOINT_INIT",
		"CONTINUATION", "ESCAPE_CHAR", "VERBATIM_SENTINEL", "VERBATIM_SEPARATOR",
		"VERBATIM_EMPTY", "VERBATIM_CONTENTS", "VERBATIM_END", "CODEPOINT",
		"CUSTOM_TYPE", "CUSTOM_END", "CUSTOM_TEXT", "CUSTOM_BINARY", "CT_STRING_END",
		"CT_STRING_ESCAPE", "CT_STRING_CONTENTS", "MEDIA_TYPE", "MEDIA_END",
		"MEDIA_TEXT", "MEDIA_BINARY", "MEDIA_STRING_END", "MEDIA_STRING_ESCAPE",
		"MEDIA_STRING_CONTENTS",
	}
	staticData.ruleNames = []string{
		"cte", "version", "recordTypes", "value", "separator", "commentLine",
		"commentBlock", "valueNull", "valueUid", "valueBool", "valueInt", "valueFloat",
		"valueInf", "valueNinf", "valueNan", "valueSnan", "valueDate", "valueTime",
		"valueString", "stringContents", "stringEscape", "verbatimSequence",
		"verbatimContents", "codepointSequence", "codepointContents", "escapeChar",
		"customText", "customEscape", "customBinary", "customType", "mediaText",
		"mediaEscape", "mediaBinary", "mediaType", "valueRid", "valueRemoteRef",
		"markerID", "marker", "reference", "containerMap", "containerList",
		"containerRecordType", "containerRecord", "containerNode", "containerEdge",
		"kvPair", "recordTypeBegin", "recordBegin", "arrayElemInt", "arrayElemIntB",
		"arrayElemIntO", "arrayElemIntX", "arrayElemUint", "arrayElemUintB",
		"arrayElemUintO", "arrayElemUintX", "arrayElemFloat", "arrayElemFloatX",
		"arrayElemNan", "arrayElemSnan", "arrayElemInf", "arrayElemNinf", "arrayElemUid",
		"arrayElemBits", "arrayElemByteX", "arrayI8", "arrayI16", "arrayI32",
		"arrayI64", "arrayU8", "arrayU16", "arrayU32", "arrayU64", "arrayF16",
		"arrayF32", "arrayF64", "arrayUid", "arrayBit",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 178, 1497, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 1, 0, 1,
		0, 1, 0, 3, 0, 160, 8, 0, 1, 0, 5, 0, 163, 8, 0, 10, 0, 12, 0, 166, 9,
		0, 1, 0, 1, 0, 3, 0, 170, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 4,
		2, 178, 8, 2, 11, 2, 12, 2, 179, 1, 2, 1, 2, 5, 2, 184, 8, 2, 10, 2, 12,
		2, 187, 9, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 227, 8, 3, 1, 4, 1, 4, 1, 4, 3, 4, 232,
		8, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10,
		1, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15, 1,
		15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 5, 18, 263, 8, 18,
		10, 18, 12, 18, 266, 9, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 3, 20, 277, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 3, 21, 286, 8, 21, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1,
		24, 1, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26,
		303, 8, 26, 10, 26, 12, 26, 306, 9, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1,
		27, 1, 27, 1, 27, 3, 27, 315, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 5, 28, 324, 8, 28, 10, 28, 12, 28, 327, 9, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 336, 8, 28, 1, 29, 1, 29,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 346, 8, 30, 10, 30, 12,
		30, 349, 9, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31,
		358, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 367,
		8, 32, 10, 32, 12, 32, 370, 9, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 3, 32, 379, 8, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 5, 34,
		386, 8, 34, 10, 34, 12, 34, 389, 9, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1,
		35, 5, 35, 396, 8, 35, 10, 35, 12, 35, 399, 9, 35, 1, 35, 1, 35, 1, 36,
		1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 5, 39, 412, 8,
		39, 10, 39, 12, 39, 415, 9, 39, 1, 39, 1, 39, 4, 39, 419, 8, 39, 11, 39,
		12, 39, 420, 1, 39, 1, 39, 5, 39, 425, 8, 39, 10, 39, 12, 39, 428, 9, 39,
		3, 39, 430, 8, 39, 1, 39, 5, 39, 433, 8, 39, 10, 39, 12, 39, 436, 9, 39,
		1, 39, 1, 39, 1, 40, 1, 40, 5, 40, 442, 8, 40, 10, 40, 12, 40, 445, 9,
		40, 1, 40, 1, 40, 4, 40, 449, 8, 40, 11, 40, 12, 40, 450, 1, 40, 1, 40,
		5, 40, 455, 8, 40, 10, 40, 12, 40, 458, 9, 40, 3, 40, 460, 8, 40, 1, 40,
		5, 40, 463, 8, 40, 10, 40, 12, 40, 466, 9, 40, 1, 40, 1, 40, 1, 41, 1,
		41, 5, 41, 472, 8, 41, 10, 41, 12, 41, 475, 9, 41, 1, 41, 1, 41, 4, 41,
		479, 8, 41, 11, 41, 12, 41, 480, 1, 41, 1, 41, 5, 41, 485, 8, 41, 10, 41,
		12, 41, 488, 9, 41, 3, 41, 490, 8, 41, 1, 41, 5, 41, 493, 8, 41, 10, 41,
		12, 41, 496, 9, 41, 1, 41, 1, 41, 1, 42, 1, 42, 5, 42, 502, 8, 42, 10,
		42, 12, 42, 505, 9, 42, 1, 42, 1, 42, 4, 42, 509, 8, 42, 11, 42, 12, 42,
		510, 1, 42, 1, 42, 5, 42, 515, 8, 42, 10, 42, 12, 42, 518, 9, 42, 3, 42,
		520, 8, 42, 1, 42, 5, 42, 523, 8, 42, 10, 42, 12, 42, 526, 9, 42, 1, 42,
		1, 42, 1, 43, 1, 43, 5, 43, 532, 8, 43, 10, 43, 12, 43, 535, 9, 43, 1,
		43, 1, 43, 4, 43, 539, 8, 43, 11, 43, 12, 43, 540, 1, 43, 1, 43, 5, 43,
		545, 8, 43, 10, 43, 12, 43, 548, 9, 43, 1, 43, 5, 43, 551, 8, 43, 10, 43,
		12, 43, 554, 9, 43, 1, 43, 1, 43, 1, 44, 1, 44, 5, 44, 560, 8, 44, 10,
		44, 12, 44, 563, 9, 44, 1, 44, 1, 44, 4, 44, 567, 8, 44, 11, 44, 12, 44,
		568, 1, 44, 1, 44, 4, 44, 573, 8, 44, 11, 44, 12, 44, 574, 1, 44, 1, 44,
		5, 44, 579, 8, 44, 10, 44, 12, 44, 582, 9, 44, 1, 44, 1, 44, 1, 45, 1,
		45, 5, 45, 588, 8, 45, 10, 45, 12, 45, 591, 9, 45, 1, 45, 1, 45, 5, 45,
		595, 8, 45, 10, 45, 12, 45, 598, 9, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1,
		47, 1, 47, 1, 48, 1, 48, 1, 49, 1, 49, 1, 50, 1, 50, 1, 51, 1, 51, 1, 52,
		1, 52, 1, 53, 1, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 56, 1, 56, 1, 57, 1,
		57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 62, 1, 62,
		1, 63, 1, 63, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 3, 65, 643, 8, 65, 1,
		65, 1, 65, 1, 65, 5, 65, 648, 8, 65, 10, 65, 12, 65, 651, 9, 65, 1, 65,
		3, 65, 654, 8, 65, 3, 65, 656, 8, 65, 1, 65, 1, 65, 1, 65, 3, 65, 661,
		8, 65, 1, 65, 1, 65, 1, 65, 5, 65, 666, 8, 65, 10, 65, 12, 65, 669, 9,
		65, 1, 65, 3, 65, 672, 8, 65, 3, 65, 674, 8, 65, 1, 65, 1, 65, 1, 65, 3,
		65, 679, 8, 65, 1, 65, 1, 65, 1, 65, 5, 65, 684, 8, 65, 10, 65, 12, 65,
		687, 9, 65, 1, 65, 3, 65, 690, 8, 65, 3, 65, 692, 8, 65, 1, 65, 1, 65,
		1, 65, 3, 65, 697, 8, 65, 1, 65, 1, 65, 1, 65, 5, 65, 702, 8, 65, 10, 65,
		12, 65, 705, 9, 65, 1, 65, 3, 65, 708, 8, 65, 3, 65, 710, 8, 65, 1, 65,
		3, 65, 713, 8, 65, 1, 65, 3, 65, 716, 8, 65, 1, 66, 1, 66, 1, 66, 3, 66,
		721, 8, 66, 1, 66, 1, 66, 1, 66, 5, 66, 726, 8, 66, 10, 66, 12, 66, 729,
		9, 66, 1, 66, 3, 66, 732, 8, 66, 3, 66, 734, 8, 66, 1, 66, 1, 66, 1, 66,
		3, 66, 739, 8, 66, 1, 66, 1, 66, 1, 66, 5, 66, 744, 8, 66, 10, 66, 12,
		66, 747, 9, 66, 1, 66, 3, 66, 750, 8, 66, 3, 66, 752, 8, 66, 1, 66, 1,
		66, 1, 66, 3, 66, 757, 8, 66, 1, 66, 1, 66, 1, 66, 5, 66, 762, 8, 66, 10,
		66, 12, 66, 765, 9, 66, 1, 66, 3, 66, 768, 8, 66, 3, 66, 770, 8, 66, 1,
		66, 1, 66, 1, 66, 3, 66, 775, 8, 66, 1, 66, 1, 66, 1, 66, 5, 66, 780, 8,
		66, 10, 66, 12, 66, 783, 9, 66, 1, 66, 3, 66, 786, 8, 66, 3, 66, 788, 8,
		66, 1, 66, 3, 66, 791, 8, 66, 1, 66, 3, 66, 794, 8, 66, 1, 67, 1, 67, 1,
		67, 3, 67, 799, 8, 67, 1, 67, 1, 67, 1, 67, 5, 67, 804, 8, 67, 10, 67,
		12, 67, 807, 9, 67, 1, 67, 3, 67, 810, 8, 67, 3, 67, 812, 8, 67, 1, 67,
		1, 67, 1, 67, 3, 67, 817, 8, 67, 1, 67, 1, 67, 1, 67, 5, 67, 822, 8, 67,
		10, 67, 12, 67, 825, 9, 67, 1, 67, 3, 67, 828, 8, 67, 3, 67, 830, 8, 67,
		1, 67, 1, 67, 1, 67, 3, 67, 835, 8, 67, 1, 67, 1, 67, 1, 67, 5, 67, 840,
		8, 67, 10, 67, 12, 67, 843, 9, 67, 1, 67, 3, 67, 846, 8, 67, 3, 67, 848,
		8, 67, 1, 67, 1, 67, 1, 67, 3, 67, 853, 8, 67, 1, 67, 1, 67, 1, 67, 5,
		67, 858, 8, 67, 10, 67, 12, 67, 861, 9, 67, 1, 67, 3, 67, 864, 8, 67, 3,
		67, 866, 8, 67, 1, 67, 3, 67, 869, 8, 67, 1, 67, 3, 67, 872, 8, 67, 1,
		68, 1, 68, 1, 68, 3, 68, 877, 8, 68, 1, 68, 1, 68, 1, 68, 5, 68, 882, 8,
		68, 10, 68, 12, 68, 885, 9, 68, 1, 68, 3, 68, 888, 8, 68, 3, 68, 890, 8,
		68, 1, 68, 1, 68, 1, 68, 3, 68, 895, 8, 68, 1, 68, 1, 68, 1, 68, 5, 68,
		900, 8, 68, 10, 68, 12, 68, 903, 9, 68, 1, 68, 3, 68, 906, 8, 68, 3, 68,
		908, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 913, 8, 68, 1, 68, 1, 68, 1, 68,
		5, 68, 918, 8, 68, 10, 68, 12, 68, 921, 9, 68, 1, 68, 3, 68, 924, 8, 68,
		3, 68, 926, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 931, 8, 68, 1, 68, 1, 68,
		1, 68, 5, 68, 936, 8, 68, 10, 68, 12, 68, 939, 9, 68, 1, 68, 3, 68, 942,
		8, 68, 3, 68, 944, 8, 68, 1, 68, 3, 68, 947, 8, 68, 1, 68, 3, 68, 950,
		8, 68, 1, 69, 1, 69, 1, 69, 3, 69, 955, 8, 69, 1, 69, 1, 69, 1, 69, 5,
		69, 960, 8, 69, 10, 69, 12, 69, 963, 9, 69, 1, 69, 3, 69, 966, 8, 69, 3,
		69, 968, 8, 69, 1, 69, 1, 69, 1, 69, 3, 69, 973, 8, 69, 1, 69, 1, 69, 1,
		69, 5, 69, 978, 8, 69, 10, 69, 12, 69, 981, 9, 69, 1, 69, 3, 69, 984, 8,
		69, 3, 69, 986, 8, 69, 1, 69, 1, 69, 1, 69, 3, 69, 991, 8, 69, 1, 69, 1,
		69, 1, 69, 5, 69, 996, 8, 69, 10, 69, 12, 69, 999, 9, 69, 1, 69, 3, 69,
		1002, 8, 69, 3, 69, 1004, 8, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1009, 8, 69,
		1, 69, 1, 69, 1, 69, 5, 69, 1014, 8, 69, 10, 69, 12, 69, 1017, 9, 69, 1,
		69, 3, 69, 1020, 8, 69, 3, 69, 1022, 8, 69, 1, 69, 3, 69, 1025, 8, 69,
		1, 69, 3, 69, 1028, 8, 69, 1, 70, 1, 70, 1, 70, 3, 70, 1033, 8, 70, 1,
		70, 1, 70, 1, 70, 5, 70, 1038, 8, 70, 10, 70, 12, 70, 1041, 9, 70, 1, 70,
		3, 70, 1044, 8, 70, 3, 70, 1046, 8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1051,
		8, 70, 1, 70, 1, 70, 1, 70, 5, 70, 1056, 8, 70, 10, 70, 12, 70, 1059, 9,
		70, 1, 70, 3, 70, 1062, 8, 70, 3, 70, 1064, 8, 70, 1, 70, 1, 70, 1, 70,
		3, 70, 1069, 8, 70, 1, 70, 1, 70, 1, 70, 5, 70, 1074, 8, 70, 10, 70, 12,
		70, 1077, 9, 70, 1, 70, 3, 70, 1080, 8, 70, 3, 70, 1082, 8, 70, 1, 70,
		1, 70, 1, 70, 3, 70, 1087, 8, 70, 1, 70, 1, 70, 1, 70, 5, 70, 1092, 8,
		70, 10, 70, 12, 70, 1095, 9, 70, 1, 70, 3, 70, 1098, 8, 70, 3, 70, 1100,
		8, 70, 1, 70, 3, 70, 1103, 8, 70, 1, 70, 3, 70, 1106, 8, 70, 1, 71, 1,
		71, 1, 71, 3, 71, 1111, 8, 71, 1, 71, 1, 71, 1, 71, 5, 71, 1116, 8, 71,
		10, 71, 12, 71, 1119, 9, 71, 1, 71, 3, 71, 1122, 8, 71, 3, 71, 1124, 8,
		71, 1, 71, 1, 71, 1, 71, 3, 71, 1129, 8, 71, 1, 71, 1, 71, 1, 71, 5, 71,
		1134, 8, 71, 10, 71, 12, 71, 1137, 9, 71, 1, 71, 3, 71, 1140, 8, 71, 3,
		71, 1142, 8, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1147, 8, 71, 1, 71, 1, 71,
		1, 71, 5, 71, 1152, 8, 71, 10, 71, 12, 71, 1155, 9, 71, 1, 71, 3, 71, 1158,
		8, 71, 3, 71, 1160, 8, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1165, 8, 71, 1,
		71, 1, 71, 1, 71, 5, 71, 1170, 8, 71, 10, 71, 12, 71, 1173, 9, 71, 1, 71,
		3, 71, 1176, 8, 71, 3, 71, 1178, 8, 71, 1, 71, 3, 71, 1181, 8, 71, 1, 71,
		3, 71, 1184, 8, 71, 1, 72, 1, 72, 1, 72, 3, 72, 1189, 8, 72, 1, 72, 1,
		72, 1, 72, 5, 72, 1194, 8, 72, 10, 72, 12, 72, 1197, 9, 72, 1, 72, 3, 72,
		1200, 8, 72, 3, 72, 1202, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1207, 8, 72,
		1, 72, 1, 72, 1, 72, 5, 72, 1212, 8, 72, 10, 72, 12, 72, 1215, 9, 72, 1,
		72, 3, 72, 1218, 8, 72, 3, 72, 1220, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72,
		1225, 8, 72, 1, 72, 1, 72, 1, 72, 5, 72, 1230, 8, 72, 10, 72, 12, 72, 1233,
		9, 72, 1, 72, 3, 72, 1236, 8, 72, 3, 72, 1238, 8, 72, 1, 72, 1, 72, 1,
		72, 3, 72, 1243, 8, 72, 1, 72, 1, 72, 1, 72, 5, 72, 1248, 8, 72, 10, 72,
		12, 72, 1251, 9, 72, 1, 72, 3, 72, 1254, 8, 72, 3, 72, 1256, 8, 72, 1,
		72, 3, 72, 1259, 8, 72, 1, 72, 3, 72, 1262, 8, 72, 1, 73, 1, 73, 1, 73,
		3, 73, 1267, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1274, 8,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1282, 8, 73, 5, 73,
		1284, 8, 73, 10, 73, 12, 73, 1287, 9, 73, 1, 73, 3, 73, 1290, 8, 73, 3,
		73, 1292, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1297, 8, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 1304, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 3, 73, 1312, 8, 73, 5, 73, 1314, 8, 73, 10, 73, 12, 73, 1317,
		9, 73, 1, 73, 3, 73, 1320, 8, 73, 3, 73, 1322, 8, 73, 1, 73, 3, 73, 1325,
		8, 73, 1, 73, 3, 73, 1328, 8, 73, 1, 74, 1, 74, 1, 74, 3, 74, 1333, 8,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1340, 8, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1348, 8, 74, 5, 74, 1350, 8, 74, 10,
		74, 12, 74, 1353, 9, 74, 1, 74, 3, 74, 1356, 8, 74, 3, 74, 1358, 8, 74,
		1, 74, 1, 74, 1, 74, 3, 74, 1363, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 3, 74, 1370, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74,
		1378, 8, 74, 5, 74, 1380, 8, 74, 10, 74, 12, 74, 1383, 9, 74, 1, 74, 3,
		74, 1386, 8, 74, 3, 74, 1388, 8, 74, 1, 74, 3, 74, 1391, 8, 74, 1, 74,
		3, 74, 1394, 8, 74, 1, 75, 1, 75, 1, 75, 3, 75, 1399, 8, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 3, 75, 1406, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 3, 75, 1414, 8, 75, 5, 75, 1416, 8, 75, 10, 75, 12, 75, 1419,
		9, 75, 1, 75, 3, 75, 1422, 8, 75, 3, 75, 1424, 8, 75, 1, 75, 1, 75, 1,
		75, 3, 75, 1429, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1436,
		8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1444, 8, 75, 5,
		75, 1446, 8, 75, 10, 75, 12, 75, 1449, 9, 75, 1, 75, 3, 75, 1452, 8, 75,
		3, 75, 1454, 8, 75, 1, 75, 3, 75, 1457, 8, 75, 1, 75, 3, 75, 1460, 8, 75,
		1, 76, 1, 76, 1, 76, 3, 76, 1465, 8, 76, 1, 76, 1, 76, 1, 76, 5, 76, 1470,
		8, 76, 10, 76, 12, 76, 1473, 9, 76, 1, 76, 3, 76, 1476, 8, 76, 3, 76, 1478,
		8, 76, 1, 76, 1, 76, 3, 76, 1482, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 5,
		77, 1488, 8, 77, 10, 77, 12, 77, 1491, 9, 77, 1, 77, 1, 77, 3, 77, 1495,
		8, 77, 1, 77, 0, 0, 78, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
		26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
		98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
		128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 0,
		11, 1, 0, 14, 15, 1, 0, 16, 23, 1, 0, 24, 25, 2, 0, 154, 154, 171, 171,
		1, 0, 98, 101, 1, 0, 104, 107, 1, 0, 110, 111, 2, 0, 112, 112, 119, 119,
		2, 0, 113, 113, 120, 120, 2, 0, 114, 114, 121, 121, 2, 0, 115, 115, 122,
		122, 1762, 0, 156, 1, 0, 0, 0, 2, 173, 1, 0, 0, 0, 4, 175, 1, 0, 0, 0,
		6, 226, 1, 0, 0, 0, 8, 231, 1, 0, 0, 0, 10, 233, 1, 0, 0, 0, 12, 235, 1,
		0, 0, 0, 14, 237, 1, 0, 0, 0, 16, 239, 1, 0, 0, 0, 18, 241, 1, 0, 0, 0,
		20, 243, 1, 0, 0, 0, 22, 245, 1, 0, 0, 0, 24, 247, 1, 0, 0, 0, 26, 249,
		1, 0, 0, 0, 28, 251, 1, 0, 0, 0, 30, 253, 1, 0, 0, 0, 32, 255, 1, 0, 0,
		0, 34, 257, 1, 0, 0, 0, 36, 259, 1, 0, 0, 0, 38, 269, 1, 0, 0, 0, 40, 271,
		1, 0, 0, 0, 42, 278, 1, 0, 0, 0, 44, 287, 1, 0, 0, 0, 46, 289, 1, 0, 0,
		0, 48, 292, 1, 0, 0, 0, 50, 294, 1, 0, 0, 0, 52, 296, 1, 0, 0, 0, 54, 309,
		1, 0, 0, 0, 56, 335, 1, 0, 0, 0, 58, 337, 1, 0, 0, 0, 60, 339, 1, 0, 0,
		0, 62, 352, 1, 0, 0, 0, 64, 378, 1, 0, 0, 0, 66, 380, 1, 0, 0, 0, 68, 382,
		1, 0, 0, 0, 70, 392, 1, 0, 0, 0, 72, 402, 1, 0, 0, 0, 74, 404, 1, 0, 0,
		0, 76, 407, 1, 0, 0, 0, 78, 409, 1, 0, 0, 0, 80, 439, 1, 0, 0, 0, 82, 469,
		1, 0, 0, 0, 84, 499, 1, 0, 0, 0, 86, 529, 1, 0, 0, 0, 88, 557, 1, 0, 0,
		0, 90, 585, 1, 0, 0, 0, 92, 601, 1, 0, 0, 0, 94, 603, 1, 0, 0, 0, 96, 605,
		1, 0, 0, 0, 98, 607, 1, 0, 0, 0, 100, 609, 1, 0, 0, 0, 102, 611, 1, 0,
		0, 0, 104, 613, 1, 0, 0, 0, 106, 615, 1, 0, 0, 0, 108, 617, 1, 0, 0, 0,
		110, 619, 1, 0, 0, 0, 112, 621, 1, 0, 0, 0, 114, 623, 1, 0, 0, 0, 116,
		625, 1, 0, 0, 0, 118, 627, 1, 0, 0, 0, 120, 629, 1, 0, 0, 0, 122, 631,
		1, 0, 0, 0, 124, 633, 1, 0, 0, 0, 126, 635, 1, 0, 0, 0, 128, 637, 1, 0,
		0, 0, 130, 639, 1, 0, 0, 0, 132, 717, 1, 0, 0, 0, 134, 795, 1, 0, 0, 0,
		136, 873, 1, 0, 0, 0, 138, 951, 1, 0, 0, 0, 140, 1029, 1, 0, 0, 0, 142,
		1107, 1, 0, 0, 0, 144, 1185, 1, 0, 0, 0, 146, 1263, 1, 0, 0, 0, 148, 1329,
		1, 0, 0, 0, 150, 1395, 1, 0, 0, 0, 152, 1461, 1, 0, 0, 0, 154, 1483, 1,
		0, 0, 0, 156, 157, 3, 2, 1, 0, 157, 159, 5, 3, 0, 0, 158, 160, 3, 4, 2,
		0, 159, 158, 1, 0, 0, 0, 159, 160, 1, 0, 0, 0, 160, 164, 1, 0, 0, 0, 161,
		163, 3, 8, 4, 0, 162, 161, 1, 0, 0, 0, 163, 166, 1, 0, 0, 0, 164, 162,
		1, 0, 0, 0, 164, 165, 1, 0, 0, 0, 165, 167, 1, 0, 0, 0, 166, 164, 1, 0,
		0, 0, 167, 169, 3, 6, 3, 0, 168, 170, 5, 3, 0, 0, 169, 168, 1, 0, 0, 0,
		169, 170, 1, 0, 0, 0, 170, 171, 1, 0, 0, 0, 171, 172, 5, 0, 0, 1, 172,
		1, 1, 0, 0, 0, 173, 174, 5, 1, 0, 0, 174, 3, 1, 0, 0, 0, 175, 185, 3, 82,
		41, 0, 176, 178, 3, 8, 4, 0, 177, 176, 1, 0, 0, 0, 178, 179, 1, 0, 0, 0,
		179, 177, 1, 0, 0, 0, 179, 180, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0, 181,
		182, 3, 82, 41, 0, 182, 184, 1, 0, 0, 0, 183, 177, 1, 0, 0, 0, 184, 187,
		1, 0, 0, 0, 185, 183, 1, 0, 0, 0, 185, 186, 1, 0, 0, 0, 186, 5, 1, 0, 0,
		0, 187, 185, 1, 0, 0, 0, 188, 227, 3, 36, 18, 0, 189, 227, 3, 68, 34, 0,
		190, 227, 3, 16, 8, 0, 191, 227, 3, 18, 9, 0, 192, 227, 3, 14, 7, 0, 193,
		227, 3, 20, 10, 0, 194, 227, 3, 22, 11, 0, 195, 227, 3, 24, 12, 0, 196,
		227, 3, 26, 13, 0, 197, 227, 3, 28, 14, 0, 198, 227, 3, 30, 15, 0, 199,
		227, 3, 32, 16, 0, 200, 227, 3, 34, 17, 0, 201, 227, 3, 130, 65, 0, 202,
		227, 3, 132, 66, 0, 203, 227, 3, 134, 67, 0, 204, 227, 3, 136, 68, 0, 205,
		227, 3, 138, 69, 0, 206, 227, 3, 140, 70, 0, 207, 227, 3, 142, 71, 0, 208,
		227, 3, 144, 72, 0, 209, 227, 3, 146, 73, 0, 210, 227, 3, 148, 74, 0, 211,
		227, 3, 150, 75, 0, 212, 227, 3, 152, 76, 0, 213, 227, 3, 154, 77, 0, 214,
		227, 3, 56, 28, 0, 215, 227, 3, 52, 26, 0, 216, 227, 3, 64, 32, 0, 217,
		227, 3, 60, 30, 0, 218, 227, 3, 78, 39, 0, 219, 227, 3, 80, 40, 0, 220,
		227, 3, 88, 44, 0, 221, 227, 3, 86, 43, 0, 222, 227, 3, 84, 42, 0, 223,
		227, 3, 74, 37, 0, 224, 227, 3, 76, 38, 0, 225, 227, 3, 70, 35, 0, 226,
		188, 1, 0, 0, 0, 226, 189, 1, 0, 0, 0, 226, 190, 1, 0, 0, 0, 226, 191,
		1, 0, 0, 0, 226, 192, 1, 0, 0, 0, 226, 193, 1, 0, 0, 0, 226, 194, 1, 0,
		0, 0, 226, 195, 1, 0, 0, 0, 226, 196, 1, 0, 0, 0, 226, 197, 1, 0, 0, 0,
		226, 198, 1, 0, 0, 0, 226, 199, 1, 0, 0, 0, 226, 200, 1, 0, 0, 0, 226,
		201, 1, 0, 0, 0, 226, 202, 1, 0, 0, 0, 226, 203, 1, 0, 0, 0, 226, 204,
		1, 0, 0, 0, 226, 205, 1, 0, 0, 0, 226, 206, 1, 0, 0, 0, 226, 207, 1, 0,
		0, 0, 226, 208, 1, 0, 0, 0, 226, 209, 1, 0, 0, 0, 226, 210, 1, 0, 0, 0,
		226, 211, 1, 0, 0, 0, 226, 212, 1, 0, 0, 0, 226, 213, 1, 0, 0, 0, 226,
		214, 1, 0, 0, 0, 226, 215, 1, 0, 0, 0, 226, 216, 1, 0, 0, 0, 226, 217,
		1, 0, 0, 0, 226, 218, 1, 0, 0, 0, 226, 219, 1, 0, 0, 0, 226, 220, 1, 0,
		0, 0, 226, 221, 1, 0, 0, 0, 226, 222, 1, 0, 0, 0, 226, 223, 1, 0, 0, 0,
		226, 224, 1, 0, 0, 0, 226, 225, 1, 0, 0, 0, 227, 7, 1, 0, 0, 0, 228, 232,
		3, 10, 5, 0, 229, 232, 3, 12, 6, 0, 230, 232, 5, 3, 0, 0, 231, 228, 1,
		0, 0, 0, 231, 229, 1, 0, 0, 0, 231, 230, 1, 0, 0, 0, 232, 9, 1, 0, 0, 0,
		233, 234, 5, 4, 0, 0, 234, 11, 1, 0, 0, 0, 235, 236, 5, 5, 0, 0, 236, 13,
		1, 0, 0, 0, 237, 238, 5, 13, 0, 0, 238, 15, 1, 0, 0, 0, 239, 240, 5, 32,
		0, 0, 240, 17, 1, 0, 0, 0, 241, 242, 7, 0, 0, 0, 242, 19, 1, 0, 0, 0, 243,
		244, 7, 1, 0, 0, 244, 21, 1, 0, 0, 0, 245, 246, 7, 2, 0, 0, 246, 23, 1,
		0, 0, 0, 247, 248, 5, 26, 0, 0, 248, 25, 1, 0, 0, 0, 249, 250, 5, 27, 0,
		0, 250, 27, 1, 0, 0, 0, 251, 252, 5, 28, 0, 0, 252, 29, 1, 0, 0, 0, 253,
		254, 5, 29, 0, 0, 254, 31, 1, 0, 0, 0, 255, 256, 5, 30, 0, 0, 256, 33,
		1, 0, 0, 0, 257, 258, 5, 31, 0, 0, 258, 35, 1, 0, 0, 0, 259, 264, 5, 34,
		0, 0, 260, 263, 3, 38, 19, 0, 261, 263, 3, 40, 20, 0, 262, 260, 1, 0, 0,
		0, 262, 261, 1, 0, 0, 0, 263, 266, 1, 0, 0, 0, 264, 262, 1, 0, 0, 0, 264,
		265, 1, 0, 0, 0, 265, 267, 1, 0, 0, 0, 266, 264, 1, 0, 0, 0, 267, 268,
		5, 152, 0, 0, 268, 37, 1, 0, 0, 0, 269, 270, 7, 3, 0, 0, 270, 39, 1, 0,
		0, 0, 271, 276, 5, 153, 0, 0, 272, 277, 3, 42, 21, 0, 273, 277, 3, 46,
		23, 0, 274, 277, 3, 50, 25, 0, 275, 277, 5, 157, 0, 0, 276, 272, 1, 0,
		0, 0, 276, 273, 1, 0, 0, 0, 276, 274, 1, 0, 0, 0, 276, 275, 1, 0, 0, 0,
		277, 41, 1, 0, 0, 0, 278, 279, 5, 155, 0, 0, 279, 280, 5, 159, 0, 0, 280,
		285, 5, 160, 0, 0, 281, 282, 3, 44, 22, 0, 282, 283, 5, 163, 0, 0, 283,
		286, 1, 0, 0, 0, 284, 286, 5, 161, 0, 0, 285, 281, 1, 0, 0, 0, 285, 284,
		1, 0, 0, 0, 286, 43, 1, 0, 0, 0, 287, 288, 5, 162, 0, 0, 288, 45, 1, 0,
		0, 0, 289, 290, 5, 156, 0, 0, 290, 291, 3, 48, 24, 0, 291, 47, 1, 0, 0,
		0, 292, 293, 5, 164, 0, 0, 293, 49, 1, 0, 0, 0, 294, 295, 5, 158, 0, 0,
		295, 51, 1, 0, 0, 0, 296, 297, 5, 33, 0, 0, 297, 298, 5, 96, 0, 0, 298,
		299, 3, 58, 29, 0, 299, 304, 5, 167, 0, 0, 300, 303, 3, 38, 19, 0, 301,
		303, 3, 54, 27, 0, 302, 300, 1, 0, 0, 0, 302, 301, 1, 0, 0, 0, 303, 306,
		1, 0, 0, 0, 304, 302, 1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 307, 1, 0,
		0, 0, 306, 304, 1, 0, 0, 0, 307, 308, 5, 169, 0, 0, 308, 53, 1, 0, 0, 0,
		309, 314, 5, 170, 0, 0, 310, 315, 3, 42, 21, 0, 311, 315, 3, 46, 23, 0,
		312, 315, 3, 50, 25, 0, 313, 315, 5, 157, 0, 0, 314, 310, 1, 0, 0, 0, 314,
		311, 1, 0, 0, 0, 314, 312, 1, 0, 0, 0, 314, 313, 1, 0, 0, 0, 315, 55, 1,
		0, 0, 0, 316, 317, 5, 33, 0, 0, 317, 318, 5, 96, 0, 0, 318, 319, 3, 58,
		29, 0, 319, 320, 5, 168, 0, 0, 320, 325, 3, 128, 64, 0, 321, 322, 5, 151,
		0, 0, 322, 324, 3, 128, 64, 0, 323, 321, 1, 0, 0, 0, 324, 327, 1, 0, 0,
		0, 325, 323, 1, 0, 0, 0, 325, 326, 1, 0, 0, 0, 326, 328, 1, 0, 0, 0, 327,
		325, 1, 0, 0, 0, 328, 329, 5, 150, 0, 0, 329, 336, 1, 0, 0, 0, 330, 331,
		5, 33, 0, 0, 331, 332, 5, 96, 0, 0, 332, 333, 3, 58, 29, 0, 333, 334, 5,
		166, 0, 0, 334, 336, 1, 0, 0, 0, 335, 316, 1, 0, 0, 0, 335, 330, 1, 0,
		0, 0, 336, 57, 1, 0, 0, 0, 337, 338, 5, 165, 0, 0, 338, 59, 1, 0, 0, 0,
		339, 340, 5, 33, 0, 0, 340, 341, 5, 97, 0, 0, 341, 342, 3, 66, 33, 0, 342,
		347, 5, 174, 0, 0, 343, 346, 3, 38, 19, 0, 344, 346, 3, 62, 31, 0, 345,
		343, 1, 0, 0, 0, 345, 344, 1, 0, 0, 0, 346, 349, 1, 0, 0, 0, 347, 345,
		1, 0, 0, 0, 347, 348, 1, 0, 0, 0, 348, 350, 1, 0, 0, 0, 349, 347, 1, 0,
		0, 0, 350, 351, 5, 176, 0, 0, 351, 61, 1, 0, 0, 0, 352, 357, 5, 177, 0,
		0, 353, 358, 3, 42, 21, 0, 354, 358, 3, 46, 23, 0, 355, 358, 3, 50, 25,
		0, 356, 358, 5, 157, 0, 0, 357, 353, 1, 0, 0, 0, 357, 354, 1, 0, 0, 0,
		357, 355, 1, 0, 0, 0, 357, 356, 1, 0, 0, 0, 358, 63, 1, 0, 0, 0, 359, 360,
		5, 33, 0, 0, 360, 361, 5, 97, 0, 0, 361, 362, 3, 66, 33, 0, 362, 363, 5,
		175, 0, 0, 363, 368, 3, 128, 64, 0, 364, 365, 5, 151, 0, 0, 365, 367, 3,
		128, 64, 0, 366, 364, 1, 0, 0, 0, 367, 370, 1, 0, 0, 0, 368, 366, 1, 0,
		0, 0, 368, 369, 1, 0, 0, 0, 369, 371, 1, 0, 0, 0, 370, 368, 1, 0, 0, 0,
		371, 372, 5, 150, 0, 0, 372, 379, 1, 0, 0, 0, 373, 374, 5, 33, 0, 0, 374,
		375, 5, 97, 0, 0, 375, 376, 3, 66, 33, 0, 376, 377, 5, 173, 0, 0, 377,
		379, 1, 0, 0, 0, 378, 359, 1, 0, 0, 0, 378, 373, 1, 0, 0, 0, 379, 65, 1,
		0, 0, 0, 380, 381, 5, 172, 0, 0, 381, 67, 1, 0, 0, 0, 382, 387, 5, 39,
		0, 0, 383, 386, 3, 38, 19, 0, 384, 386, 3, 40, 20, 0, 385, 383, 1, 0, 0,
		0, 385, 384, 1, 0, 0, 0, 386, 389, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 387,
		388, 1, 0, 0, 0, 388, 390, 1, 0, 0, 0, 389, 387, 1, 0, 0, 0, 390, 391,
		5, 152, 0, 0, 391, 69, 1, 0, 0, 0, 392, 397, 5, 35, 0, 0, 393, 396, 3,
		38, 19, 0, 394, 396, 3, 40, 20, 0, 395, 393, 1, 0, 0, 0, 395, 394, 1, 0,
		0, 0, 396, 399, 1, 0, 0, 0, 397, 395, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0,
		398, 400, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 400, 401, 5, 152, 0, 0, 401,
		71, 1, 0, 0, 0, 402, 403, 5, 36, 0, 0, 403, 73, 1, 0, 0, 0, 404, 405, 3,
		72, 36, 0, 405, 406, 3, 6, 3, 0, 406, 75, 1, 0, 0, 0, 407, 408, 5, 37,
		0, 0, 408, 77, 1, 0, 0, 0, 409, 413, 5, 8, 0, 0, 410, 412, 3, 8, 4, 0,
		411, 410, 1, 0, 0, 0, 412, 415, 1, 0, 0, 0, 413, 411, 1, 0, 0, 0, 413,
		414, 1, 0, 0, 0, 414, 429, 1, 0, 0, 0, 415, 413, 1, 0, 0, 0, 416, 426,
		3, 90, 45, 0, 417, 419, 3, 8, 4, 0, 418, 417, 1, 0, 0, 0, 419, 420, 1,
		0, 0, 0, 420, 418, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 422, 1, 0, 0,
		0, 422, 423, 3, 90, 45, 0, 423, 425, 1, 0, 0, 0, 424, 418, 1, 0, 0, 0,
		425, 428, 1, 0, 0, 0, 426, 424, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427,
		430, 1, 0, 0, 0, 428, 426, 1, 0, 0, 0, 429, 416, 1, 0, 0, 0, 429, 430,
		1, 0, 0, 0, 430, 434, 1, 0, 0, 0, 431, 433, 3, 8, 4, 0, 432, 431, 1, 0,
		0, 0, 433, 436, 1, 0, 0, 0, 434, 432, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0,
		435, 437, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 437, 438, 5, 9, 0, 0, 438,
		79, 1, 0, 0, 0, 439, 443, 5, 6, 0, 0, 440, 442, 3, 8, 4, 0, 441, 440, 1,
		0, 0, 0, 442, 445, 1, 0, 0, 0, 443, 441, 1, 0, 0, 0, 443, 444, 1, 0, 0,
		0, 444, 459, 1, 0, 0, 0, 445, 443, 1, 0, 0, 0, 446, 456, 3, 6, 3, 0, 447,
		449, 3, 8, 4, 0, 448, 447, 1, 0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 448,
		1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 453, 3, 6,
		3, 0, 453, 455, 1, 0, 0, 0, 454, 448, 1, 0, 0, 0, 455, 458, 1, 0, 0, 0,
		456, 454, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 460, 1, 0, 0, 0, 458,
		456, 1, 0, 0, 0, 459, 446, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 464,
		1, 0, 0, 0, 461, 463, 3, 8, 4, 0, 462, 461, 1, 0, 0, 0, 463, 466, 1, 0,
		0, 0, 464, 462, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 467, 1, 0, 0, 0,
		466, 464, 1, 0, 0, 0, 467, 468, 5, 7, 0, 0, 468, 81, 1, 0, 0, 0, 469, 473,
		3, 92, 46, 0, 470, 472, 3, 8, 4, 0, 471, 470, 1, 0, 0, 0, 472, 475, 1,
		0, 0, 0, 473, 471, 1, 0, 0, 0, 473, 474, 1, 0, 0, 0, 474, 489, 1, 0, 0,
		0, 475, 473, 1, 0, 0, 0, 476, 486, 3, 6, 3, 0, 477, 479, 3, 8, 4, 0, 478,
		477, 1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480, 478, 1, 0, 0, 0, 480, 481,
		1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 483, 3, 6, 3, 0, 483, 485, 1, 0,
		0, 0, 484, 478, 1, 0, 0, 0, 485, 488, 1, 0, 0, 0, 486, 484, 1, 0, 0, 0,
		486, 487, 1, 0, 0, 0, 487, 490, 1, 0, 0, 0, 488, 486, 1, 0, 0, 0, 489,
		476, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 494, 1, 0, 0, 0, 491, 493,
		3, 8, 4, 0, 492, 491, 1, 0, 0, 0, 493, 496, 1, 0, 0, 0, 494, 492, 1, 0,
		0, 0, 494, 495, 1, 0, 0, 0, 495, 497, 1, 0, 0, 0, 496, 494, 1, 0, 0, 0,
		497, 498, 5, 38, 0, 0, 498, 83, 1, 0, 0, 0, 499, 503, 3, 94, 47, 0, 500,
		502, 3, 8, 4, 0, 501, 500, 1, 0, 0, 0, 502, 505, 1, 0, 0, 0, 503, 501,
		1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 519, 1, 0, 0, 0, 505, 503, 1, 0,
		0, 0, 506, 516, 3, 6, 3, 0, 507, 509, 3, 8, 4, 0, 508, 507, 1, 0, 0, 0,
		509, 510, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511,
		512, 1, 0, 0, 0, 512, 513, 3, 6, 3, 0, 513, 515, 1, 0, 0, 0, 514, 508,
		1, 0, 0, 0, 515, 518, 1, 0, 0, 0, 516, 514, 1, 0, 0, 0, 516, 517, 1, 0,
		0, 0, 517, 520, 1, 0, 0, 0, 518, 516, 1, 0, 0, 0, 519, 506, 1, 0, 0, 0,
		519, 520, 1, 0, 0, 0, 520, 524, 1, 0, 0, 0, 521, 523, 3, 8, 4, 0, 522,
		521, 1, 0, 0, 0, 523, 526, 1, 0, 0, 0, 524, 522, 1, 0, 0, 0, 524, 525,
		1, 0, 0, 0, 525, 527, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0, 527, 528, 5, 9,
		0, 0, 528, 85, 1, 0, 0, 0, 529, 533, 5, 11, 0, 0, 530, 532, 3, 8, 4, 0,
		531, 530, 1, 0, 0, 0, 532, 535, 1, 0, 0, 0, 533, 531, 1, 0, 0, 0, 533,
		534, 1, 0, 0, 0, 534, 536, 1, 0, 0, 0, 535, 533, 1, 0, 0, 0, 536, 546,
		3, 6, 3, 0, 537, 539, 3, 8, 4, 0, 538, 537, 1, 0, 0, 0, 539, 540, 1, 0,
		0, 0, 540, 538, 1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0,
		542, 543, 3, 6, 3, 0, 543, 545, 1, 0, 0, 0, 544, 538, 1, 0, 0, 0, 545,
		548, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 552,
		1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 549, 551, 3, 8, 4, 0, 550, 549, 1, 0,
		0, 0, 551, 554, 1, 0, 0, 0, 552, 550, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0,
		553, 555, 1, 0, 0, 0, 554, 552, 1, 0, 0, 0, 555, 556, 5, 12, 0, 0, 556,
		87, 1, 0, 0, 0, 557, 561, 5, 40, 0, 0, 558, 560, 3, 8, 4, 0, 559, 558,
		1, 0, 0, 0, 560, 563, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0, 561, 562, 1, 0,
		0, 0, 562, 564, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 564, 566, 3, 6, 3, 0,
		565, 567, 3, 8, 4, 0, 566, 565, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568,
		566, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 572,
		3, 6, 3, 0, 571, 573, 3, 8, 4, 0, 572, 571, 1, 0, 0, 0, 573, 574, 1, 0,
		0, 0, 574, 572, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0,
		576, 580, 3, 6, 3, 0, 577, 579, 3, 8, 4, 0, 578, 577, 1, 0, 0, 0, 579,
		582, 1, 0, 0, 0, 580, 578, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 583,
		1, 0, 0, 0, 582, 580, 1, 0, 0, 0, 583, 584, 5, 12, 0, 0, 584, 89, 1, 0,
		0, 0, 585, 589, 3, 6, 3, 0, 586, 588, 3, 8, 4, 0, 587, 586, 1, 0, 0, 0,
		588, 591, 1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590,
		592, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0, 592, 596, 5, 10, 0, 0, 593, 595,
		3, 8, 4, 0, 594, 593, 1, 0, 0, 0, 595, 598, 1, 0, 0, 0, 596, 594, 1, 0,
		0, 0, 596, 597, 1, 0, 0, 0, 597, 599, 1, 0, 0, 0, 598, 596, 1, 0, 0, 0,
		599, 600, 3, 6, 3, 0, 600, 91, 1, 0, 0, 0, 601, 602, 5, 41, 0, 0, 602,
		93, 1, 0, 0, 0, 603, 604, 5, 42, 0, 0, 604, 95, 1, 0, 0, 0, 605, 606, 7,
		4, 0, 0, 606, 97, 1, 0, 0, 0, 607, 608, 5, 125, 0, 0, 608, 99, 1, 0, 0,
		0, 609, 610, 5, 128, 0, 0, 610, 101, 1, 0, 0, 0, 611, 612, 5, 131, 0, 0,
		612, 103, 1, 0, 0, 0, 613, 614, 7, 5, 0, 0, 614, 105, 1, 0, 0, 0, 615,
		616, 5, 134, 0, 0, 616, 107, 1, 0, 0, 0, 617, 618, 5, 137, 0, 0, 618, 109,
		1, 0, 0, 0, 619, 620, 5, 140, 0, 0, 620, 111, 1, 0, 0, 0, 621, 622, 7,
		6, 0, 0, 622, 113, 1, 0, 0, 0, 623, 624, 5, 118, 0, 0, 624, 115, 1, 0,
		0, 0, 625, 626, 7, 7, 0, 0, 626, 117, 1, 0, 0, 0, 627, 628, 7, 8, 0, 0,
		628, 119, 1, 0, 0, 0, 629, 630, 7, 9, 0, 0, 630, 121, 1, 0, 0, 0, 631,
		632, 7, 10, 0, 0, 632, 123, 1, 0, 0, 0, 633, 634, 5, 143, 0, 0, 634, 125,
		1, 0, 0, 0, 635, 636, 5, 146, 0, 0, 636, 127, 1, 0, 0, 0, 637, 638, 5,
		149, 0, 0, 638, 129, 1, 0, 0, 0, 639, 715, 5, 33, 0, 0, 640, 642, 5, 43,
		0, 0, 641, 643, 5, 103, 0, 0, 642, 641, 1, 0, 0, 0, 642, 643, 1, 0, 0,
		0, 643, 655, 1, 0, 0, 0, 644, 649, 3, 96, 48, 0, 645, 646, 5, 103, 0, 0,
		646, 648, 3, 96, 48, 0, 647, 645, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649,
		647, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 653, 1, 0, 0, 0, 651, 649,
		1, 0, 0, 0, 652, 654, 5, 103, 0, 0, 653, 652, 1, 0, 0, 0, 653, 654, 1,
		0, 0, 0, 654, 656, 1, 0, 0, 0, 655, 644, 1, 0, 0, 0, 655, 656, 1, 0, 0,
		0, 656, 657, 1, 0, 0, 0, 657, 713, 5, 102, 0, 0, 658, 660, 5, 45, 0, 0,
		659, 661, 5, 127, 0, 0, 660, 659, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661,
		673, 1, 0, 0, 0, 662, 667, 3, 98, 49, 0, 663, 664, 5, 127, 0, 0, 664, 666,
		3, 98, 49, 0, 665, 663, 1, 0, 0, 0, 666, 669, 1, 0, 0, 0, 667, 665, 1,
		0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 671, 1, 0, 0, 0, 669, 667, 1, 0, 0,
		0, 670, 672, 5, 127, 0, 0, 671, 670, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0,
		672, 674, 1, 0, 0, 0, 673, 662, 1, 0, 0, 0, 673, 674, 1, 0, 0, 0, 674,
		675, 1, 0, 0, 0, 675, 713, 5, 126, 0, 0, 676, 678, 5, 46, 0, 0, 677, 679,
		5, 130, 0, 0, 678, 677, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 691, 1,
		0, 0, 0, 680, 685, 3, 100, 50, 0, 681, 682, 5, 130, 0, 0, 682, 684, 3,
		100, 50, 0, 683, 681, 1, 0, 0, 0, 684, 687, 1, 0, 0, 0, 685, 683, 1, 0,
		0, 0, 685, 686, 1, 0, 0, 0, 686, 689, 1, 0, 0, 0, 687, 685, 1, 0, 0, 0,
		688, 690, 5, 130, 0, 0, 689, 688, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690,
		692, 1, 0, 0, 0, 691, 680, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 693,
		1, 0, 0, 0, 693, 713, 5, 129, 0, 0, 694, 696, 5, 47, 0, 0, 695, 697, 5,
		133, 0, 0, 696, 695, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 709, 1, 0,
		0, 0, 698, 703, 3, 102, 51, 0, 699, 700, 5, 133, 0, 0, 700, 702, 3, 102,
		51, 0, 701, 699, 1, 0, 0, 0, 702, 705, 1, 0, 0, 0, 703, 701, 1, 0, 0, 0,
		703, 704, 1, 0, 0, 0, 704, 707, 1, 0, 0, 0, 705, 703, 1, 0, 0, 0, 706,
		708, 5, 133, 0, 0, 707, 706, 1, 0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 710,
		1, 0, 0, 0, 709, 698, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 711, 1, 0,
		0, 0, 711, 713, 5, 132, 0, 0, 712, 640, 1, 0, 0, 0, 712, 658, 1, 0, 0,
		0, 712, 676, 1, 0, 0, 0, 712, 694, 1, 0, 0, 0, 713, 716, 1, 0, 0, 0, 714,
		716, 5, 44, 0, 0, 715, 712, 1, 0, 0, 0, 715, 714, 1, 0, 0, 0, 716, 131,
		1, 0, 0, 0, 717, 793, 5, 33, 0, 0, 718, 720, 5, 48, 0, 0, 719, 721, 5,
		103, 0, 0, 720, 719, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 733, 1, 0,
		0, 0, 722, 727, 3, 96, 48, 0, 723, 724, 5, 103, 0, 0, 724, 726, 3, 96,
		48, 0, 725, 723, 1, 0, 0, 0, 726, 729, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0,
		727, 728, 1, 0, 0, 0, 728, 731, 1, 0, 0, 0, 729, 727, 1, 0, 0, 0, 730,
		732, 5, 103, 0, 0, 731, 730, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732, 734,
		1, 0, 0, 0, 733, 722, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 735, 1, 0,
		0, 0, 735, 791, 5, 102, 0, 0, 736, 738, 5, 50, 0, 0, 737, 739, 5, 127,
		0, 0, 738, 737, 1, 0, 0, 0, 738, 739, 1, 0, 0, 0, 739, 751, 1, 0, 0, 0,
		740, 745, 3, 98, 49, 0, 741, 742, 5, 127, 0, 0, 742, 744, 3, 98, 49, 0,
		743, 741, 1, 0, 0, 0, 744, 747, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0, 745,
		746, 1, 0, 0, 0, 746, 749, 1, 0, 0, 0, 747, 745, 1, 0, 0, 0, 748, 750,
		5, 127, 0, 0, 749, 748, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 752, 1,
		0, 0, 0, 751, 740, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 753, 1, 0, 0,
		0, 753, 791, 5, 126, 0, 0, 754, 756, 5, 51, 0, 0, 755, 757, 5, 130, 0,
		0, 756, 755, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 769, 1, 0, 0, 0, 758,
		763, 3, 100, 50, 0, 759, 760, 5, 130, 0, 0, 760, 762, 3, 100, 50, 0, 761,
		759, 1, 0, 0, 0, 762, 765, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764,
		1, 0, 0, 0, 764, 767, 1, 0, 0, 0, 765, 763, 1, 0, 0, 0, 766, 768, 5, 130,
		0, 0, 767, 766, 1, 0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 770, 1, 0, 0, 0,
		769, 758, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 771, 1, 0, 0, 0, 771,
		791, 5, 129, 0, 0, 772, 774, 5, 52, 0, 0, 773, 775, 5, 133, 0, 0, 774,
		773, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 787, 1, 0, 0, 0, 776, 781,
		3, 102, 51, 0, 777, 778, 5, 133, 0, 0, 778, 780, 3, 102, 51, 0, 779, 777,
		1, 0, 0, 0, 780, 783, 1, 0, 0, 0, 781, 779, 1, 0, 0, 0, 781, 782, 1, 0,
		0, 0, 782, 785, 1, 0, 0, 0, 783, 781, 1, 0, 0, 0, 784, 786, 5, 133, 0,
		0, 785, 784, 1, 0, 0, 0, 785, 786, 1, 0, 0, 0, 786, 788, 1, 0, 0, 0, 787,
		776, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 791,
		5, 132, 0, 0, 790, 718, 1, 0, 0, 0, 790, 736, 1, 0, 0, 0, 790, 754, 1,
		0, 0, 0, 790, 772, 1, 0, 0, 0, 791, 794, 1, 0, 0, 0, 792, 794, 5, 49, 0,
		0, 793, 790, 1, 0, 0, 0, 793, 792, 1, 0, 0, 0, 794, 133, 1, 0, 0, 0, 795,
		871, 5, 33, 0, 0, 796, 798, 5, 53, 0, 0, 797, 799, 5, 103, 0, 0, 798, 797,
		1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 811, 1, 0, 0, 0, 800, 805, 3, 96,
		48, 0, 801, 802, 5, 103, 0, 0, 802, 804, 3, 96, 48, 0, 803, 801, 1, 0,
		0, 0, 804, 807, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805, 806, 1, 0, 0, 0,
		806, 809, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 808, 810, 5, 103, 0, 0, 809,
		808, 1, 0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 812, 1, 0, 0, 0, 811, 800,
		1, 0, 0, 0, 811, 812, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 869, 5, 102,
		0, 0, 814, 816, 5, 55, 0, 0, 815, 817, 5, 127, 0, 0, 816, 815, 1, 0, 0,
		0, 816, 817, 1, 0, 0, 0, 817, 829, 1, 0, 0, 0, 818, 823, 3, 98, 49, 0,
		819, 820, 5, 127, 0, 0, 820, 822, 3, 98, 49, 0, 821, 819, 1, 0, 0, 0, 822,
		825, 1, 0, 0, 0, 823, 821, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0, 824, 827,
		1, 0, 0, 0, 825, 823, 1, 0, 0, 0, 826, 828, 5, 127, 0, 0, 827, 826, 1,
		0, 0, 0, 827, 828, 1, 0, 0, 0, 828, 830, 1, 0, 0, 0, 829, 818, 1, 0, 0,
		0, 829, 830, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 869, 5, 126, 0, 0,
		832, 834, 5, 56, 0, 0, 833, 835, 5, 130, 0, 0, 834, 833, 1, 0, 0, 0, 834,
		835, 1, 0, 0, 0, 835, 847, 1, 0, 0, 0, 836, 841, 3, 100, 50, 0, 837, 838,
		5, 130, 0, 0, 838, 840, 3, 100, 50, 0, 839, 837, 1, 0, 0, 0, 840, 843,
		1, 0, 0, 0, 841, 839, 1, 0, 0, 0, 841, 842, 1, 0, 0, 0, 842, 845, 1, 0,
		0, 0, 843, 841, 1, 0, 0, 0, 844, 846, 5, 130, 0, 0, 845, 844, 1, 0, 0,
		0, 845, 846, 1, 0, 0, 0, 846, 848, 1, 0, 0, 0, 847, 836, 1, 0, 0, 0, 847,
		848, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 869, 5, 129, 0, 0, 850, 852,
		5, 57, 0, 0, 851, 853, 5, 133, 0, 0, 852, 851, 1, 0, 0, 0, 852, 853, 1,
		0, 0, 0, 853, 865, 1, 0, 0, 0, 854, 859, 3, 102, 51, 0, 855, 856, 5, 133,
		0, 0, 856, 858, 3, 102, 51, 0, 857, 855, 1, 0, 0, 0, 858, 861, 1, 0, 0,
		0, 859, 857, 1, 0, 0, 0, 859, 860, 1, 0, 0, 0, 860, 863, 1, 0, 0, 0, 861,
		859, 1, 0, 0, 0, 862, 864, 5, 133, 0, 0, 863, 862, 1, 0, 0, 0, 863, 864,
		1, 0, 0, 0, 864, 866, 1, 0, 0, 0, 865, 854, 1, 0, 0, 0, 865, 866, 1, 0,
		0, 0, 866, 867, 1, 0, 0, 0, 867, 869, 5, 132, 0, 0, 868, 796, 1, 0, 0,
		0, 868, 814, 1, 0, 0, 0, 868, 832, 1, 0, 0, 0, 868, 850, 1, 0, 0, 0, 869,
		872, 1, 0, 0, 0, 870, 872, 5, 54, 0, 0, 871, 868, 1, 0, 0, 0, 871, 870,
		1, 0, 0, 0, 872, 135, 1, 0, 0, 0, 873, 949, 5, 33, 0, 0, 874, 876, 5, 58,
		0, 0, 875, 877, 5, 103, 0, 0, 876, 875, 1, 0, 0, 0, 876, 877, 1, 0, 0,
		0, 877, 889, 1, 0, 0, 0, 878, 883, 3, 96, 48, 0, 879, 880, 5, 103, 0, 0,
		880, 882, 3, 96, 48, 0, 881, 879, 1, 0, 0, 0, 882, 885, 1, 0, 0, 0, 883,
		881, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 887, 1, 0, 0, 0, 885, 883,
		1, 0, 0, 0, 886, 888, 5, 103, 0, 0, 887, 886, 1, 0, 0, 0, 887, 888, 1,
		0, 0, 0, 888, 890, 1, 0, 0, 0, 889, 878, 1, 0, 0, 0, 889, 890, 1, 0, 0,
		0, 890, 891, 1, 0, 0, 0, 891, 947, 5, 102, 0, 0, 892, 894, 5, 60, 0, 0,
		893, 895, 5, 127, 0, 0, 894, 893, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895,
		907, 1, 0, 0, 0, 896, 901, 3, 98, 49, 0, 897, 898, 5, 127, 0, 0, 898, 900,
		3, 98, 49, 0, 899, 897, 1, 0, 0, 0, 900, 903, 1, 0, 0, 0, 901, 899, 1,
		0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 905, 1, 0, 0, 0, 903, 901, 1, 0, 0,
		0, 904, 906, 5, 127, 0, 0, 905, 904, 1, 0, 0, 0, 905, 906, 1, 0, 0, 0,
		906, 908, 1, 0, 0, 0, 907, 896, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908,
		909, 1, 0, 0, 0, 909, 947, 5, 126, 0, 0, 910, 912, 5, 61, 0, 0, 911, 913,
		5, 130, 0, 0, 912, 911, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 925, 1,
		0, 0, 0, 914, 919, 3, 100, 50, 0, 915, 916, 5, 130, 0, 0, 916, 918, 3,
		100, 50, 0, 917, 915, 1, 0, 0, 0, 918, 921, 1, 0, 0, 0, 919, 917, 1, 0,
		0, 0, 919, 920, 1, 0, 0, 0, 920, 923, 1, 0, 0, 0, 921, 919, 1, 0, 0, 0,
		922, 924, 5, 130, 0, 0, 923, 922, 1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924,
		926, 1, 0, 0, 0, 925, 914, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 927,
		1, 0, 0, 0, 927, 947, 5, 129, 0, 0, 928, 930, 5, 62, 0, 0, 929, 931, 5,
		133, 0, 0, 930, 929, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 943, 1, 0,
		0, 0, 932, 937, 3, 102, 51, 0, 933, 934, 5, 133, 0, 0, 934, 936, 3, 102,
		51, 0, 935, 933, 1, 0, 0, 0, 936, 939, 1, 0, 0, 0, 937, 935, 1, 0, 0, 0,
		937, 938, 1, 0, 0, 0, 938, 941, 1, 0, 0, 0, 939, 937, 1, 0, 0, 0, 940,
		942, 5, 133, 0, 0, 941, 940, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 944,
		1, 0, 0, 0, 943, 932, 1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 945, 1, 0,
		0, 0, 945, 947, 5, 132, 0, 0, 946, 874, 1, 0, 0, 0, 946, 892, 1, 0, 0,
		0, 946, 910, 1, 0, 0, 0, 946, 928, 1, 0, 0, 0, 947, 950, 1, 0, 0, 0, 948,
		950, 5, 59, 0, 0, 949, 946, 1, 0, 0, 0, 949, 948, 1, 0, 0, 0, 950, 137,
		1, 0, 0, 0, 951, 1027, 5, 33, 0, 0, 952, 954, 5, 63, 0, 0, 953, 955, 5,
		109, 0, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 967, 1, 0,
		0, 0, 956, 961, 3, 104, 52, 0, 957, 958, 5, 109, 0, 0, 958, 960, 3, 104,
		52, 0, 959, 957, 1, 0, 0, 0, 960, 963, 1, 0, 0, 0, 961, 959, 1, 0, 0, 0,
		961, 962, 1, 0, 0, 0, 962, 965, 1, 0, 0, 0, 963, 961, 1, 0, 0, 0, 964,
		966, 5, 109, 0, 0, 965, 964, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 968,
		1, 0, 0, 0, 967, 956, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 969, 1, 0,
		0, 0, 969, 1025, 5, 108, 0, 0, 970, 972, 5, 65, 0, 0, 971, 973, 5, 136,
		0, 0, 972, 971, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 985, 1, 0, 0, 0,
		974, 979, 3, 106, 53, 0, 975, 976, 5, 136, 0, 0, 976, 978, 3, 106, 53,
		0, 977, 975, 1, 0, 0, 0, 978, 981, 1, 0, 0, 0, 979, 977, 1, 0, 0, 0, 979,
		980, 1, 0, 0, 0, 980, 983, 1, 0, 0, 0, 981, 979, 1, 0, 0, 0, 982, 984,
		5, 136, 0, 0, 983, 982, 1, 0, 0, 0, 983, 984, 1, 0, 0, 0, 984, 986, 1,
		0, 0, 0, 985, 974, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986, 987, 1, 0, 0,
		0, 987, 1025, 5, 135, 0, 0, 988, 990, 5, 66, 0, 0, 989, 991, 5, 139, 0,
		0, 990, 989, 1, 0, 0, 0, 990, 991, 1, 0, 0, 0, 991, 1003, 1, 0, 0, 0, 992,
		997, 3, 108, 54, 0, 993, 994, 5, 139, 0, 0, 994, 996, 3, 108, 54, 0, 995,
		993, 1, 0, 0, 0, 996, 999, 1, 0, 0, 0, 997, 995, 1, 0, 0, 0, 997, 998,
		1, 0, 0, 0, 998, 1001, 1, 0, 0, 0, 999, 997, 1, 0, 0, 0, 1000, 1002, 5,
		139, 0, 0, 1001, 1000, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1004,
		1, 0, 0, 0, 1003, 992, 1, 0, 0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1005,
		1, 0, 0, 0, 1005, 1025, 5, 138, 0, 0, 1006, 1008, 5, 67, 0, 0, 1007, 1009,
		5, 142, 0, 0, 1008, 1007, 1, 0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1021,
		1, 0, 0, 0, 1010, 1015, 3, 110, 55, 0, 1011, 1012, 5, 142, 0, 0, 1012,
		1014, 3, 110, 55, 0, 1013, 1011, 1, 0, 0, 0, 1014, 1017, 1, 0, 0, 0, 1015,
		1013, 1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016, 1019, 1, 0, 0, 0, 1017,
		1015, 1, 0, 0, 0, 1018, 1020, 5, 142, 0, 0, 1019, 1018, 1, 0, 0, 0, 1019,
		1020, 1, 0, 0, 0, 1020, 1022, 1, 0, 0, 0, 1021, 1010, 1, 0, 0, 0, 1021,
		1022, 1, 0, 0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 1025, 5, 141, 0, 0, 1024,
		952, 1, 0, 0, 0, 1024, 970, 1, 0, 0, 0, 1024, 988, 1, 0, 0, 0, 1024, 1006,
		1, 0, 0, 0, 1025, 1028, 1, 0, 0, 0, 1026, 1028, 5, 64, 0, 0, 1027, 1024,
		1, 0, 0, 0, 1027, 1026, 1, 0, 0, 0, 1028, 139, 1, 0, 0, 0, 1029, 1105,
		5, 33, 0, 0, 1030, 1032, 5, 68, 0, 0, 1031, 1033, 5, 109, 0, 0, 1032, 1031,
		1, 0, 0, 0, 1032, 1033, 1, 0, 0, 0, 1033, 1045, 1, 0, 0, 0, 1034, 1039,
		3, 104, 52, 0, 1035, 1036, 5, 109, 0, 0, 1036, 1038, 3, 104, 52, 0, 1037,
		1035, 1, 0, 0, 0, 1038, 1041, 1, 0, 0, 0, 1039, 1037, 1, 0, 0, 0, 1039,
		1040, 1, 0, 0, 0, 1040, 1043, 1, 0, 0, 0, 1041, 1039, 1, 0, 0, 0, 1042,
		1044, 5, 109, 0, 0, 1043, 1042, 1, 0, 0, 0, 1043, 1044, 1, 0, 0, 0, 1044,
		1046, 1, 0, 0, 0, 1045, 1034, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046,
		1047, 1, 0, 0, 0, 1047, 1103, 5, 108, 0, 0, 1048, 1050, 5, 70, 0, 0, 1049,
		1051, 5, 136, 0, 0, 1050, 1049, 1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051,
		1063, 1, 0, 0, 0, 1052, 1057, 3, 106, 53, 0, 1053, 1054, 5, 136, 0, 0,
		1054, 1056, 3, 106, 53, 0, 1055, 1053, 1, 0, 0, 0, 1056, 1059, 1, 0, 0,
		0, 1057, 1055, 1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 1061, 1, 0, 0,
		0, 1059, 1057, 1, 0, 0, 0, 1060, 1062, 5, 136, 0, 0, 1061, 1060, 1, 0,
		0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1064, 1, 0, 0, 0, 1063, 1052, 1, 0,
		0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1103, 5, 135,
		0, 0, 1066, 1068, 5, 71, 0, 0, 1067, 1069, 5, 139, 0, 0, 1068, 1067, 1,
		0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1081, 1, 0, 0, 0, 1070, 1075, 3,
		108, 54, 0, 1071, 1072, 5, 139, 0, 0, 1072, 1074, 3, 108, 54, 0, 1073,
		1071, 1, 0, 0, 0, 1074, 1077, 1, 0, 0, 0, 1075, 1073, 1, 0, 0, 0, 1075,
		1076, 1, 0, 0, 0, 1076, 1079, 1, 0, 0, 0, 1077, 1075, 1, 0, 0, 0, 1078,
		1080, 5, 139, 0, 0, 1079, 1078, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080,
		1082, 1, 0, 0, 0, 1081, 1070, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082,
		1083, 1, 0, 0, 0, 1083, 1103, 5, 138, 0, 0, 1084, 1086, 5, 72, 0, 0, 1085,
		1087, 5, 142, 0, 0, 1086, 1085, 1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0, 1087,
		1099, 1, 0, 0, 0, 1088, 1093, 3, 110, 55, 0, 1089, 1090, 5, 142, 0, 0,
		1090, 1092, 3, 110, 55, 0, 1091, 1089, 1, 0, 0, 0, 1092, 1095, 1, 0, 0,
		0, 1093, 1091, 1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1097, 1, 0, 0,
		0, 1095, 1093, 1, 0, 0, 0, 1096, 1098, 5, 142, 0, 0, 1097, 1096, 1, 0,
		0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 1100, 1, 0, 0, 0, 1099, 1088, 1, 0,
		0, 0, 1099, 1100, 1, 0, 0, 0, 1100, 1101, 1, 0, 0, 0, 1101, 1103, 5, 141,
		0, 0, 1102, 1030, 1, 0, 0, 0, 1102, 1048, 1, 0, 0, 0, 1102, 1066, 1, 0,
		0, 0, 1102, 1084, 1, 0, 0, 0, 1103, 1106, 1, 0, 0, 0, 1104, 1106, 5, 69,
		0, 0, 1105, 1102, 1, 0, 0, 0, 1105, 1104, 1, 0, 0, 0, 1106, 141, 1, 0,
		0, 0, 1107, 1183, 5, 33, 0, 0, 1108, 1110, 5, 73, 0, 0, 1109, 1111, 5,
		109, 0, 0, 1110, 1109, 1, 0, 0, 0, 1110, 1111, 1, 0, 0, 0, 1111, 1123,
		1, 0, 0, 0, 1112, 1117, 3, 104, 52, 0, 1113, 1114, 5, 109, 0, 0, 1114,
		1116, 3, 104, 52, 0, 1115, 1113, 1, 0, 0, 0, 1116, 1119, 1, 0, 0, 0, 1117,
		1115, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 1121, 1, 0, 0, 0, 1119,
		1117, 1, 0, 0, 0, 1120, 1122, 5, 109, 0, 0, 1121, 1120, 1, 0, 0, 0, 1121,
		1122, 1, 0, 0, 0, 1122, 1124, 1, 0, 0, 0, 1123, 1112, 1, 0, 0, 0, 1123,
		1124, 1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 1181, 5, 108, 0, 0, 1126,
		1128, 5, 75, 0, 0, 1127, 1129, 5, 136, 0, 0, 1128, 1127, 1, 0, 0, 0, 1128,
		1129, 1, 0, 0, 0, 1129, 1141, 1, 0, 0, 0, 1130, 1135, 3, 106, 53, 0, 1131,
		1132, 5, 136, 0, 0, 1132, 1134, 3, 106, 53, 0, 1133, 1131, 1, 0, 0, 0,
		1134, 1137, 1, 0, 0, 0, 1135, 1133, 1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0,
		1136, 1139, 1, 0, 0, 0, 1137, 1135, 1, 0, 0, 0, 1138, 1140, 5, 136, 0,
		0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1142, 1, 0, 0,
		0, 1141, 1130, 1, 0, 0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1143, 1, 0, 0,
		0, 1143, 1181, 5, 135, 0, 0, 1144, 1146, 5, 76, 0, 0, 1145, 1147, 5, 139,
		0, 0, 1146, 1145, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 1159, 1, 0,
		0, 0, 1148, 1153, 3, 108, 54, 0, 1149, 1150, 5, 139, 0, 0, 1150, 1152,
		3, 108, 54, 0, 1151, 1149, 1, 0, 0, 0, 1152, 1155, 1, 0, 0, 0, 1153, 1151,
		1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 1157, 1, 0, 0, 0, 1155, 1153,
		1, 0, 0, 0, 1156, 1158, 5, 139, 0, 0, 1157, 1156, 1, 0, 0, 0, 1157, 1158,
		1, 0, 0, 0, 1158, 1160, 1, 0, 0, 0, 1159, 1148, 1, 0, 0, 0, 1159, 1160,
		1, 0, 0, 0, 1160, 1161, 1, 0, 0, 0, 1161, 1181, 5, 138, 0, 0, 1162, 1164,
		5, 77, 0, 0, 1163, 1165, 5, 142, 0, 0, 1164, 1163, 1, 0, 0, 0, 1164, 1165,
		1, 0, 0, 0, 1165, 1177, 1, 0, 0, 0, 1166, 1171, 3, 110, 55, 0, 1167, 1168,
		5, 142, 0, 0, 1168, 1170, 3, 110, 55, 0, 1169, 1167, 1, 0, 0, 0, 1170,
		1173, 1, 0, 0, 0, 1171, 1169, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172,
		1175, 1, 0, 0, 0, 1173, 1171, 1, 0, 0, 0, 1174, 1176, 5, 142, 0, 0, 1175,
		1174, 1, 0, 0, 0, 1175, 1176, 1, 0, 0, 0, 1176, 1178, 1, 0, 0, 0, 1177,
		1166, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1179, 1, 0, 0, 0, 1179,
		1181, 5, 141, 0, 0, 1180, 1108, 1, 0, 0, 0, 1180, 1126, 1, 0, 0, 0, 1180,
		1144, 1, 0, 0, 0, 1180, 1162, 1, 0, 0, 0, 1181, 1184, 1, 0, 0, 0, 1182,
		1184, 5, 74, 0, 0, 1183, 1180, 1, 0, 0, 0, 1183, 1182, 1, 0, 0, 0, 1184,
		143, 1, 0, 0, 0, 1185, 1261, 5, 33, 0, 0, 1186, 1188, 5, 78, 0, 0, 1187,
		1189, 5, 109, 0, 0, 1188, 1187, 1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189,
		1201, 1, 0, 0, 0, 1190, 1195, 3, 104, 52, 0, 1191, 1192, 5, 109, 0, 0,
		1192, 1194, 3, 104, 52, 0, 1193, 1191, 1, 0, 0, 0, 1194, 1197, 1, 0, 0,
		0, 1195, 1193, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1199, 1, 0, 0,
		0, 1197, 1195, 1, 0, 0, 0, 1198, 1200, 5, 109, 0, 0, 1199, 1198, 1, 0,
		0, 0, 1199, 1200, 1, 0, 0, 0, 1200, 1202, 1, 0, 0, 0, 1201, 1190, 1, 0,
		0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1203, 1, 0, 0, 0, 1203, 1259, 5, 108,
		0, 0, 1204, 1206, 5, 80, 0, 0, 1205, 1207, 5, 136, 0, 0, 1206, 1205, 1,
		0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 1219, 1, 0, 0, 0, 1208, 1213, 3,
		106, 53, 0, 1209, 1210, 5, 136, 0, 0, 1210, 1212, 3, 106, 53, 0, 1211,
		1209, 1, 0, 0, 0, 1212, 1215, 1, 0, 0, 0, 1213, 1211, 1, 0, 0, 0, 1213,
		1214, 1, 0, 0, 0, 1214, 1217, 1, 0, 0, 0, 1215, 1213, 1, 0, 0, 0, 1216,
		1218, 5, 136, 0, 0, 1217, 1216, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218,
		1220, 1, 0, 0, 0, 1219, 1208, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220,
		1221, 1, 0, 0, 0, 1221, 1259, 5, 135, 0, 0, 1222, 1224, 5, 81, 0, 0, 1223,
		1225, 5, 139, 0, 0, 1224, 1223, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225,
		1237, 1, 0, 0, 0, 1226, 1231, 3, 108, 54, 0, 1227, 1228, 5, 139, 0, 0,
		1228, 1230, 3, 108, 54, 0, 1229, 1227, 1, 0, 0, 0, 1230, 1233, 1, 0, 0,
		0, 1231, 1229, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1235, 1, 0, 0,
		0, 1233, 1231, 1, 0, 0, 0, 1234, 1236, 5, 139, 0, 0, 1235, 1234, 1, 0,
		0, 0, 1235, 1236, 1, 0, 0, 0, 1236, 1238, 1, 0, 0, 0, 1237, 1226, 1, 0,
		0, 0, 1237, 1238, 1, 0, 0, 0, 1238, 1239, 1, 0, 0, 0, 1239, 1259, 5, 138,
		0, 0, 1240, 1242, 5, 82, 0, 0, 1241, 1243, 5, 142, 0, 0, 1242, 1241, 1,
		0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1255, 1, 0, 0, 0, 1244, 1249, 3,
		110, 55, 0, 1245, 1246, 5, 142, 0, 0, 1246, 1248, 3, 110, 55, 0, 1247,
		1245, 1, 0, 0, 0, 1248, 1251, 1, 0, 0, 0, 1249, 1247, 1, 0, 0, 0, 1249,
		1250, 1, 0, 0, 0, 1250, 1253, 1, 0, 0, 0, 1251, 1249, 1, 0, 0, 0, 1252,
		1254, 5, 142, 0, 0, 1253, 1252, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254,
		1256, 1, 0, 0, 0, 1255, 1244, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256,
		1257, 1, 0, 0, 0, 1257, 1259, 5, 141, 0, 0, 1258, 1186, 1, 0, 0, 0, 1258,
		1204, 1, 0, 0, 0, 1258, 1222, 1, 0, 0, 0, 1258, 1240, 1, 0, 0, 0, 1259,
		1262, 1, 0, 0, 0, 1260, 1262, 5, 79, 0, 0, 1261, 1258, 1, 0, 0, 0, 1261,
		1260, 1, 0, 0, 0, 1262, 145, 1, 0, 0, 0, 1263, 1327, 5, 33, 0, 0, 1264,
		1266, 5, 83, 0, 0, 1265, 1267, 5, 117, 0, 0, 1266, 1265, 1, 0, 0, 0, 1266,
		1267, 1, 0, 0, 0, 1267, 1291, 1, 0, 0, 0, 1268, 1274, 3, 112, 56, 0, 1269,
		1274, 3, 116, 58, 0, 1270, 1274, 3, 118, 59, 0, 1271, 1274, 3, 120, 60,
		0, 1272, 1274, 3, 122, 61, 0, 1273, 1268, 1, 0, 0, 0, 1273, 1269, 1, 0,
		0, 0, 1273, 1270, 1, 0, 0, 0, 1273, 1271, 1, 0, 0, 0, 1273, 1272, 1, 0,
		0, 0, 1274, 1285, 1, 0, 0, 0, 1275, 1281, 5, 117, 0, 0, 1276, 1282, 3,
		112, 56, 0, 1277, 1282, 3, 116, 58, 0, 1278, 1282, 3, 118, 59, 0, 1279,
		1282, 3, 120, 60, 0, 1280, 1282, 3, 122, 61, 0, 1281, 1276, 1, 0, 0, 0,
		1281, 1277, 1, 0, 0, 0, 1281, 1278, 1, 0, 0, 0, 1281, 1279, 1, 0, 0, 0,
		1281, 1280, 1, 0, 0, 0, 1282, 1284, 1, 0, 0, 0, 1283, 1275, 1, 0, 0, 0,
		1284, 1287, 1, 0, 0, 0, 1285, 1283, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0,
		1286, 1289, 1, 0, 0, 0, 1287, 1285, 1, 0, 0, 0, 1288, 1290, 5, 117, 0,
		0, 1289, 1288, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1292, 1, 0, 0,
		0, 1291, 1273, 1, 0, 0, 0, 1291, 1292, 1, 0, 0, 0, 1292, 1293, 1, 0, 0,
		0, 1293, 1325, 5, 116, 0, 0, 1294, 1296, 5, 85, 0, 0, 1295, 1297, 5, 124,
		0, 0, 1296, 1295, 1, 0, 0, 0, 1296, 1297, 1, 0, 0, 0, 1297, 1321, 1, 0,
		0, 0, 1298, 1304, 3, 114, 57, 0, 1299, 1304, 3, 116, 58, 0, 1300, 1304,
		3, 118, 59, 0, 1301, 1304, 3, 120, 60, 0, 1302, 1304, 3, 122, 61, 0, 1303,
		1298, 1, 0, 0, 0, 1303, 1299, 1, 0, 0, 0, 1303, 1300, 1, 0, 0, 0, 1303,
		1301, 1, 0, 0, 0, 1303, 1302, 1, 0, 0, 0, 1304, 1315, 1, 0, 0, 0, 1305,
		1311, 5, 124, 0, 0, 1306, 1312, 3, 114, 57, 0, 1307, 1312, 3, 116, 58,
		0, 1308, 1312, 3, 118, 59, 0, 1309, 1312, 3, 120, 60, 0, 1310, 1312, 3,
		122, 61, 0, 1311, 1306, 1, 0, 0, 0, 1311, 1307, 1, 0, 0, 0, 1311, 1308,
		1, 0, 0, 0, 1311, 1309, 1, 0, 0, 0, 1311, 1310, 1, 0, 0, 0, 1312, 1314,
		1, 0, 0, 0, 1313, 1305, 1, 0, 0, 0, 1314, 1317, 1, 0, 0, 0, 1315, 1313,
		1, 0, 0, 0, 1315, 1316, 1, 0, 0, 0, 1316, 1319, 1, 0, 0, 0, 1317, 1315,
		1, 0, 0, 0, 1318, 1320, 5, 124, 0, 0, 1319, 1318, 1, 0, 0, 0, 1319, 1320,
		1, 0, 0, 0, 1320, 1322, 1, 0, 0, 0, 1321, 1303, 1, 0, 0, 0, 1321, 1322,
		1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1325, 5, 123, 0, 0, 1324, 1264,
		1, 0, 0, 0, 1324, 1294, 1, 0, 0, 0, 1325, 1328, 1, 0, 0, 0, 1326, 1328,
		5, 84, 0, 0, 1327, 1324, 1, 0, 0, 0, 1327, 1326, 1, 0, 0, 0, 1328, 147,
		1, 0, 0, 0, 1329, 1393, 5, 33, 0, 0, 1330, 1332, 5, 86, 0, 0, 1331, 1333,
		5, 117, 0, 0, 1332, 1331, 1, 0, 0, 0, 1332, 1333, 1, 0, 0, 0, 1333, 1357,
		1, 0, 0, 0, 1334, 1340, 3, 112, 56, 0, 1335, 1340, 3, 116, 58, 0, 1336,
		1340, 3, 118, 59, 0, 1337, 1340, 3, 120, 60, 0, 1338, 1340, 3, 122, 61,
		0, 1339, 1334, 1, 0, 0, 0, 1339, 1335, 1, 0, 0, 0, 1339, 1336, 1, 0, 0,
		0, 1339, 1337, 1, 0, 0, 0, 1339, 1338, 1, 0, 0, 0, 1340, 1351, 1, 0, 0,
		0, 1341, 1347, 5, 117, 0, 0, 1342, 1348, 3, 112, 56, 0, 1343, 1348, 3,
		116, 58, 0, 1344, 1348, 3, 118, 59, 0, 1345, 1348, 3, 120, 60, 0, 1346,
		1348, 3, 122, 61, 0, 1347, 1342, 1, 0, 0, 0, 1347, 1343, 1, 0, 0, 0, 1347,
		1344, 1, 0, 0, 0, 1347, 1345, 1, 0, 0, 0, 1347, 1346, 1, 0, 0, 0, 1348,
		1350, 1, 0, 0, 0, 1349, 1341, 1, 0, 0, 0, 1350, 1353, 1, 0, 0, 0, 1351,
		1349, 1, 0, 0, 0, 1351, 1352, 1, 0, 0, 0, 1352, 1355, 1, 0, 0, 0, 1353,
		1351, 1, 0, 0, 0, 1354, 1356, 5, 117, 0, 0, 1355, 1354, 1, 0, 0, 0, 1355,
		1356, 1, 0, 0, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1339, 1, 0, 0, 0, 1357,
		1358, 1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0, 1359, 1391, 5, 116, 0, 0, 1360,
		1362, 5, 88, 0, 0, 1361, 1363, 5, 124, 0, 0, 1362, 1361, 1, 0, 0, 0, 1362,
		1363, 1, 0, 0, 0, 1363, 1387, 1, 0, 0, 0, 1364, 1370, 3, 114, 57, 0, 1365,
		1370, 3, 116, 58, 0, 1366, 1370, 3, 118, 59, 0, 1367, 1370, 3, 120, 60,
		0, 1368, 1370, 3, 122, 61, 0, 1369, 1364, 1, 0, 0, 0, 1369, 1365, 1, 0,
		0, 0, 1369, 1366, 1, 0, 0, 0, 1369, 1367, 1, 0, 0, 0, 1369, 1368, 1, 0,
		0, 0, 1370, 1381, 1, 0, 0, 0, 1371, 1377, 5, 124, 0, 0, 1372, 1378, 3,
		114, 57, 0, 1373, 1378, 3, 116, 58, 0, 1374, 1378, 3, 118, 59, 0, 1375,
		1378, 3, 120, 60, 0, 1376, 1378, 3, 122, 61, 0, 1377, 1372, 1, 0, 0, 0,
		1377, 1373, 1, 0, 0, 0, 1377, 1374, 1, 0, 0, 0, 1377, 1375, 1, 0, 0, 0,
		1377, 1376, 1, 0, 0, 0, 1378, 1380, 1, 0, 0, 0, 1379, 1371, 1, 0, 0, 0,
		1380, 1383, 1, 0, 0, 0, 1381, 1379, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0,
		1382, 1385, 1, 0, 0, 0, 1383, 1381, 1, 0, 0, 0, 1384, 1386, 5, 124, 0,
		0, 1385, 1384, 1, 0, 0, 0, 1385, 1386, 1, 0, 0, 0, 1386, 1388, 1, 0, 0,
		0, 1387, 1369, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0, 1388, 1389, 1, 0, 0,
		0, 1389, 1391, 5, 123, 0, 0, 1390, 1330, 1, 0, 0, 0, 1390, 1360, 1, 0,
		0, 0, 1391, 1394, 1, 0, 0, 0, 1392, 1394, 5, 87, 0, 0, 1393, 1390, 1, 0,
		0, 0, 1393, 1392, 1, 0, 0, 0, 1394, 149, 1, 0, 0, 0, 1395, 1459, 5, 33,
		0, 0, 1396, 1398, 5, 89, 0, 0, 1397, 1399, 5, 117, 0, 0, 1398, 1397, 1,
		0, 0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1423, 1, 0, 0, 0, 1400, 1406, 3,
		112, 56, 0, 1401, 1406, 3, 116, 58, 0, 1402, 1406, 3, 118, 59, 0, 1403,
		1406, 3, 120, 60, 0, 1404, 1406, 3, 122, 61, 0, 1405, 1400, 1, 0, 0, 0,
		1405, 1401, 1, 0, 0, 0, 1405, 1402, 1, 0, 0, 0, 1405, 1403, 1, 0, 0, 0,
		1405, 1404, 1, 0, 0, 0, 1406, 1417, 1, 0, 0, 0, 1407, 1413, 5, 117, 0,
		0, 1408, 1414, 3, 112, 56, 0, 1409, 1414, 3, 116, 58, 0, 1410, 1414, 3,
		118, 59, 0, 1411, 1414, 3, 120, 60, 0, 1412, 1414, 3, 122, 61, 0, 1413,
		1408, 1, 0, 0, 0, 1413, 1409, 1, 0, 0, 0, 1413, 1410, 1, 0, 0, 0, 1413,
		1411, 1, 0, 0, 0, 1413, 1412, 1, 0, 0, 0, 1414, 1416, 1, 0, 0, 0, 1415,
		1407, 1, 0, 0, 0, 1416, 1419, 1, 0, 0, 0, 1417, 1415, 1, 0, 0, 0, 1417,
		1418, 1, 0, 0, 0, 1418, 1421, 1, 0, 0, 0, 1419, 1417, 1, 0, 0, 0, 1420,
		1422, 5, 117, 0, 0, 1421, 1420, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422,
		1424, 1, 0, 0, 0, 1423, 1405, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424,
		1425, 1, 0, 0, 0, 1425, 1457, 5, 116, 0, 0, 1426, 1428, 5, 91, 0, 0, 1427,
		1429, 5, 124, 0, 0, 1428, 1427, 1, 0, 0, 0, 1428, 1429, 1, 0, 0, 0, 1429,
		1453, 1, 0, 0, 0, 1430, 1436, 3, 114, 57, 0, 1431, 1436, 3, 116, 58, 0,
		1432, 1436, 3, 118, 59, 0, 1433, 1436, 3, 120, 60, 0, 1434, 1436, 3, 122,
		61, 0, 1435, 1430, 1, 0, 0, 0, 1435, 1431, 1, 0, 0, 0, 1435, 1432, 1, 0,
		0, 0, 1435, 1433, 1, 0, 0, 0, 1435, 1434, 1, 0, 0, 0, 1436, 1447, 1, 0,
		0, 0, 1437, 1443, 5, 124, 0, 0, 1438, 1444, 3, 114, 57, 0, 1439, 1444,
		3, 116, 58, 0, 1440, 1444, 3, 118, 59, 0, 1441, 1444, 3, 120, 60, 0, 1442,
		1444, 3, 122, 61, 0, 1443, 1438, 1, 0, 0, 0, 1443, 1439, 1, 0, 0, 0, 1443,
		1440, 1, 0, 0, 0, 1443, 1441, 1, 0, 0, 0, 1443, 1442, 1, 0, 0, 0, 1444,
		1446, 1, 0, 0, 0, 1445, 1437, 1, 0, 0, 0, 1446, 1449, 1, 0, 0, 0, 1447,
		1445, 1, 0, 0, 0, 1447, 1448, 1, 0, 0, 0, 1448, 1451, 1, 0, 0, 0, 1449,
		1447, 1, 0, 0, 0, 1450, 1452, 5, 124, 0, 0, 1451, 1450, 1, 0, 0, 0, 1451,
		1452, 1, 0, 0, 0, 1452, 1454, 1, 0, 0, 0, 1453, 1435, 1, 0, 0, 0, 1453,
		1454, 1, 0, 0, 0, 1454, 1455, 1, 0, 0, 0, 1455, 1457, 5, 123, 0, 0, 1456,
		1396, 1, 0, 0, 0, 1456, 1426, 1, 0, 0, 0, 1457, 1460, 1, 0, 0, 0, 1458,
		1460, 5, 90, 0, 0, 1459, 1456, 1, 0, 0, 0, 1459, 1458, 1, 0, 0, 0, 1460,
		151, 1, 0, 0, 0, 1461, 1481, 5, 33, 0, 0, 1462, 1464, 5, 92, 0, 0, 1463,
		1465, 5, 145, 0, 0, 1464, 1463, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465,
		1477, 1, 0, 0, 0, 1466, 1471, 3, 124, 62, 0, 1467, 1468, 5, 145, 0, 0,
		1468, 1470, 3, 124, 62, 0, 1469, 1467, 1, 0, 0, 0, 1470, 1473, 1, 0, 0,
		0, 1471, 1469, 1, 0, 0, 0, 1471, 1472, 1, 0, 0, 0, 1472, 1475, 1, 0, 0,
		0, 1473, 1471, 1, 0, 0, 0, 1474, 1476, 5, 145, 0, 0, 1475, 1474, 1, 0,
		0, 0, 1475, 1476, 1, 0, 0, 0, 1476, 1478, 1, 0, 0, 0, 1477, 1466, 1, 0,
		0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1479, 1, 0, 0, 0, 1479, 1482, 5, 144,
		0, 0, 1480, 1482, 5, 93, 0, 0, 1481, 1462, 1, 0, 0, 0, 1481, 1480, 1, 0,
		0, 0, 1482, 153, 1, 0, 0, 0, 1483, 1494, 5, 33, 0, 0, 1484, 1489, 5, 94,
		0, 0, 1485, 1488, 5, 148, 0, 0, 1486, 1488, 3, 126, 63, 0, 1487, 1485,
		1, 0, 0, 0, 1487, 1486, 1, 0, 0, 0, 1488, 1491, 1, 0, 0, 0, 1489, 1487,
		1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1492, 1, 0, 0, 0, 1491, 1489,
		1, 0, 0, 0, 1492, 1495, 5, 147, 0, 0, 1493, 1495, 5, 95, 0, 0, 1494, 1484,
		1, 0, 0, 0, 1494, 1493, 1, 0, 0, 0, 1495, 155, 1, 0, 0, 0, 249, 159, 164,
		169, 179, 185, 226, 231, 262, 264, 276, 285, 302, 304, 314, 325, 335, 345,
		347, 357, 368, 378, 385, 387, 395, 397, 413, 420, 426, 429, 434, 443, 450,
		456, 459, 464, 473, 480, 486, 489, 494, 503, 510, 516, 519, 524, 533, 540,
		546, 552, 561, 568, 574, 580, 589, 596, 642, 649, 653, 655, 660, 667, 671,
		673, 678, 685, 689, 691, 696, 703, 707, 709, 712, 715, 720, 727, 731, 733,
		738, 745, 749, 751, 756, 763, 767, 769, 774, 781, 785, 787, 790, 793, 798,
		805, 809, 811, 816, 823, 827, 829, 834, 841, 845, 847, 852, 859, 863, 865,
		868, 871, 876, 883, 887, 889, 894, 901, 905, 907, 912, 919, 923, 925, 930,
		937, 941, 943, 946, 949, 954, 961, 965, 967, 972, 979, 983, 985, 990, 997,
		1001, 1003, 1008, 1015, 1019, 1021, 1024, 1027, 1032, 1039, 1043, 1045,
		1050, 1057, 1061, 1063, 1068, 1075, 1079, 1081, 1086, 1093, 1097, 1099,
		1102, 1105, 1110, 1117, 1121, 1123, 1128, 1135, 1139, 1141, 1146, 1153,
		1157, 1159, 1164, 1171, 1175, 1177, 1180, 1183, 1188, 1195, 1199, 1201,
		1206, 1213, 1217, 1219, 1224, 1231, 1235, 1237, 1242, 1249, 1253, 1255,
		1258, 1261, 1266, 1273, 1281, 1285, 1289, 1291, 1296, 1303, 1311, 1315,
		1319, 1321, 1324, 1327, 1332, 1339, 1347, 1351, 1355, 1357, 1362, 1369,
		1377, 1381, 1385, 1387, 1390, 1393, 1398, 1405, 1413, 1417, 1421, 1423,
		1428, 1435, 1443, 1447, 1451, 1453, 1456, 1459, 1464, 1471, 1475, 1477,
		1481, 1487, 1489, 1494,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CTEParserInit initializes any static state used to implement CTEParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCTEParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CTEParserInit() {
	staticData := &cteparserParserStaticData
	staticData.once.Do(cteparserParserInit)
}

// NewCTEParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCTEParser(input antlr.TokenStream) *CTEParser {
	CTEParserInit()
	this := new(CTEParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &cteparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "CTEParser.g4"

	return this
}

// CTEParser tokens.
const (
	CTEParserEOF                   = antlr.TokenEOF
	CTEParserVERSION               = 1
	CTEParserCTE_VERSION           = 2
	CTEParserWSL                   = 3
	CTEParserCOMMENT_LINE          = 4
	CTEParserCOMMENT_BLOCK         = 5
	CTEParserLIST_BEGIN            = 6
	CTEParserLIST_END              = 7
	CTEParserMAP_BEGIN             = 8
	CTEParserMAP_OR_RECORD_END     = 9
	CTEParserKV_SEPARATOR          = 10
	CTEParserNODE_BEGIN            = 11
	CTEParserEDGE_OR_NODE_END      = 12
	CTEParserNULL                  = 13
	CTEParserTRUE                  = 14
	CTEParserFALSE                 = 15
	CTEParserPINT_BIN              = 16
	CTEParserNINT_BIN              = 17
	CTEParserPINT_DEC              = 18
	CTEParserNINT_DEC              = 19
	CTEParserPINT_OCT              = 20
	CTEParserNINT_OCT              = 21
	CTEParserPINT_HEX              = 22
	CTEParserNINT_HEX              = 23
	CTEParserFLOAT_DEC             = 24
	CTEParserFLOAT_HEX             = 25
	CTEParserFLOAT_INF             = 26
	CTEParserFLOAT_NINF            = 27
	CTEParserFLOAT_NAN             = 28
	CTEParserFLOAT_SNAN            = 29
	CTEParserDATE                  = 30
	CTEParserTIME                  = 31
	CTEParserVALUE_UID             = 32
	CTEParserARRAY_BEGIN           = 33
	CTEParserSTRING_BEGIN          = 34
	CTEParserRREF_BEGIN            = 35
	CTEParserMARKER                = 36
	CTEParserREFERENCE             = 37
	CTEParserRECORD_TYPE_END       = 38
	CTEParserRID_BEGIN             = 39
	CTEParserEDGE_BEGIN            = 40
	CTEParserRECORD_TYPE_BEGIN     = 41
	CTEParserRECORD_BEGIN          = 42
	CTEParserARRAY_TYPE_I8         = 43
	CTEParserARRAY_TYPE_I8_EMPTY   = 44
	CTEParserARRAY_TYPE_I8B        = 45
	CTEParserARRAY_TYPE_I8O        = 46
	CTEParserARRAY_TYPE_I8X        = 47
	CTEParserARRAY_TYPE_I16        = 48
	CTEParserARRAY_TYPE_I16_EMPTY  = 49
	CTEParserARRAY_TYPE_I16B       = 50
	CTEParserARRAY_TYPE_I16O       = 51
	CTEParserARRAY_TYPE_I16X       = 52
	CTEParserARRAY_TYPE_I32        = 53
	CTEParserARRAY_TYPE_I32_EMPTY  = 54
	CTEParserARRAY_TYPE_I32B       = 55
	CTEParserARRAY_TYPE_I32O       = 56
	CTEParserARRAY_TYPE_I32X       = 57
	CTEParserARRAY_TYPE_I64        = 58
	CTEParserARRAY_TYPE_I64_EMPTY  = 59
	CTEParserARRAY_TYPE_I64B       = 60
	CTEParserARRAY_TYPE_I64O       = 61
	CTEParserARRAY_TYPE_I64X       = 62
	CTEParserARRAY_TYPE_U8         = 63
	CTEParserARRAY_TYPE_U8_EMPTY   = 64
	CTEParserARRAY_TYPE_U8B        = 65
	CTEParserARRAY_TYPE_U8O        = 66
	CTEParserARRAY_TYPE_U8X        = 67
	CTEParserARRAY_TYPE_U16        = 68
	CTEParserARRAY_TYPE_U16_EMPTY  = 69
	CTEParserARRAY_TYPE_U16B       = 70
	CTEParserARRAY_TYPE_U16O       = 71
	CTEParserARRAY_TYPE_U16X       = 72
	CTEParserARRAY_TYPE_U32        = 73
	CTEParserARRAY_TYPE_U32_EMPTY  = 74
	CTEParserARRAY_TYPE_U32B       = 75
	CTEParserARRAY_TYPE_U32O       = 76
	CTEParserARRAY_TYPE_U32X       = 77
	CTEParserARRAY_TYPE_U64        = 78
	CTEParserARRAY_TYPE_U64_EMPTY  = 79
	CTEParserARRAY_TYPE_U64B       = 80
	CTEParserARRAY_TYPE_U64O       = 81
	CTEParserARRAY_TYPE_U64X       = 82
	CTEParserARRAY_TYPE_F16        = 83
	CTEParserARRAY_TYPE_F16_EMPTY  = 84
	CTEParserARRAY_TYPE_F16X       = 85
	CTEParserARRAY_TYPE_F32        = 86
	CTEParserARRAY_TYPE_F32_EMPTY  = 87
	CTEParserARRAY_TYPE_F32X       = 88
	CTEParserARRAY_TYPE_F64        = 89
	CTEParserARRAY_TYPE_F64_EMPTY  = 90
	CTEParserARRAY_TYPE_F64X       = 91
	CTEParserARRAY_TYPE_UID        = 92
	CTEParserARRAY_TYPE_UID_EMPTY  = 93
	CTEParserARRAY_TYPE_BIT        = 94
	CTEParserARRAY_TYPE_BIT_EMPTY  = 95
	CTEParserARRAY_TYPE_CUSTOM     = 96
	CTEParserARRAY_TYPE_MEDIA      = 97
	CTEParserARRAY_I_ELEM_B        = 98
	CTEParserARRAY_I_ELEM_O        = 99
	CTEParserARRAY_I_ELEM_H        = 100
	CTEParserARRAY_I_ELEM_D        = 101
	CTEParserARRAY_I_END           = 102
	CTEParserARRAY_I_WSL           = 103
	CTEParserARRAY_U_ELEM_B        = 104
	CTEParserARRAY_U_ELEM_O        = 105
	CTEParserARRAY_U_ELEM_H        = 106
	CTEParserARRAY_U_ELEM_D        = 107
	CTEParserARRAY_U_END           = 108
	CTEParserARRAY_U_WSL           = 109
	CTEParserARRAY_F_ELEM_D        = 110
	CTEParserARRAY_F_ELEM_H        = 111
	CTEParserARRAY_F_NAN           = 112
	CTEParserARRAY_F_SNAN          = 113
	CTEParserARRAY_F_INF           = 114
	CTEParserARRAY_F_NINF          = 115
	CTEParserARRAY_F_END           = 116
	CTEParserARRAY_F_WSL           = 117
	CTEParserARRAY_F_X_ELEM        = 118
	CTEParserARRAY_F_X_NAN         = 119
	CTEParserARRAY_F_X_SNAN        = 120
	CTEParserARRAY_F_X_INF         = 121
	CTEParserARRAY_F_X_NINF        = 122
	CTEParserARRAY_F_X_END         = 123
	CTEParserARRAY_F_X_WSL         = 124
	CTEParserARRAY_I_B_ELEM        = 125
	CTEParserARRAY_I_B_END         = 126
	CTEParserARRAY_I_B_WSL         = 127
	CTEParserARRAY_I_O_ELEM        = 128
	CTEParserARRAY_I_O_END         = 129
	CTEParserARRAY_I_O_WSL         = 130
	CTEParserARRAY_I_X_ELEM        = 131
	CTEParserARRAY_I_X_END         = 132
	CTEParserARRAY_I_X_WSL         = 133
	CTEParserARRAY_U_B_ELEM        = 134
	CTEParserARRAY_U_B_END         = 135
	CTEParserARRAY_U_B_WSL         = 136
	CTEParserARRAY_U_O_ELEM        = 137
	CTEParserARRAY_U_O_END         = 138
	CTEParserARRAY_U_O_WSL         = 139
	CTEParserARRAY_U_X_ELEM        = 140
	CTEParserARRAY_U_X_END         = 141
	CTEParserARRAY_U_X_WSL         = 142
	CTEParserARRAY_UID_ELEM        = 143
	CTEParserARRAY_UID_END         = 144
	CTEParserARRAY_UID_WSL         = 145
	CTEParserARRAY_BIT_BITS        = 146
	CTEParserARRAY_BIT_END         = 147
	CTEParserARRAY_BIT_WSL         = 148
	CTEParserBYTES_ELEM            = 149
	CTEParserBYTES_END             = 150
	CTEParserBYTES_WS              = 151
	CTEParserSTRING_END            = 152
	CTEParserSTRING_ESCAPE         = 153
	CTEParserSTRING_CONTENTS       = 154
	CTEParserVERBATIM_INIT         = 155
	CTEParserCODEPOINT_INIT        = 156
	CTEParserCONTINUATION          = 157
	CTEParserESCAPE_CHAR           = 158
	CTEParserVERBATIM_SENTINEL     = 159
	CTEParserVERBATIM_SEPARATOR    = 160
	CTEParserVERBATIM_EMPTY        = 161
	CTEParserVERBATIM_CONTENTS     = 162
	CTEParserVERBATIM_END          = 163
	CTEParserCODEPOINT             = 164
	CTEParserCUSTOM_TYPE           = 165
	CTEParserCUSTOM_END            = 166
	CTEParserCUSTOM_TEXT           = 167
	CTEParserCUSTOM_BINARY         = 168
	CTEParserCT_STRING_END         = 169
	CTEParserCT_STRING_ESCAPE      = 170
	CTEParserCT_STRING_CONTENTS    = 171
	CTEParserMEDIA_TYPE            = 172
	CTEParserMEDIA_END             = 173
	CTEParserMEDIA_TEXT            = 174
	CTEParserMEDIA_BINARY          = 175
	CTEParserMEDIA_STRING_END      = 176
	CTEParserMEDIA_STRING_ESCAPE   = 177
	CTEParserMEDIA_STRING_CONTENTS = 178
)

// CTEParser rules.
const (
	CTEParserRULE_cte                 = 0
	CTEParserRULE_version             = 1
	CTEParserRULE_recordTypes         = 2
	CTEParserRULE_value               = 3
	CTEParserRULE_separator           = 4
	CTEParserRULE_commentLine         = 5
	CTEParserRULE_commentBlock        = 6
	CTEParserRULE_valueNull           = 7
	CTEParserRULE_valueUid            = 8
	CTEParserRULE_valueBool           = 9
	CTEParserRULE_valueInt            = 10
	CTEParserRULE_valueFloat          = 11
	CTEParserRULE_valueInf            = 12
	CTEParserRULE_valueNinf           = 13
	CTEParserRULE_valueNan            = 14
	CTEParserRULE_valueSnan           = 15
	CTEParserRULE_valueDate           = 16
	CTEParserRULE_valueTime           = 17
	CTEParserRULE_valueString         = 18
	CTEParserRULE_stringContents      = 19
	CTEParserRULE_stringEscape        = 20
	CTEParserRULE_verbatimSequence    = 21
	CTEParserRULE_verbatimContents    = 22
	CTEParserRULE_codepointSequence   = 23
	CTEParserRULE_codepointContents   = 24
	CTEParserRULE_escapeChar          = 25
	CTEParserRULE_customText          = 26
	CTEParserRULE_customEscape        = 27
	CTEParserRULE_customBinary        = 28
	CTEParserRULE_customType          = 29
	CTEParserRULE_mediaText           = 30
	CTEParserRULE_mediaEscape         = 31
	CTEParserRULE_mediaBinary         = 32
	CTEParserRULE_mediaType           = 33
	CTEParserRULE_valueRid            = 34
	CTEParserRULE_valueRemoteRef      = 35
	CTEParserRULE_markerID            = 36
	CTEParserRULE_marker              = 37
	CTEParserRULE_reference           = 38
	CTEParserRULE_containerMap        = 39
	CTEParserRULE_containerList       = 40
	CTEParserRULE_containerRecordType = 41
	CTEParserRULE_containerRecord     = 42
	CTEParserRULE_containerNode       = 43
	CTEParserRULE_containerEdge       = 44
	CTEParserRULE_kvPair              = 45
	CTEParserRULE_recordTypeBegin     = 46
	CTEParserRULE_recordBegin         = 47
	CTEParserRULE_arrayElemInt        = 48
	CTEParserRULE_arrayElemIntB       = 49
	CTEParserRULE_arrayElemIntO       = 50
	CTEParserRULE_arrayElemIntX       = 51
	CTEParserRULE_arrayElemUint       = 52
	CTEParserRULE_arrayElemUintB      = 53
	CTEParserRULE_arrayElemUintO      = 54
	CTEParserRULE_arrayElemUintX      = 55
	CTEParserRULE_arrayElemFloat      = 56
	CTEParserRULE_arrayElemFloatX     = 57
	CTEParserRULE_arrayElemNan        = 58
	CTEParserRULE_arrayElemSnan       = 59
	CTEParserRULE_arrayElemInf        = 60
	CTEParserRULE_arrayElemNinf       = 61
	CTEParserRULE_arrayElemUid        = 62
	CTEParserRULE_arrayElemBits       = 63
	CTEParserRULE_arrayElemByteX      = 64
	CTEParserRULE_arrayI8             = 65
	CTEParserRULE_arrayI16            = 66
	CTEParserRULE_arrayI32            = 67
	CTEParserRULE_arrayI64            = 68
	CTEParserRULE_arrayU8             = 69
	CTEParserRULE_arrayU16            = 70
	CTEParserRULE_arrayU32            = 71
	CTEParserRULE_arrayU64            = 72
	CTEParserRULE_arrayF16            = 73
	CTEParserRULE_arrayF32            = 74
	CTEParserRULE_arrayF64            = 75
	CTEParserRULE_arrayUid            = 76
	CTEParserRULE_arrayBit            = 77
)

// ICteContext is an interface to support dynamic dispatch.
type ICteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Version() IVersionContext
	AllWSL() []antlr.TerminalNode
	WSL(i int) antlr.TerminalNode
	Value() IValueContext
	EOF() antlr.TerminalNode
	RecordTypes() IRecordTypesContext
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext

	// IsCteContext differentiates from other interfaces.
	IsCteContext()
}

type CteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteContext() *CteContext {
	var p = new(CteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_cte
	return p
}

func (*CteContext) IsCteContext() {}

func NewCteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteContext {
	var p = new(CteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_cte

	return p
}

func (s *CteContext) GetParser() antlr.Parser { return s.parser }

func (s *CteContext) Version() IVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *CteContext) AllWSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserWSL)
}

func (s *CteContext) WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserWSL, i)
}

func (s *CteContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *CteContext) EOF() antlr.TerminalNode {
	return s.GetToken(CTEParserEOF, 0)
}

func (s *CteContext) RecordTypes() IRecordTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypesContext)
}

func (s *CteContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *CteContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *CteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCte(s)
	}
}

func (s *CteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCte(s)
	}
}

func (p *CTEParser) Cte() (localctx ICteContext) {
	this := p
	_ = this

	localctx = NewCteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CTEParserRULE_cte)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(156)
		p.Version()
	}
	{
		p.SetState(157)
		p.Match(CTEParserWSL)
	}
	p.SetState(159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CTEParserRECORD_TYPE_BEGIN {
		{
			p.SetState(158)
			p.RecordTypes()
		}

	}
	p.SetState(164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(161)
			p.Separator()
		}

		p.SetState(166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(167)
		p.Value()
	}
	p.SetState(169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CTEParserWSL {
		{
			p.SetState(168)
			p.Match(CTEParserWSL)
		}

	}
	{
		p.SetState(171)
		p.Match(CTEParserEOF)
	}

	return localctx
}

// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VERSION() antlr.TerminalNode

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_version
	return p
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(CTEParserVERSION, 0)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitVersion(s)
	}
}

func (p *CTEParser) Version() (localctx IVersionContext) {
	this := p
	_ = this

	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CTEParserRULE_version)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(173)
		p.Match(CTEParserVERSION)
	}

	return localctx
}

// IRecordTypesContext is an interface to support dynamic dispatch.
type IRecordTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllContainerRecordType() []IContainerRecordTypeContext
	ContainerRecordType(i int) IContainerRecordTypeContext
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext

	// IsRecordTypesContext differentiates from other interfaces.
	IsRecordTypesContext()
}

type RecordTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypesContext() *RecordTypesContext {
	var p = new(RecordTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_recordTypes
	return p
}

func (*RecordTypesContext) IsRecordTypesContext() {}

func NewRecordTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypesContext {
	var p = new(RecordTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_recordTypes

	return p
}

func (s *RecordTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypesContext) AllContainerRecordType() []IContainerRecordTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContainerRecordTypeContext); ok {
			len++
		}
	}

	tst := make([]IContainerRecordTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContainerRecordTypeContext); ok {
			tst[i] = t.(IContainerRecordTypeContext)
			i++
		}
	}

	return tst
}

func (s *RecordTypesContext) ContainerRecordType(i int) IContainerRecordTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainerRecordTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainerRecordTypeContext)
}

func (s *RecordTypesContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *RecordTypesContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *RecordTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterRecordTypes(s)
	}
}

func (s *RecordTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitRecordTypes(s)
	}
}

func (p *CTEParser) RecordTypes() (localctx IRecordTypesContext) {
	this := p
	_ = this

	localctx = NewRecordTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CTEParserRULE_recordTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(175)
		p.ContainerRecordType()
	}
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(177)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
				{
					p.SetState(176)
					p.Separator()
				}

				p.SetState(179)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(181)
				p.ContainerRecordType()
			}

		}
		p.SetState(187)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueString() IValueStringContext
	ValueRid() IValueRidContext
	ValueUid() IValueUidContext
	ValueBool() IValueBoolContext
	ValueNull() IValueNullContext
	ValueInt() IValueIntContext
	ValueFloat() IValueFloatContext
	ValueInf() IValueInfContext
	ValueNinf() IValueNinfContext
	ValueNan() IValueNanContext
	ValueSnan() IValueSnanContext
	ValueDate() IValueDateContext
	ValueTime() IValueTimeContext
	ArrayI8() IArrayI8Context
	ArrayI16() IArrayI16Context
	ArrayI32() IArrayI32Context
	ArrayI64() IArrayI64Context
	ArrayU8() IArrayU8Context
	ArrayU16() IArrayU16Context
	ArrayU32() IArrayU32Context
	ArrayU64() IArrayU64Context
	ArrayF16() IArrayF16Context
	ArrayF32() IArrayF32Context
	ArrayF64() IArrayF64Context
	ArrayUid() IArrayUidContext
	ArrayBit() IArrayBitContext
	CustomBinary() ICustomBinaryContext
	CustomText() ICustomTextContext
	MediaBinary() IMediaBinaryContext
	MediaText() IMediaTextContext
	ContainerMap() IContainerMapContext
	ContainerList() IContainerListContext
	ContainerEdge() IContainerEdgeContext
	ContainerNode() IContainerNodeContext
	ContainerRecord() IContainerRecordContext
	Marker() IMarkerContext
	Reference() IReferenceContext
	ValueRemoteRef() IValueRemoteRefContext

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) ValueString() IValueStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueStringContext)
}

func (s *ValueContext) ValueRid() IValueRidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueRidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueRidContext)
}

func (s *ValueContext) ValueUid() IValueUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueUidContext)
}

func (s *ValueContext) ValueBool() IValueBoolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueBoolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueBoolContext)
}

func (s *ValueContext) ValueNull() IValueNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueNullContext)
}

func (s *ValueContext) ValueInt() IValueIntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueIntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueIntContext)
}

func (s *ValueContext) ValueFloat() IValueFloatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueFloatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueFloatContext)
}

func (s *ValueContext) ValueInf() IValueInfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueInfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueInfContext)
}

func (s *ValueContext) ValueNinf() IValueNinfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueNinfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueNinfContext)
}

func (s *ValueContext) ValueNan() IValueNanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueNanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueNanContext)
}

func (s *ValueContext) ValueSnan() IValueSnanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueSnanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueSnanContext)
}

func (s *ValueContext) ValueDate() IValueDateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueDateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueDateContext)
}

func (s *ValueContext) ValueTime() IValueTimeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTimeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTimeContext)
}

func (s *ValueContext) ArrayI8() IArrayI8Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayI8Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayI8Context)
}

func (s *ValueContext) ArrayI16() IArrayI16Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayI16Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayI16Context)
}

func (s *ValueContext) ArrayI32() IArrayI32Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayI32Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayI32Context)
}

func (s *ValueContext) ArrayI64() IArrayI64Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayI64Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayI64Context)
}

func (s *ValueContext) ArrayU8() IArrayU8Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayU8Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayU8Context)
}

func (s *ValueContext) ArrayU16() IArrayU16Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayU16Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayU16Context)
}

func (s *ValueContext) ArrayU32() IArrayU32Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayU32Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayU32Context)
}

func (s *ValueContext) ArrayU64() IArrayU64Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayU64Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayU64Context)
}

func (s *ValueContext) ArrayF16() IArrayF16Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayF16Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayF16Context)
}

func (s *ValueContext) ArrayF32() IArrayF32Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayF32Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayF32Context)
}

func (s *ValueContext) ArrayF64() IArrayF64Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayF64Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayF64Context)
}

func (s *ValueContext) ArrayUid() IArrayUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayUidContext)
}

func (s *ValueContext) ArrayBit() IArrayBitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayBitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayBitContext)
}

func (s *ValueContext) CustomBinary() ICustomBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomBinaryContext)
}

func (s *ValueContext) CustomText() ICustomTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomTextContext)
}

func (s *ValueContext) MediaBinary() IMediaBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMediaBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMediaBinaryContext)
}

func (s *ValueContext) MediaText() IMediaTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMediaTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMediaTextContext)
}

func (s *ValueContext) ContainerMap() IContainerMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainerMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainerMapContext)
}

func (s *ValueContext) ContainerList() IContainerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainerListContext)
}

func (s *ValueContext) ContainerEdge() IContainerEdgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainerEdgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainerEdgeContext)
}

func (s *ValueContext) ContainerNode() IContainerNodeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainerNodeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainerNodeContext)
}

func (s *ValueContext) ContainerRecord() IContainerRecordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainerRecordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainerRecordContext)
}

func (s *ValueContext) Marker() IMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerContext)
}

func (s *ValueContext) Reference() IReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ValueContext) ValueRemoteRef() IValueRemoteRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueRemoteRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueRemoteRefContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *CTEParser) Value() (localctx IValueContext) {
	this := p
	_ = this

	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CTEParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(188)
			p.ValueString()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(189)
			p.ValueRid()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(190)
			p.ValueUid()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(191)
			p.ValueBool()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(192)
			p.ValueNull()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(193)
			p.ValueInt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(194)
			p.ValueFloat()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(195)
			p.ValueInf()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(196)
			p.ValueNinf()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(197)
			p.ValueNan()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(198)
			p.ValueSnan()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(199)
			p.ValueDate()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(200)
			p.ValueTime()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(201)
			p.ArrayI8()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(202)
			p.ArrayI16()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(203)
			p.ArrayI32()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(204)
			p.ArrayI64()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(205)
			p.ArrayU8()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(206)
			p.ArrayU16()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(207)
			p.ArrayU32()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(208)
			p.ArrayU64()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(209)
			p.ArrayF16()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(210)
			p.ArrayF32()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(211)
			p.ArrayF64()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(212)
			p.ArrayUid()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(213)
			p.ArrayBit()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(214)
			p.CustomBinary()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(215)
			p.CustomText()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(216)
			p.MediaBinary()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(217)
			p.MediaText()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(218)
			p.ContainerMap()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(219)
			p.ContainerList()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(220)
			p.ContainerEdge()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(221)
			p.ContainerNode()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(222)
			p.ContainerRecord()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(223)
			p.Marker()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(224)
			p.Reference()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(225)
			p.ValueRemoteRef()
		}

	}

	return localctx
}

// ISeparatorContext is an interface to support dynamic dispatch.
type ISeparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommentLine() ICommentLineContext
	CommentBlock() ICommentBlockContext
	WSL() antlr.TerminalNode

	// IsSeparatorContext differentiates from other interfaces.
	IsSeparatorContext()
}

type SeparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeparatorContext() *SeparatorContext {
	var p = new(SeparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_separator
	return p
}

func (*SeparatorContext) IsSeparatorContext() {}

func NewSeparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SeparatorContext {
	var p = new(SeparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_separator

	return p
}

func (s *SeparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SeparatorContext) CommentLine() ICommentLineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentLineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentLineContext)
}

func (s *SeparatorContext) CommentBlock() ICommentBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentBlockContext)
}

func (s *SeparatorContext) WSL() antlr.TerminalNode {
	return s.GetToken(CTEParserWSL, 0)
}

func (s *SeparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SeparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterSeparator(s)
	}
}

func (s *SeparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitSeparator(s)
	}
}

func (p *CTEParser) Separator() (localctx ISeparatorContext) {
	this := p
	_ = this

	localctx = NewSeparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CTEParserRULE_separator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(231)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserCOMMENT_LINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(228)
			p.CommentLine()
		}

	case CTEParserCOMMENT_BLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(229)
			p.CommentBlock()
		}

	case CTEParserWSL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(230)
			p.Match(CTEParserWSL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICommentLineContext is an interface to support dynamic dispatch.
type ICommentLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT_LINE() antlr.TerminalNode

	// IsCommentLineContext differentiates from other interfaces.
	IsCommentLineContext()
}

type CommentLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentLineContext() *CommentLineContext {
	var p = new(CommentLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_commentLine
	return p
}

func (*CommentLineContext) IsCommentLineContext() {}

func NewCommentLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentLineContext {
	var p = new(CommentLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_commentLine

	return p
}

func (s *CommentLineContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentLineContext) COMMENT_LINE() antlr.TerminalNode {
	return s.GetToken(CTEParserCOMMENT_LINE, 0)
}

func (s *CommentLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCommentLine(s)
	}
}

func (s *CommentLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCommentLine(s)
	}
}

func (p *CTEParser) CommentLine() (localctx ICommentLineContext) {
	this := p
	_ = this

	localctx = NewCommentLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CTEParserRULE_commentLine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.Match(CTEParserCOMMENT_LINE)
	}

	return localctx
}

// ICommentBlockContext is an interface to support dynamic dispatch.
type ICommentBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT_BLOCK() antlr.TerminalNode

	// IsCommentBlockContext differentiates from other interfaces.
	IsCommentBlockContext()
}

type CommentBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentBlockContext() *CommentBlockContext {
	var p = new(CommentBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_commentBlock
	return p
}

func (*CommentBlockContext) IsCommentBlockContext() {}

func NewCommentBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentBlockContext {
	var p = new(CommentBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_commentBlock

	return p
}

func (s *CommentBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentBlockContext) COMMENT_BLOCK() antlr.TerminalNode {
	return s.GetToken(CTEParserCOMMENT_BLOCK, 0)
}

func (s *CommentBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCommentBlock(s)
	}
}

func (s *CommentBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCommentBlock(s)
	}
}

func (p *CTEParser) CommentBlock() (localctx ICommentBlockContext) {
	this := p
	_ = this

	localctx = NewCommentBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CTEParserRULE_commentBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(235)
		p.Match(CTEParserCOMMENT_BLOCK)
	}

	return localctx
}

// IValueNullContext is an interface to support dynamic dispatch.
type IValueNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode

	// IsValueNullContext differentiates from other interfaces.
	IsValueNullContext()
}

type ValueNullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueNullContext() *ValueNullContext {
	var p = new(ValueNullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueNull
	return p
}

func (*ValueNullContext) IsValueNullContext() {}

func NewValueNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueNullContext {
	var p = new(ValueNullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueNull

	return p
}

func (s *ValueNullContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(CTEParserNULL, 0)
}

func (s *ValueNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueNull(s)
	}
}

func (s *ValueNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueNull(s)
	}
}

func (p *CTEParser) ValueNull() (localctx IValueNullContext) {
	this := p
	_ = this

	localctx = NewValueNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CTEParserRULE_valueNull)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Match(CTEParserNULL)
	}

	return localctx
}

// IValueUidContext is an interface to support dynamic dispatch.
type IValueUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE_UID() antlr.TerminalNode

	// IsValueUidContext differentiates from other interfaces.
	IsValueUidContext()
}

type ValueUidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueUidContext() *ValueUidContext {
	var p = new(ValueUidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueUid
	return p
}

func (*ValueUidContext) IsValueUidContext() {}

func NewValueUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueUidContext {
	var p = new(ValueUidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueUid

	return p
}

func (s *ValueUidContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueUidContext) VALUE_UID() antlr.TerminalNode {
	return s.GetToken(CTEParserVALUE_UID, 0)
}

func (s *ValueUidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueUidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueUidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueUid(s)
	}
}

func (s *ValueUidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueUid(s)
	}
}

func (p *CTEParser) ValueUid() (localctx IValueUidContext) {
	this := p
	_ = this

	localctx = NewValueUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CTEParserRULE_valueUid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.Match(CTEParserVALUE_UID)
	}

	return localctx
}

// IValueBoolContext is an interface to support dynamic dispatch.
type IValueBoolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsValueBoolContext differentiates from other interfaces.
	IsValueBoolContext()
}

type ValueBoolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueBoolContext() *ValueBoolContext {
	var p = new(ValueBoolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueBool
	return p
}

func (*ValueBoolContext) IsValueBoolContext() {}

func NewValueBoolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueBoolContext {
	var p = new(ValueBoolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueBool

	return p
}

func (s *ValueBoolContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueBoolContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CTEParserTRUE, 0)
}

func (s *ValueBoolContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CTEParserFALSE, 0)
}

func (s *ValueBoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueBoolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueBoolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueBool(s)
	}
}

func (s *ValueBoolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueBool(s)
	}
}

func (p *CTEParser) ValueBool() (localctx IValueBoolContext) {
	this := p
	_ = this

	localctx = NewValueBoolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CTEParserRULE_valueBool)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserTRUE || _la == CTEParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IValueIntContext is an interface to support dynamic dispatch.
type IValueIntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PINT_BIN() antlr.TerminalNode
	NINT_BIN() antlr.TerminalNode
	PINT_OCT() antlr.TerminalNode
	NINT_OCT() antlr.TerminalNode
	PINT_DEC() antlr.TerminalNode
	NINT_DEC() antlr.TerminalNode
	PINT_HEX() antlr.TerminalNode
	NINT_HEX() antlr.TerminalNode

	// IsValueIntContext differentiates from other interfaces.
	IsValueIntContext()
}

type ValueIntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueIntContext() *ValueIntContext {
	var p = new(ValueIntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueInt
	return p
}

func (*ValueIntContext) IsValueIntContext() {}

func NewValueIntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueIntContext {
	var p = new(ValueIntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueInt

	return p
}

func (s *ValueIntContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueIntContext) PINT_BIN() antlr.TerminalNode {
	return s.GetToken(CTEParserPINT_BIN, 0)
}

func (s *ValueIntContext) NINT_BIN() antlr.TerminalNode {
	return s.GetToken(CTEParserNINT_BIN, 0)
}

func (s *ValueIntContext) PINT_OCT() antlr.TerminalNode {
	return s.GetToken(CTEParserPINT_OCT, 0)
}

func (s *ValueIntContext) NINT_OCT() antlr.TerminalNode {
	return s.GetToken(CTEParserNINT_OCT, 0)
}

func (s *ValueIntContext) PINT_DEC() antlr.TerminalNode {
	return s.GetToken(CTEParserPINT_DEC, 0)
}

func (s *ValueIntContext) NINT_DEC() antlr.TerminalNode {
	return s.GetToken(CTEParserNINT_DEC, 0)
}

func (s *ValueIntContext) PINT_HEX() antlr.TerminalNode {
	return s.GetToken(CTEParserPINT_HEX, 0)
}

func (s *ValueIntContext) NINT_HEX() antlr.TerminalNode {
	return s.GetToken(CTEParserNINT_HEX, 0)
}

func (s *ValueIntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueIntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueIntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueInt(s)
	}
}

func (s *ValueIntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueInt(s)
	}
}

func (p *CTEParser) ValueInt() (localctx IValueIntContext) {
	this := p
	_ = this

	localctx = NewValueIntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CTEParserRULE_valueInt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(243)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16711680) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IValueFloatContext is an interface to support dynamic dispatch.
type IValueFloatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT_DEC() antlr.TerminalNode
	FLOAT_HEX() antlr.TerminalNode

	// IsValueFloatContext differentiates from other interfaces.
	IsValueFloatContext()
}

type ValueFloatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueFloatContext() *ValueFloatContext {
	var p = new(ValueFloatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueFloat
	return p
}

func (*ValueFloatContext) IsValueFloatContext() {}

func NewValueFloatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueFloatContext {
	var p = new(ValueFloatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueFloat

	return p
}

func (s *ValueFloatContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueFloatContext) FLOAT_DEC() antlr.TerminalNode {
	return s.GetToken(CTEParserFLOAT_DEC, 0)
}

func (s *ValueFloatContext) FLOAT_HEX() antlr.TerminalNode {
	return s.GetToken(CTEParserFLOAT_HEX, 0)
}

func (s *ValueFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueFloatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueFloat(s)
	}
}

func (s *ValueFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueFloat(s)
	}
}

func (p *CTEParser) ValueFloat() (localctx IValueFloatContext) {
	this := p
	_ = this

	localctx = NewValueFloatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CTEParserRULE_valueFloat)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(245)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserFLOAT_DEC || _la == CTEParserFLOAT_HEX) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IValueInfContext is an interface to support dynamic dispatch.
type IValueInfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT_INF() antlr.TerminalNode

	// IsValueInfContext differentiates from other interfaces.
	IsValueInfContext()
}

type ValueInfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueInfContext() *ValueInfContext {
	var p = new(ValueInfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueInf
	return p
}

func (*ValueInfContext) IsValueInfContext() {}

func NewValueInfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueInfContext {
	var p = new(ValueInfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueInf

	return p
}

func (s *ValueInfContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueInfContext) FLOAT_INF() antlr.TerminalNode {
	return s.GetToken(CTEParserFLOAT_INF, 0)
}

func (s *ValueInfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueInfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueInfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueInf(s)
	}
}

func (s *ValueInfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueInf(s)
	}
}

func (p *CTEParser) ValueInf() (localctx IValueInfContext) {
	this := p
	_ = this

	localctx = NewValueInfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CTEParserRULE_valueInf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(247)
		p.Match(CTEParserFLOAT_INF)
	}

	return localctx
}

// IValueNinfContext is an interface to support dynamic dispatch.
type IValueNinfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT_NINF() antlr.TerminalNode

	// IsValueNinfContext differentiates from other interfaces.
	IsValueNinfContext()
}

type ValueNinfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueNinfContext() *ValueNinfContext {
	var p = new(ValueNinfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueNinf
	return p
}

func (*ValueNinfContext) IsValueNinfContext() {}

func NewValueNinfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueNinfContext {
	var p = new(ValueNinfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueNinf

	return p
}

func (s *ValueNinfContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueNinfContext) FLOAT_NINF() antlr.TerminalNode {
	return s.GetToken(CTEParserFLOAT_NINF, 0)
}

func (s *ValueNinfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueNinfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueNinfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueNinf(s)
	}
}

func (s *ValueNinfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueNinf(s)
	}
}

func (p *CTEParser) ValueNinf() (localctx IValueNinfContext) {
	this := p
	_ = this

	localctx = NewValueNinfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CTEParserRULE_valueNinf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(249)
		p.Match(CTEParserFLOAT_NINF)
	}

	return localctx
}

// IValueNanContext is an interface to support dynamic dispatch.
type IValueNanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT_NAN() antlr.TerminalNode

	// IsValueNanContext differentiates from other interfaces.
	IsValueNanContext()
}

type ValueNanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueNanContext() *ValueNanContext {
	var p = new(ValueNanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueNan
	return p
}

func (*ValueNanContext) IsValueNanContext() {}

func NewValueNanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueNanContext {
	var p = new(ValueNanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueNan

	return p
}

func (s *ValueNanContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueNanContext) FLOAT_NAN() antlr.TerminalNode {
	return s.GetToken(CTEParserFLOAT_NAN, 0)
}

func (s *ValueNanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueNanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueNanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueNan(s)
	}
}

func (s *ValueNanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueNan(s)
	}
}

func (p *CTEParser) ValueNan() (localctx IValueNanContext) {
	this := p
	_ = this

	localctx = NewValueNanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CTEParserRULE_valueNan)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.Match(CTEParserFLOAT_NAN)
	}

	return localctx
}

// IValueSnanContext is an interface to support dynamic dispatch.
type IValueSnanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT_SNAN() antlr.TerminalNode

	// IsValueSnanContext differentiates from other interfaces.
	IsValueSnanContext()
}

type ValueSnanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSnanContext() *ValueSnanContext {
	var p = new(ValueSnanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueSnan
	return p
}

func (*ValueSnanContext) IsValueSnanContext() {}

func NewValueSnanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSnanContext {
	var p = new(ValueSnanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueSnan

	return p
}

func (s *ValueSnanContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSnanContext) FLOAT_SNAN() antlr.TerminalNode {
	return s.GetToken(CTEParserFLOAT_SNAN, 0)
}

func (s *ValueSnanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSnanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSnanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueSnan(s)
	}
}

func (s *ValueSnanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueSnan(s)
	}
}

func (p *CTEParser) ValueSnan() (localctx IValueSnanContext) {
	this := p
	_ = this

	localctx = NewValueSnanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CTEParserRULE_valueSnan)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(253)
		p.Match(CTEParserFLOAT_SNAN)
	}

	return localctx
}

// IValueDateContext is an interface to support dynamic dispatch.
type IValueDateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode

	// IsValueDateContext differentiates from other interfaces.
	IsValueDateContext()
}

type ValueDateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueDateContext() *ValueDateContext {
	var p = new(ValueDateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueDate
	return p
}

func (*ValueDateContext) IsValueDateContext() {}

func NewValueDateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueDateContext {
	var p = new(ValueDateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueDate

	return p
}

func (s *ValueDateContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueDateContext) DATE() antlr.TerminalNode {
	return s.GetToken(CTEParserDATE, 0)
}

func (s *ValueDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueDateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueDateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueDate(s)
	}
}

func (s *ValueDateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueDate(s)
	}
}

func (p *CTEParser) ValueDate() (localctx IValueDateContext) {
	this := p
	_ = this

	localctx = NewValueDateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CTEParserRULE_valueDate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(CTEParserDATE)
	}

	return localctx
}

// IValueTimeContext is an interface to support dynamic dispatch.
type IValueTimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TIME() antlr.TerminalNode

	// IsValueTimeContext differentiates from other interfaces.
	IsValueTimeContext()
}

type ValueTimeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueTimeContext() *ValueTimeContext {
	var p = new(ValueTimeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueTime
	return p
}

func (*ValueTimeContext) IsValueTimeContext() {}

func NewValueTimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueTimeContext {
	var p = new(ValueTimeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueTime

	return p
}

func (s *ValueTimeContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueTimeContext) TIME() antlr.TerminalNode {
	return s.GetToken(CTEParserTIME, 0)
}

func (s *ValueTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueTimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueTime(s)
	}
}

func (s *ValueTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueTime(s)
	}
}

func (p *CTEParser) ValueTime() (localctx IValueTimeContext) {
	this := p
	_ = this

	localctx = NewValueTimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CTEParserRULE_valueTime)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(CTEParserTIME)
	}

	return localctx
}

// IValueStringContext is an interface to support dynamic dispatch.
type IValueStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_BEGIN() antlr.TerminalNode
	STRING_END() antlr.TerminalNode
	AllStringContents() []IStringContentsContext
	StringContents(i int) IStringContentsContext
	AllStringEscape() []IStringEscapeContext
	StringEscape(i int) IStringEscapeContext

	// IsValueStringContext differentiates from other interfaces.
	IsValueStringContext()
}

type ValueStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueStringContext() *ValueStringContext {
	var p = new(ValueStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueString
	return p
}

func (*ValueStringContext) IsValueStringContext() {}

func NewValueStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueStringContext {
	var p = new(ValueStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueString

	return p
}

func (s *ValueStringContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueStringContext) STRING_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserSTRING_BEGIN, 0)
}

func (s *ValueStringContext) STRING_END() antlr.TerminalNode {
	return s.GetToken(CTEParserSTRING_END, 0)
}

func (s *ValueStringContext) AllStringContents() []IStringContentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContentsContext); ok {
			len++
		}
	}

	tst := make([]IStringContentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContentsContext); ok {
			tst[i] = t.(IStringContentsContext)
			i++
		}
	}

	return tst
}

func (s *ValueStringContext) StringContents(i int) IStringContentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContentsContext)
}

func (s *ValueStringContext) AllStringEscape() []IStringEscapeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringEscapeContext); ok {
			len++
		}
	}

	tst := make([]IStringEscapeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringEscapeContext); ok {
			tst[i] = t.(IStringEscapeContext)
			i++
		}
	}

	return tst
}

func (s *ValueStringContext) StringEscape(i int) IStringEscapeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringEscapeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringEscapeContext)
}

func (s *ValueStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueString(s)
	}
}

func (s *ValueStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueString(s)
	}
}

func (p *CTEParser) ValueString() (localctx IValueStringContext) {
	this := p
	_ = this

	localctx = NewValueStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CTEParserRULE_valueString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Match(CTEParserSTRING_BEGIN)
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-153)) & ^0x3f) == 0 && ((int64(1)<<(_la-153))&262147) != 0 {
		p.SetState(262)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserSTRING_CONTENTS, CTEParserCT_STRING_CONTENTS:
			{
				p.SetState(260)
				p.StringContents()
			}

		case CTEParserSTRING_ESCAPE:
			{
				p.SetState(261)
				p.StringEscape()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(267)
		p.Match(CTEParserSTRING_END)
	}

	return localctx
}

// IStringContentsContext is an interface to support dynamic dispatch.
type IStringContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_CONTENTS() antlr.TerminalNode
	CT_STRING_CONTENTS() antlr.TerminalNode

	// IsStringContentsContext differentiates from other interfaces.
	IsStringContentsContext()
}

type StringContentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContentsContext() *StringContentsContext {
	var p = new(StringContentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_stringContents
	return p
}

func (*StringContentsContext) IsStringContentsContext() {}

func NewStringContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContentsContext {
	var p = new(StringContentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_stringContents

	return p
}

func (s *StringContentsContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContentsContext) STRING_CONTENTS() antlr.TerminalNode {
	return s.GetToken(CTEParserSTRING_CONTENTS, 0)
}

func (s *StringContentsContext) CT_STRING_CONTENTS() antlr.TerminalNode {
	return s.GetToken(CTEParserCT_STRING_CONTENTS, 0)
}

func (s *StringContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterStringContents(s)
	}
}

func (s *StringContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitStringContents(s)
	}
}

func (p *CTEParser) StringContents() (localctx IStringContentsContext) {
	this := p
	_ = this

	localctx = NewStringContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CTEParserRULE_stringContents)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserSTRING_CONTENTS || _la == CTEParserCT_STRING_CONTENTS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringEscapeContext is an interface to support dynamic dispatch.
type IStringEscapeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_ESCAPE() antlr.TerminalNode
	VerbatimSequence() IVerbatimSequenceContext
	CodepointSequence() ICodepointSequenceContext
	EscapeChar() IEscapeCharContext
	CONTINUATION() antlr.TerminalNode

	// IsStringEscapeContext differentiates from other interfaces.
	IsStringEscapeContext()
}

type StringEscapeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringEscapeContext() *StringEscapeContext {
	var p = new(StringEscapeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_stringEscape
	return p
}

func (*StringEscapeContext) IsStringEscapeContext() {}

func NewStringEscapeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringEscapeContext {
	var p = new(StringEscapeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_stringEscape

	return p
}

func (s *StringEscapeContext) GetParser() antlr.Parser { return s.parser }

func (s *StringEscapeContext) STRING_ESCAPE() antlr.TerminalNode {
	return s.GetToken(CTEParserSTRING_ESCAPE, 0)
}

func (s *StringEscapeContext) VerbatimSequence() IVerbatimSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVerbatimSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVerbatimSequenceContext)
}

func (s *StringEscapeContext) CodepointSequence() ICodepointSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodepointSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodepointSequenceContext)
}

func (s *StringEscapeContext) EscapeChar() IEscapeCharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEscapeCharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEscapeCharContext)
}

func (s *StringEscapeContext) CONTINUATION() antlr.TerminalNode {
	return s.GetToken(CTEParserCONTINUATION, 0)
}

func (s *StringEscapeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringEscapeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringEscapeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterStringEscape(s)
	}
}

func (s *StringEscapeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitStringEscape(s)
	}
}

func (p *CTEParser) StringEscape() (localctx IStringEscapeContext) {
	this := p
	_ = this

	localctx = NewStringEscapeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CTEParserRULE_stringEscape)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(271)
		p.Match(CTEParserSTRING_ESCAPE)
	}
	p.SetState(276)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserVERBATIM_INIT:
		{
			p.SetState(272)
			p.VerbatimSequence()
		}

	case CTEParserCODEPOINT_INIT:
		{
			p.SetState(273)
			p.CodepointSequence()
		}

	case CTEParserESCAPE_CHAR:
		{
			p.SetState(274)
			p.EscapeChar()
		}

	case CTEParserCONTINUATION:
		{
			p.SetState(275)
			p.Match(CTEParserCONTINUATION)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVerbatimSequenceContext is an interface to support dynamic dispatch.
type IVerbatimSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VERBATIM_INIT() antlr.TerminalNode
	VERBATIM_SENTINEL() antlr.TerminalNode
	VERBATIM_SEPARATOR() antlr.TerminalNode
	VERBATIM_EMPTY() antlr.TerminalNode
	VerbatimContents() IVerbatimContentsContext
	VERBATIM_END() antlr.TerminalNode

	// IsVerbatimSequenceContext differentiates from other interfaces.
	IsVerbatimSequenceContext()
}

type VerbatimSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVerbatimSequenceContext() *VerbatimSequenceContext {
	var p = new(VerbatimSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_verbatimSequence
	return p
}

func (*VerbatimSequenceContext) IsVerbatimSequenceContext() {}

func NewVerbatimSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VerbatimSequenceContext {
	var p = new(VerbatimSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_verbatimSequence

	return p
}

func (s *VerbatimSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *VerbatimSequenceContext) VERBATIM_INIT() antlr.TerminalNode {
	return s.GetToken(CTEParserVERBATIM_INIT, 0)
}

func (s *VerbatimSequenceContext) VERBATIM_SENTINEL() antlr.TerminalNode {
	return s.GetToken(CTEParserVERBATIM_SENTINEL, 0)
}

func (s *VerbatimSequenceContext) VERBATIM_SEPARATOR() antlr.TerminalNode {
	return s.GetToken(CTEParserVERBATIM_SEPARATOR, 0)
}

func (s *VerbatimSequenceContext) VERBATIM_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserVERBATIM_EMPTY, 0)
}

func (s *VerbatimSequenceContext) VerbatimContents() IVerbatimContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVerbatimContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVerbatimContentsContext)
}

func (s *VerbatimSequenceContext) VERBATIM_END() antlr.TerminalNode {
	return s.GetToken(CTEParserVERBATIM_END, 0)
}

func (s *VerbatimSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VerbatimSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VerbatimSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterVerbatimSequence(s)
	}
}

func (s *VerbatimSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitVerbatimSequence(s)
	}
}

func (p *CTEParser) VerbatimSequence() (localctx IVerbatimSequenceContext) {
	this := p
	_ = this

	localctx = NewVerbatimSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CTEParserRULE_verbatimSequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(278)
		p.Match(CTEParserVERBATIM_INIT)
	}
	{
		p.SetState(279)
		p.Match(CTEParserVERBATIM_SENTINEL)
	}
	{
		p.SetState(280)
		p.Match(CTEParserVERBATIM_SEPARATOR)
	}
	p.SetState(285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserVERBATIM_CONTENTS:
		{
			p.SetState(281)
			p.VerbatimContents()
		}
		{
			p.SetState(282)
			p.Match(CTEParserVERBATIM_END)
		}

	case CTEParserVERBATIM_EMPTY:
		{
			p.SetState(284)
			p.Match(CTEParserVERBATIM_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVerbatimContentsContext is an interface to support dynamic dispatch.
type IVerbatimContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VERBATIM_CONTENTS() antlr.TerminalNode

	// IsVerbatimContentsContext differentiates from other interfaces.
	IsVerbatimContentsContext()
}

type VerbatimContentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVerbatimContentsContext() *VerbatimContentsContext {
	var p = new(VerbatimContentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_verbatimContents
	return p
}

func (*VerbatimContentsContext) IsVerbatimContentsContext() {}

func NewVerbatimContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VerbatimContentsContext {
	var p = new(VerbatimContentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_verbatimContents

	return p
}

func (s *VerbatimContentsContext) GetParser() antlr.Parser { return s.parser }

func (s *VerbatimContentsContext) VERBATIM_CONTENTS() antlr.TerminalNode {
	return s.GetToken(CTEParserVERBATIM_CONTENTS, 0)
}

func (s *VerbatimContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VerbatimContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VerbatimContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterVerbatimContents(s)
	}
}

func (s *VerbatimContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitVerbatimContents(s)
	}
}

func (p *CTEParser) VerbatimContents() (localctx IVerbatimContentsContext) {
	this := p
	_ = this

	localctx = NewVerbatimContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CTEParserRULE_verbatimContents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(CTEParserVERBATIM_CONTENTS)
	}

	return localctx
}

// ICodepointSequenceContext is an interface to support dynamic dispatch.
type ICodepointSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CODEPOINT_INIT() antlr.TerminalNode
	CodepointContents() ICodepointContentsContext

	// IsCodepointSequenceContext differentiates from other interfaces.
	IsCodepointSequenceContext()
}

type CodepointSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodepointSequenceContext() *CodepointSequenceContext {
	var p = new(CodepointSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_codepointSequence
	return p
}

func (*CodepointSequenceContext) IsCodepointSequenceContext() {}

func NewCodepointSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodepointSequenceContext {
	var p = new(CodepointSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_codepointSequence

	return p
}

func (s *CodepointSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CodepointSequenceContext) CODEPOINT_INIT() antlr.TerminalNode {
	return s.GetToken(CTEParserCODEPOINT_INIT, 0)
}

func (s *CodepointSequenceContext) CodepointContents() ICodepointContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodepointContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodepointContentsContext)
}

func (s *CodepointSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodepointSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodepointSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCodepointSequence(s)
	}
}

func (s *CodepointSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCodepointSequence(s)
	}
}

func (p *CTEParser) CodepointSequence() (localctx ICodepointSequenceContext) {
	this := p
	_ = this

	localctx = NewCodepointSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CTEParserRULE_codepointSequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.Match(CTEParserCODEPOINT_INIT)
	}
	{
		p.SetState(290)
		p.CodepointContents()
	}

	return localctx
}

// ICodepointContentsContext is an interface to support dynamic dispatch.
type ICodepointContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CODEPOINT() antlr.TerminalNode

	// IsCodepointContentsContext differentiates from other interfaces.
	IsCodepointContentsContext()
}

type CodepointContentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodepointContentsContext() *CodepointContentsContext {
	var p = new(CodepointContentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_codepointContents
	return p
}

func (*CodepointContentsContext) IsCodepointContentsContext() {}

func NewCodepointContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodepointContentsContext {
	var p = new(CodepointContentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_codepointContents

	return p
}

func (s *CodepointContentsContext) GetParser() antlr.Parser { return s.parser }

func (s *CodepointContentsContext) CODEPOINT() antlr.TerminalNode {
	return s.GetToken(CTEParserCODEPOINT, 0)
}

func (s *CodepointContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodepointContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodepointContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCodepointContents(s)
	}
}

func (s *CodepointContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCodepointContents(s)
	}
}

func (p *CTEParser) CodepointContents() (localctx ICodepointContentsContext) {
	this := p
	_ = this

	localctx = NewCodepointContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CTEParserRULE_codepointContents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(292)
		p.Match(CTEParserCODEPOINT)
	}

	return localctx
}

// IEscapeCharContext is an interface to support dynamic dispatch.
type IEscapeCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ESCAPE_CHAR() antlr.TerminalNode

	// IsEscapeCharContext differentiates from other interfaces.
	IsEscapeCharContext()
}

type EscapeCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapeCharContext() *EscapeCharContext {
	var p = new(EscapeCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_escapeChar
	return p
}

func (*EscapeCharContext) IsEscapeCharContext() {}

func NewEscapeCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapeCharContext {
	var p = new(EscapeCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_escapeChar

	return p
}

func (s *EscapeCharContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapeCharContext) ESCAPE_CHAR() antlr.TerminalNode {
	return s.GetToken(CTEParserESCAPE_CHAR, 0)
}

func (s *EscapeCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapeCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EscapeCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterEscapeChar(s)
	}
}

func (s *EscapeCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitEscapeChar(s)
	}
}

func (p *CTEParser) EscapeChar() (localctx IEscapeCharContext) {
	this := p
	_ = this

	localctx = NewEscapeCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CTEParserRULE_escapeChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(294)
		p.Match(CTEParserESCAPE_CHAR)
	}

	return localctx
}

// ICustomTextContext is an interface to support dynamic dispatch.
type ICustomTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_CUSTOM() antlr.TerminalNode
	CustomType() ICustomTypeContext
	CUSTOM_TEXT() antlr.TerminalNode
	CT_STRING_END() antlr.TerminalNode
	AllStringContents() []IStringContentsContext
	StringContents(i int) IStringContentsContext
	AllCustomEscape() []ICustomEscapeContext
	CustomEscape(i int) ICustomEscapeContext

	// IsCustomTextContext differentiates from other interfaces.
	IsCustomTextContext()
}

type CustomTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomTextContext() *CustomTextContext {
	var p = new(CustomTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_customText
	return p
}

func (*CustomTextContext) IsCustomTextContext() {}

func NewCustomTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomTextContext {
	var p = new(CustomTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_customText

	return p
}

func (s *CustomTextContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomTextContext) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *CustomTextContext) ARRAY_TYPE_CUSTOM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_CUSTOM, 0)
}

func (s *CustomTextContext) CustomType() ICustomTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomTypeContext)
}

func (s *CustomTextContext) CUSTOM_TEXT() antlr.TerminalNode {
	return s.GetToken(CTEParserCUSTOM_TEXT, 0)
}

func (s *CustomTextContext) CT_STRING_END() antlr.TerminalNode {
	return s.GetToken(CTEParserCT_STRING_END, 0)
}

func (s *CustomTextContext) AllStringContents() []IStringContentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContentsContext); ok {
			len++
		}
	}

	tst := make([]IStringContentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContentsContext); ok {
			tst[i] = t.(IStringContentsContext)
			i++
		}
	}

	return tst
}

func (s *CustomTextContext) StringContents(i int) IStringContentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContentsContext)
}

func (s *CustomTextContext) AllCustomEscape() []ICustomEscapeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICustomEscapeContext); ok {
			len++
		}
	}

	tst := make([]ICustomEscapeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICustomEscapeContext); ok {
			tst[i] = t.(ICustomEscapeContext)
			i++
		}
	}

	return tst
}

func (s *CustomTextContext) CustomEscape(i int) ICustomEscapeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomEscapeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomEscapeContext)
}

func (s *CustomTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCustomText(s)
	}
}

func (s *CustomTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCustomText(s)
	}
}

func (p *CTEParser) CustomText() (localctx ICustomTextContext) {
	this := p
	_ = this

	localctx = NewCustomTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CTEParserRULE_customText)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.Match(CTEParserARRAY_BEGIN)
	}
	{
		p.SetState(297)
		p.Match(CTEParserARRAY_TYPE_CUSTOM)
	}
	{
		p.SetState(298)
		p.CustomType()
	}
	{
		p.SetState(299)
		p.Match(CTEParserCUSTOM_TEXT)
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-154)) & ^0x3f) == 0 && ((int64(1)<<(_la-154))&196609) != 0 {
		p.SetState(302)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserSTRING_CONTENTS, CTEParserCT_STRING_CONTENTS:
			{
				p.SetState(300)
				p.StringContents()
			}

		case CTEParserCT_STRING_ESCAPE:
			{
				p.SetState(301)
				p.CustomEscape()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(307)
		p.Match(CTEParserCT_STRING_END)
	}

	return localctx
}

// ICustomEscapeContext is an interface to support dynamic dispatch.
type ICustomEscapeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CT_STRING_ESCAPE() antlr.TerminalNode
	VerbatimSequence() IVerbatimSequenceContext
	CodepointSequence() ICodepointSequenceContext
	EscapeChar() IEscapeCharContext
	CONTINUATION() antlr.TerminalNode

	// IsCustomEscapeContext differentiates from other interfaces.
	IsCustomEscapeContext()
}

type CustomEscapeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomEscapeContext() *CustomEscapeContext {
	var p = new(CustomEscapeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_customEscape
	return p
}

func (*CustomEscapeContext) IsCustomEscapeContext() {}

func NewCustomEscapeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomEscapeContext {
	var p = new(CustomEscapeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_customEscape

	return p
}

func (s *CustomEscapeContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomEscapeContext) CT_STRING_ESCAPE() antlr.TerminalNode {
	return s.GetToken(CTEParserCT_STRING_ESCAPE, 0)
}

func (s *CustomEscapeContext) VerbatimSequence() IVerbatimSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVerbatimSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVerbatimSequenceContext)
}

func (s *CustomEscapeContext) CodepointSequence() ICodepointSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodepointSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodepointSequenceContext)
}

func (s *CustomEscapeContext) EscapeChar() IEscapeCharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEscapeCharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEscapeCharContext)
}

func (s *CustomEscapeContext) CONTINUATION() antlr.TerminalNode {
	return s.GetToken(CTEParserCONTINUATION, 0)
}

func (s *CustomEscapeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomEscapeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomEscapeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCustomEscape(s)
	}
}

func (s *CustomEscapeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCustomEscape(s)
	}
}

func (p *CTEParser) CustomEscape() (localctx ICustomEscapeContext) {
	this := p
	_ = this

	localctx = NewCustomEscapeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CTEParserRULE_customEscape)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Match(CTEParserCT_STRING_ESCAPE)
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserVERBATIM_INIT:
		{
			p.SetState(310)
			p.VerbatimSequence()
		}

	case CTEParserCODEPOINT_INIT:
		{
			p.SetState(311)
			p.CodepointSequence()
		}

	case CTEParserESCAPE_CHAR:
		{
			p.SetState(312)
			p.EscapeChar()
		}

	case CTEParserCONTINUATION:
		{
			p.SetState(313)
			p.Match(CTEParserCONTINUATION)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICustomBinaryContext is an interface to support dynamic dispatch.
type ICustomBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_CUSTOM() antlr.TerminalNode
	CustomType() ICustomTypeContext
	CUSTOM_BINARY() antlr.TerminalNode
	AllArrayElemByteX() []IArrayElemByteXContext
	ArrayElemByteX(i int) IArrayElemByteXContext
	BYTES_END() antlr.TerminalNode
	AllBYTES_WS() []antlr.TerminalNode
	BYTES_WS(i int) antlr.TerminalNode
	CUSTOM_END() antlr.TerminalNode

	// IsCustomBinaryContext differentiates from other interfaces.
	IsCustomBinaryContext()
}

type CustomBinaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomBinaryContext() *CustomBinaryContext {
	var p = new(CustomBinaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_customBinary
	return p
}

func (*CustomBinaryContext) IsCustomBinaryContext() {}

func NewCustomBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomBinaryContext {
	var p = new(CustomBinaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_customBinary

	return p
}

func (s *CustomBinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomBinaryContext) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *CustomBinaryContext) ARRAY_TYPE_CUSTOM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_CUSTOM, 0)
}

func (s *CustomBinaryContext) CustomType() ICustomTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomTypeContext)
}

func (s *CustomBinaryContext) CUSTOM_BINARY() antlr.TerminalNode {
	return s.GetToken(CTEParserCUSTOM_BINARY, 0)
}

func (s *CustomBinaryContext) AllArrayElemByteX() []IArrayElemByteXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemByteXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemByteXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemByteXContext); ok {
			tst[i] = t.(IArrayElemByteXContext)
			i++
		}
	}

	return tst
}

func (s *CustomBinaryContext) ArrayElemByteX(i int) IArrayElemByteXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemByteXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemByteXContext)
}

func (s *CustomBinaryContext) BYTES_END() antlr.TerminalNode {
	return s.GetToken(CTEParserBYTES_END, 0)
}

func (s *CustomBinaryContext) AllBYTES_WS() []antlr.TerminalNode {
	return s.GetTokens(CTEParserBYTES_WS)
}

func (s *CustomBinaryContext) BYTES_WS(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserBYTES_WS, i)
}

func (s *CustomBinaryContext) CUSTOM_END() antlr.TerminalNode {
	return s.GetToken(CTEParserCUSTOM_END, 0)
}

func (s *CustomBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomBinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCustomBinary(s)
	}
}

func (s *CustomBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCustomBinary(s)
	}
}

func (p *CTEParser) CustomBinary() (localctx ICustomBinaryContext) {
	this := p
	_ = this

	localctx = NewCustomBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CTEParserRULE_customBinary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(335)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(316)
			p.Match(CTEParserARRAY_BEGIN)
		}
		{
			p.SetState(317)
			p.Match(CTEParserARRAY_TYPE_CUSTOM)
		}
		{
			p.SetState(318)
			p.CustomType()
		}
		{
			p.SetState(319)
			p.Match(CTEParserCUSTOM_BINARY)
		}
		{
			p.SetState(320)
			p.ArrayElemByteX()
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CTEParserBYTES_WS {
			{
				p.SetState(321)
				p.Match(CTEParserBYTES_WS)
			}
			{
				p.SetState(322)
				p.ArrayElemByteX()
			}

			p.SetState(327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(328)
			p.Match(CTEParserBYTES_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(330)
			p.Match(CTEParserARRAY_BEGIN)
		}
		{
			p.SetState(331)
			p.Match(CTEParserARRAY_TYPE_CUSTOM)
		}
		{
			p.SetState(332)
			p.CustomType()
		}
		{
			p.SetState(333)
			p.Match(CTEParserCUSTOM_END)
		}

	}

	return localctx
}

// ICustomTypeContext is an interface to support dynamic dispatch.
type ICustomTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CUSTOM_TYPE() antlr.TerminalNode

	// IsCustomTypeContext differentiates from other interfaces.
	IsCustomTypeContext()
}

type CustomTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomTypeContext() *CustomTypeContext {
	var p = new(CustomTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_customType
	return p
}

func (*CustomTypeContext) IsCustomTypeContext() {}

func NewCustomTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomTypeContext {
	var p = new(CustomTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_customType

	return p
}

func (s *CustomTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomTypeContext) CUSTOM_TYPE() antlr.TerminalNode {
	return s.GetToken(CTEParserCUSTOM_TYPE, 0)
}

func (s *CustomTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterCustomType(s)
	}
}

func (s *CustomTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitCustomType(s)
	}
}

func (p *CTEParser) CustomType() (localctx ICustomTypeContext) {
	this := p
	_ = this

	localctx = NewCustomTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CTEParserRULE_customType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.Match(CTEParserCUSTOM_TYPE)
	}

	return localctx
}

// IMediaTextContext is an interface to support dynamic dispatch.
type IMediaTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_MEDIA() antlr.TerminalNode
	MediaType() IMediaTypeContext
	MEDIA_TEXT() antlr.TerminalNode
	MEDIA_STRING_END() antlr.TerminalNode
	AllStringContents() []IStringContentsContext
	StringContents(i int) IStringContentsContext
	AllMediaEscape() []IMediaEscapeContext
	MediaEscape(i int) IMediaEscapeContext

	// IsMediaTextContext differentiates from other interfaces.
	IsMediaTextContext()
}

type MediaTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaTextContext() *MediaTextContext {
	var p = new(MediaTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_mediaText
	return p
}

func (*MediaTextContext) IsMediaTextContext() {}

func NewMediaTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaTextContext {
	var p = new(MediaTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_mediaText

	return p
}

func (s *MediaTextContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaTextContext) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *MediaTextContext) ARRAY_TYPE_MEDIA() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_MEDIA, 0)
}

func (s *MediaTextContext) MediaType() IMediaTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMediaTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMediaTypeContext)
}

func (s *MediaTextContext) MEDIA_TEXT() antlr.TerminalNode {
	return s.GetToken(CTEParserMEDIA_TEXT, 0)
}

func (s *MediaTextContext) MEDIA_STRING_END() antlr.TerminalNode {
	return s.GetToken(CTEParserMEDIA_STRING_END, 0)
}

func (s *MediaTextContext) AllStringContents() []IStringContentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContentsContext); ok {
			len++
		}
	}

	tst := make([]IStringContentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContentsContext); ok {
			tst[i] = t.(IStringContentsContext)
			i++
		}
	}

	return tst
}

func (s *MediaTextContext) StringContents(i int) IStringContentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContentsContext)
}

func (s *MediaTextContext) AllMediaEscape() []IMediaEscapeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMediaEscapeContext); ok {
			len++
		}
	}

	tst := make([]IMediaEscapeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMediaEscapeContext); ok {
			tst[i] = t.(IMediaEscapeContext)
			i++
		}
	}

	return tst
}

func (s *MediaTextContext) MediaEscape(i int) IMediaEscapeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMediaEscapeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMediaEscapeContext)
}

func (s *MediaTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterMediaText(s)
	}
}

func (s *MediaTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitMediaText(s)
	}
}

func (p *CTEParser) MediaText() (localctx IMediaTextContext) {
	this := p
	_ = this

	localctx = NewMediaTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CTEParserRULE_mediaText)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.Match(CTEParserARRAY_BEGIN)
	}
	{
		p.SetState(340)
		p.Match(CTEParserARRAY_TYPE_MEDIA)
	}
	{
		p.SetState(341)
		p.MediaType()
	}
	{
		p.SetState(342)
		p.Match(CTEParserMEDIA_TEXT)
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-154)) & ^0x3f) == 0 && ((int64(1)<<(_la-154))&8519681) != 0 {
		p.SetState(345)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserSTRING_CONTENTS, CTEParserCT_STRING_CONTENTS:
			{
				p.SetState(343)
				p.StringContents()
			}

		case CTEParserMEDIA_STRING_ESCAPE:
			{
				p.SetState(344)
				p.MediaEscape()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(350)
		p.Match(CTEParserMEDIA_STRING_END)
	}

	return localctx
}

// IMediaEscapeContext is an interface to support dynamic dispatch.
type IMediaEscapeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MEDIA_STRING_ESCAPE() antlr.TerminalNode
	VerbatimSequence() IVerbatimSequenceContext
	CodepointSequence() ICodepointSequenceContext
	EscapeChar() IEscapeCharContext
	CONTINUATION() antlr.TerminalNode

	// IsMediaEscapeContext differentiates from other interfaces.
	IsMediaEscapeContext()
}

type MediaEscapeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaEscapeContext() *MediaEscapeContext {
	var p = new(MediaEscapeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_mediaEscape
	return p
}

func (*MediaEscapeContext) IsMediaEscapeContext() {}

func NewMediaEscapeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaEscapeContext {
	var p = new(MediaEscapeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_mediaEscape

	return p
}

func (s *MediaEscapeContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaEscapeContext) MEDIA_STRING_ESCAPE() antlr.TerminalNode {
	return s.GetToken(CTEParserMEDIA_STRING_ESCAPE, 0)
}

func (s *MediaEscapeContext) VerbatimSequence() IVerbatimSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVerbatimSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVerbatimSequenceContext)
}

func (s *MediaEscapeContext) CodepointSequence() ICodepointSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodepointSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodepointSequenceContext)
}

func (s *MediaEscapeContext) EscapeChar() IEscapeCharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEscapeCharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEscapeCharContext)
}

func (s *MediaEscapeContext) CONTINUATION() antlr.TerminalNode {
	return s.GetToken(CTEParserCONTINUATION, 0)
}

func (s *MediaEscapeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaEscapeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaEscapeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterMediaEscape(s)
	}
}

func (s *MediaEscapeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitMediaEscape(s)
	}
}

func (p *CTEParser) MediaEscape() (localctx IMediaEscapeContext) {
	this := p
	_ = this

	localctx = NewMediaEscapeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CTEParserRULE_mediaEscape)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(352)
		p.Match(CTEParserMEDIA_STRING_ESCAPE)
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserVERBATIM_INIT:
		{
			p.SetState(353)
			p.VerbatimSequence()
		}

	case CTEParserCODEPOINT_INIT:
		{
			p.SetState(354)
			p.CodepointSequence()
		}

	case CTEParserESCAPE_CHAR:
		{
			p.SetState(355)
			p.EscapeChar()
		}

	case CTEParserCONTINUATION:
		{
			p.SetState(356)
			p.Match(CTEParserCONTINUATION)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMediaBinaryContext is an interface to support dynamic dispatch.
type IMediaBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_MEDIA() antlr.TerminalNode
	MediaType() IMediaTypeContext
	MEDIA_BINARY() antlr.TerminalNode
	AllArrayElemByteX() []IArrayElemByteXContext
	ArrayElemByteX(i int) IArrayElemByteXContext
	BYTES_END() antlr.TerminalNode
	AllBYTES_WS() []antlr.TerminalNode
	BYTES_WS(i int) antlr.TerminalNode
	MEDIA_END() antlr.TerminalNode

	// IsMediaBinaryContext differentiates from other interfaces.
	IsMediaBinaryContext()
}

type MediaBinaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaBinaryContext() *MediaBinaryContext {
	var p = new(MediaBinaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_mediaBinary
	return p
}

func (*MediaBinaryContext) IsMediaBinaryContext() {}

func NewMediaBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaBinaryContext {
	var p = new(MediaBinaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_mediaBinary

	return p
}

func (s *MediaBinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaBinaryContext) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *MediaBinaryContext) ARRAY_TYPE_MEDIA() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_MEDIA, 0)
}

func (s *MediaBinaryContext) MediaType() IMediaTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMediaTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMediaTypeContext)
}

func (s *MediaBinaryContext) MEDIA_BINARY() antlr.TerminalNode {
	return s.GetToken(CTEParserMEDIA_BINARY, 0)
}

func (s *MediaBinaryContext) AllArrayElemByteX() []IArrayElemByteXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemByteXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemByteXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemByteXContext); ok {
			tst[i] = t.(IArrayElemByteXContext)
			i++
		}
	}

	return tst
}

func (s *MediaBinaryContext) ArrayElemByteX(i int) IArrayElemByteXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemByteXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemByteXContext)
}

func (s *MediaBinaryContext) BYTES_END() antlr.TerminalNode {
	return s.GetToken(CTEParserBYTES_END, 0)
}

func (s *MediaBinaryContext) AllBYTES_WS() []antlr.TerminalNode {
	return s.GetTokens(CTEParserBYTES_WS)
}

func (s *MediaBinaryContext) BYTES_WS(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserBYTES_WS, i)
}

func (s *MediaBinaryContext) MEDIA_END() antlr.TerminalNode {
	return s.GetToken(CTEParserMEDIA_END, 0)
}

func (s *MediaBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaBinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterMediaBinary(s)
	}
}

func (s *MediaBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitMediaBinary(s)
	}
}

func (p *CTEParser) MediaBinary() (localctx IMediaBinaryContext) {
	this := p
	_ = this

	localctx = NewMediaBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CTEParserRULE_mediaBinary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(359)
			p.Match(CTEParserARRAY_BEGIN)
		}
		{
			p.SetState(360)
			p.Match(CTEParserARRAY_TYPE_MEDIA)
		}
		{
			p.SetState(361)
			p.MediaType()
		}
		{
			p.SetState(362)
			p.Match(CTEParserMEDIA_BINARY)
		}
		{
			p.SetState(363)
			p.ArrayElemByteX()
		}
		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CTEParserBYTES_WS {
			{
				p.SetState(364)
				p.Match(CTEParserBYTES_WS)
			}
			{
				p.SetState(365)
				p.ArrayElemByteX()
			}

			p.SetState(370)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(371)
			p.Match(CTEParserBYTES_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(373)
			p.Match(CTEParserARRAY_BEGIN)
		}
		{
			p.SetState(374)
			p.Match(CTEParserARRAY_TYPE_MEDIA)
		}
		{
			p.SetState(375)
			p.MediaType()
		}
		{
			p.SetState(376)
			p.Match(CTEParserMEDIA_END)
		}

	}

	return localctx
}

// IMediaTypeContext is an interface to support dynamic dispatch.
type IMediaTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MEDIA_TYPE() antlr.TerminalNode

	// IsMediaTypeContext differentiates from other interfaces.
	IsMediaTypeContext()
}

type MediaTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaTypeContext() *MediaTypeContext {
	var p = new(MediaTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_mediaType
	return p
}

func (*MediaTypeContext) IsMediaTypeContext() {}

func NewMediaTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaTypeContext {
	var p = new(MediaTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_mediaType

	return p
}

func (s *MediaTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaTypeContext) MEDIA_TYPE() antlr.TerminalNode {
	return s.GetToken(CTEParserMEDIA_TYPE, 0)
}

func (s *MediaTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterMediaType(s)
	}
}

func (s *MediaTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitMediaType(s)
	}
}

func (p *CTEParser) MediaType() (localctx IMediaTypeContext) {
	this := p
	_ = this

	localctx = NewMediaTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CTEParserRULE_mediaType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(CTEParserMEDIA_TYPE)
	}

	return localctx
}

// IValueRidContext is an interface to support dynamic dispatch.
type IValueRidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RID_BEGIN() antlr.TerminalNode
	STRING_END() antlr.TerminalNode
	AllStringContents() []IStringContentsContext
	StringContents(i int) IStringContentsContext
	AllStringEscape() []IStringEscapeContext
	StringEscape(i int) IStringEscapeContext

	// IsValueRidContext differentiates from other interfaces.
	IsValueRidContext()
}

type ValueRidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueRidContext() *ValueRidContext {
	var p = new(ValueRidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueRid
	return p
}

func (*ValueRidContext) IsValueRidContext() {}

func NewValueRidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueRidContext {
	var p = new(ValueRidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueRid

	return p
}

func (s *ValueRidContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueRidContext) RID_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserRID_BEGIN, 0)
}

func (s *ValueRidContext) STRING_END() antlr.TerminalNode {
	return s.GetToken(CTEParserSTRING_END, 0)
}

func (s *ValueRidContext) AllStringContents() []IStringContentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContentsContext); ok {
			len++
		}
	}

	tst := make([]IStringContentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContentsContext); ok {
			tst[i] = t.(IStringContentsContext)
			i++
		}
	}

	return tst
}

func (s *ValueRidContext) StringContents(i int) IStringContentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContentsContext)
}

func (s *ValueRidContext) AllStringEscape() []IStringEscapeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringEscapeContext); ok {
			len++
		}
	}

	tst := make([]IStringEscapeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringEscapeContext); ok {
			tst[i] = t.(IStringEscapeContext)
			i++
		}
	}

	return tst
}

func (s *ValueRidContext) StringEscape(i int) IStringEscapeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringEscapeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringEscapeContext)
}

func (s *ValueRidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueRidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueRidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueRid(s)
	}
}

func (s *ValueRidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueRid(s)
	}
}

func (p *CTEParser) ValueRid() (localctx IValueRidContext) {
	this := p
	_ = this

	localctx = NewValueRidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CTEParserRULE_valueRid)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.Match(CTEParserRID_BEGIN)
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-153)) & ^0x3f) == 0 && ((int64(1)<<(_la-153))&262147) != 0 {
		p.SetState(385)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserSTRING_CONTENTS, CTEParserCT_STRING_CONTENTS:
			{
				p.SetState(383)
				p.StringContents()
			}

		case CTEParserSTRING_ESCAPE:
			{
				p.SetState(384)
				p.StringEscape()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(390)
		p.Match(CTEParserSTRING_END)
	}

	return localctx
}

// IValueRemoteRefContext is an interface to support dynamic dispatch.
type IValueRemoteRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RREF_BEGIN() antlr.TerminalNode
	STRING_END() antlr.TerminalNode
	AllStringContents() []IStringContentsContext
	StringContents(i int) IStringContentsContext
	AllStringEscape() []IStringEscapeContext
	StringEscape(i int) IStringEscapeContext

	// IsValueRemoteRefContext differentiates from other interfaces.
	IsValueRemoteRefContext()
}

type ValueRemoteRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueRemoteRefContext() *ValueRemoteRefContext {
	var p = new(ValueRemoteRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_valueRemoteRef
	return p
}

func (*ValueRemoteRefContext) IsValueRemoteRefContext() {}

func NewValueRemoteRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueRemoteRefContext {
	var p = new(ValueRemoteRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_valueRemoteRef

	return p
}

func (s *ValueRemoteRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueRemoteRefContext) RREF_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserRREF_BEGIN, 0)
}

func (s *ValueRemoteRefContext) STRING_END() antlr.TerminalNode {
	return s.GetToken(CTEParserSTRING_END, 0)
}

func (s *ValueRemoteRefContext) AllStringContents() []IStringContentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContentsContext); ok {
			len++
		}
	}

	tst := make([]IStringContentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContentsContext); ok {
			tst[i] = t.(IStringContentsContext)
			i++
		}
	}

	return tst
}

func (s *ValueRemoteRefContext) StringContents(i int) IStringContentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContentsContext)
}

func (s *ValueRemoteRefContext) AllStringEscape() []IStringEscapeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringEscapeContext); ok {
			len++
		}
	}

	tst := make([]IStringEscapeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringEscapeContext); ok {
			tst[i] = t.(IStringEscapeContext)
			i++
		}
	}

	return tst
}

func (s *ValueRemoteRefContext) StringEscape(i int) IStringEscapeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringEscapeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringEscapeContext)
}

func (s *ValueRemoteRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueRemoteRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueRemoteRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterValueRemoteRef(s)
	}
}

func (s *ValueRemoteRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitValueRemoteRef(s)
	}
}

func (p *CTEParser) ValueRemoteRef() (localctx IValueRemoteRefContext) {
	this := p
	_ = this

	localctx = NewValueRemoteRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CTEParserRULE_valueRemoteRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(CTEParserRREF_BEGIN)
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-153)) & ^0x3f) == 0 && ((int64(1)<<(_la-153))&262147) != 0 {
		p.SetState(395)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserSTRING_CONTENTS, CTEParserCT_STRING_CONTENTS:
			{
				p.SetState(393)
				p.StringContents()
			}

		case CTEParserSTRING_ESCAPE:
			{
				p.SetState(394)
				p.StringEscape()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(400)
		p.Match(CTEParserSTRING_END)
	}

	return localctx
}

// IMarkerIDContext is an interface to support dynamic dispatch.
type IMarkerIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MARKER() antlr.TerminalNode

	// IsMarkerIDContext differentiates from other interfaces.
	IsMarkerIDContext()
}

type MarkerIDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMarkerIDContext() *MarkerIDContext {
	var p = new(MarkerIDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_markerID
	return p
}

func (*MarkerIDContext) IsMarkerIDContext() {}

func NewMarkerIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MarkerIDContext {
	var p = new(MarkerIDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_markerID

	return p
}

func (s *MarkerIDContext) GetParser() antlr.Parser { return s.parser }

func (s *MarkerIDContext) MARKER() antlr.TerminalNode {
	return s.GetToken(CTEParserMARKER, 0)
}

func (s *MarkerIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MarkerIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MarkerIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterMarkerID(s)
	}
}

func (s *MarkerIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitMarkerID(s)
	}
}

func (p *CTEParser) MarkerID() (localctx IMarkerIDContext) {
	this := p
	_ = this

	localctx = NewMarkerIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CTEParserRULE_markerID)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(CTEParserMARKER)
	}

	return localctx
}

// IMarkerContext is an interface to support dynamic dispatch.
type IMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MarkerID() IMarkerIDContext
	Value() IValueContext

	// IsMarkerContext differentiates from other interfaces.
	IsMarkerContext()
}

type MarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMarkerContext() *MarkerContext {
	var p = new(MarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_marker
	return p
}

func (*MarkerContext) IsMarkerContext() {}

func NewMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MarkerContext {
	var p = new(MarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_marker

	return p
}

func (s *MarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *MarkerContext) MarkerID() IMarkerIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerIDContext)
}

func (s *MarkerContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *MarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterMarker(s)
	}
}

func (s *MarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitMarker(s)
	}
}

func (p *CTEParser) Marker() (localctx IMarkerContext) {
	this := p
	_ = this

	localctx = NewMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CTEParserRULE_marker)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.MarkerID()
	}
	{
		p.SetState(405)
		p.Value()
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFERENCE() antlr.TerminalNode

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(CTEParserREFERENCE, 0)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *CTEParser) Reference() (localctx IReferenceContext) {
	this := p
	_ = this

	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CTEParserRULE_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Match(CTEParserREFERENCE)
	}

	return localctx
}

// IContainerMapContext is an interface to support dynamic dispatch.
type IContainerMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP_BEGIN() antlr.TerminalNode
	MAP_OR_RECORD_END() antlr.TerminalNode
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext
	AllKvPair() []IKvPairContext
	KvPair(i int) IKvPairContext

	// IsContainerMapContext differentiates from other interfaces.
	IsContainerMapContext()
}

type ContainerMapContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainerMapContext() *ContainerMapContext {
	var p = new(ContainerMapContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_containerMap
	return p
}

func (*ContainerMapContext) IsContainerMapContext() {}

func NewContainerMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainerMapContext {
	var p = new(ContainerMapContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_containerMap

	return p
}

func (s *ContainerMapContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainerMapContext) MAP_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserMAP_BEGIN, 0)
}

func (s *ContainerMapContext) MAP_OR_RECORD_END() antlr.TerminalNode {
	return s.GetToken(CTEParserMAP_OR_RECORD_END, 0)
}

func (s *ContainerMapContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *ContainerMapContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *ContainerMapContext) AllKvPair() []IKvPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKvPairContext); ok {
			len++
		}
	}

	tst := make([]IKvPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKvPairContext); ok {
			tst[i] = t.(IKvPairContext)
			i++
		}
	}

	return tst
}

func (s *ContainerMapContext) KvPair(i int) IKvPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKvPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKvPairContext)
}

func (s *ContainerMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainerMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainerMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterContainerMap(s)
	}
}

func (s *ContainerMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitContainerMap(s)
	}
}

func (p *CTEParser) ContainerMap() (localctx IContainerMapContext) {
	this := p
	_ = this

	localctx = NewContainerMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CTEParserRULE_containerMap)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(CTEParserMAP_BEGIN)
	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(410)
				p.Separator()
			}

		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6322191853888) != 0 {
		{
			p.SetState(416)
			p.KvPair()
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(418)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
					{
						p.SetState(417)
						p.Separator()
					}

					p.SetState(420)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(422)
					p.KvPair()
				}

			}
			p.SetState(428)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
		}

	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(431)
			p.Separator()
		}

		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(437)
		p.Match(CTEParserMAP_OR_RECORD_END)
	}

	return localctx
}

// IContainerListContext is an interface to support dynamic dispatch.
type IContainerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIST_BEGIN() antlr.TerminalNode
	LIST_END() antlr.TerminalNode
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext
	AllValue() []IValueContext
	Value(i int) IValueContext

	// IsContainerListContext differentiates from other interfaces.
	IsContainerListContext()
}

type ContainerListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainerListContext() *ContainerListContext {
	var p = new(ContainerListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_containerList
	return p
}

func (*ContainerListContext) IsContainerListContext() {}

func NewContainerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainerListContext {
	var p = new(ContainerListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_containerList

	return p
}

func (s *ContainerListContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainerListContext) LIST_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserLIST_BEGIN, 0)
}

func (s *ContainerListContext) LIST_END() antlr.TerminalNode {
	return s.GetToken(CTEParserLIST_END, 0)
}

func (s *ContainerListContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *ContainerListContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *ContainerListContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ContainerListContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContainerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterContainerList(s)
	}
}

func (s *ContainerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitContainerList(s)
	}
}

func (p *CTEParser) ContainerList() (localctx IContainerListContext) {
	this := p
	_ = this

	localctx = NewContainerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CTEParserRULE_containerList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.Match(CTEParserLIST_BEGIN)
	}
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(440)
				p.Separator()
			}

		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6322191853888) != 0 {
		{
			p.SetState(446)
			p.Value()
		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(448)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
					{
						p.SetState(447)
						p.Separator()
					}

					p.SetState(450)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(452)
					p.Value()
				}

			}
			p.SetState(458)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())
		}

	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(461)
			p.Separator()
		}

		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(467)
		p.Match(CTEParserLIST_END)
	}

	return localctx
}

// IContainerRecordTypeContext is an interface to support dynamic dispatch.
type IContainerRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordTypeBegin() IRecordTypeBeginContext
	RECORD_TYPE_END() antlr.TerminalNode
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext
	AllValue() []IValueContext
	Value(i int) IValueContext

	// IsContainerRecordTypeContext differentiates from other interfaces.
	IsContainerRecordTypeContext()
}

type ContainerRecordTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainerRecordTypeContext() *ContainerRecordTypeContext {
	var p = new(ContainerRecordTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_containerRecordType
	return p
}

func (*ContainerRecordTypeContext) IsContainerRecordTypeContext() {}

func NewContainerRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainerRecordTypeContext {
	var p = new(ContainerRecordTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_containerRecordType

	return p
}

func (s *ContainerRecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainerRecordTypeContext) RecordTypeBegin() IRecordTypeBeginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypeBeginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypeBeginContext)
}

func (s *ContainerRecordTypeContext) RECORD_TYPE_END() antlr.TerminalNode {
	return s.GetToken(CTEParserRECORD_TYPE_END, 0)
}

func (s *ContainerRecordTypeContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *ContainerRecordTypeContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *ContainerRecordTypeContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ContainerRecordTypeContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContainerRecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainerRecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainerRecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterContainerRecordType(s)
	}
}

func (s *ContainerRecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitContainerRecordType(s)
	}
}

func (p *CTEParser) ContainerRecordType() (localctx IContainerRecordTypeContext) {
	this := p
	_ = this

	localctx = NewContainerRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CTEParserRULE_containerRecordType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.RecordTypeBegin()
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(470)
				p.Separator()
			}

		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6322191853888) != 0 {
		{
			p.SetState(476)
			p.Value()
		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(478)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
					{
						p.SetState(477)
						p.Separator()
					}

					p.SetState(480)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(482)
					p.Value()
				}

			}
			p.SetState(488)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
		}

	}
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(491)
			p.Separator()
		}

		p.SetState(496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(497)
		p.Match(CTEParserRECORD_TYPE_END)
	}

	return localctx
}

// IContainerRecordContext is an interface to support dynamic dispatch.
type IContainerRecordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordBegin() IRecordBeginContext
	MAP_OR_RECORD_END() antlr.TerminalNode
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext
	AllValue() []IValueContext
	Value(i int) IValueContext

	// IsContainerRecordContext differentiates from other interfaces.
	IsContainerRecordContext()
}

type ContainerRecordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainerRecordContext() *ContainerRecordContext {
	var p = new(ContainerRecordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_containerRecord
	return p
}

func (*ContainerRecordContext) IsContainerRecordContext() {}

func NewContainerRecordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainerRecordContext {
	var p = new(ContainerRecordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_containerRecord

	return p
}

func (s *ContainerRecordContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainerRecordContext) RecordBegin() IRecordBeginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordBeginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordBeginContext)
}

func (s *ContainerRecordContext) MAP_OR_RECORD_END() antlr.TerminalNode {
	return s.GetToken(CTEParserMAP_OR_RECORD_END, 0)
}

func (s *ContainerRecordContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *ContainerRecordContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *ContainerRecordContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ContainerRecordContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContainerRecordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainerRecordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainerRecordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterContainerRecord(s)
	}
}

func (s *ContainerRecordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitContainerRecord(s)
	}
}

func (p *CTEParser) ContainerRecord() (localctx IContainerRecordContext) {
	this := p
	_ = this

	localctx = NewContainerRecordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CTEParserRULE_containerRecord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.RecordBegin()
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(500)
				p.Separator()
			}

		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6322191853888) != 0 {
		{
			p.SetState(506)
			p.Value()
		}
		p.SetState(516)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(508)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
					{
						p.SetState(507)
						p.Separator()
					}

					p.SetState(510)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(512)
					p.Value()
				}

			}
			p.SetState(518)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())
		}

	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(521)
			p.Separator()
		}

		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(527)
		p.Match(CTEParserMAP_OR_RECORD_END)
	}

	return localctx
}

// IContainerNodeContext is an interface to support dynamic dispatch.
type IContainerNodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NODE_BEGIN() antlr.TerminalNode
	AllValue() []IValueContext
	Value(i int) IValueContext
	EDGE_OR_NODE_END() antlr.TerminalNode
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext

	// IsContainerNodeContext differentiates from other interfaces.
	IsContainerNodeContext()
}

type ContainerNodeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainerNodeContext() *ContainerNodeContext {
	var p = new(ContainerNodeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_containerNode
	return p
}

func (*ContainerNodeContext) IsContainerNodeContext() {}

func NewContainerNodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainerNodeContext {
	var p = new(ContainerNodeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_containerNode

	return p
}

func (s *ContainerNodeContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainerNodeContext) NODE_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserNODE_BEGIN, 0)
}

func (s *ContainerNodeContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ContainerNodeContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContainerNodeContext) EDGE_OR_NODE_END() antlr.TerminalNode {
	return s.GetToken(CTEParserEDGE_OR_NODE_END, 0)
}

func (s *ContainerNodeContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *ContainerNodeContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *ContainerNodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainerNodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainerNodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterContainerNode(s)
	}
}

func (s *ContainerNodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitContainerNode(s)
	}
}

func (p *CTEParser) ContainerNode() (localctx IContainerNodeContext) {
	this := p
	_ = this

	localctx = NewContainerNodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CTEParserRULE_containerNode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Match(CTEParserNODE_BEGIN)
	}
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(530)
			p.Separator()
		}

		p.SetState(535)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(536)
		p.Value()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
				{
					p.SetState(537)
					p.Separator()
				}

				p.SetState(540)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(542)
				p.Value()
			}

		}
		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}
	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(549)
			p.Separator()
		}

		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(555)
		p.Match(CTEParserEDGE_OR_NODE_END)
	}

	return localctx
}

// IContainerEdgeContext is an interface to support dynamic dispatch.
type IContainerEdgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EDGE_BEGIN() antlr.TerminalNode
	AllValue() []IValueContext
	Value(i int) IValueContext
	EDGE_OR_NODE_END() antlr.TerminalNode
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext

	// IsContainerEdgeContext differentiates from other interfaces.
	IsContainerEdgeContext()
}

type ContainerEdgeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainerEdgeContext() *ContainerEdgeContext {
	var p = new(ContainerEdgeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_containerEdge
	return p
}

func (*ContainerEdgeContext) IsContainerEdgeContext() {}

func NewContainerEdgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainerEdgeContext {
	var p = new(ContainerEdgeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_containerEdge

	return p
}

func (s *ContainerEdgeContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainerEdgeContext) EDGE_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserEDGE_BEGIN, 0)
}

func (s *ContainerEdgeContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ContainerEdgeContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContainerEdgeContext) EDGE_OR_NODE_END() antlr.TerminalNode {
	return s.GetToken(CTEParserEDGE_OR_NODE_END, 0)
}

func (s *ContainerEdgeContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *ContainerEdgeContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *ContainerEdgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainerEdgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainerEdgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterContainerEdge(s)
	}
}

func (s *ContainerEdgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitContainerEdge(s)
	}
}

func (p *CTEParser) ContainerEdge() (localctx IContainerEdgeContext) {
	this := p
	_ = this

	localctx = NewContainerEdgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CTEParserRULE_containerEdge)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		p.Match(CTEParserEDGE_BEGIN)
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(558)
			p.Separator()
		}

		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(564)
		p.Value()
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
		{
			p.SetState(565)
			p.Separator()
		}

		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(570)
		p.Value()
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0) {
		{
			p.SetState(571)
			p.Separator()
		}

		p.SetState(574)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(576)
		p.Value()
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(577)
			p.Separator()
		}

		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(583)
		p.Match(CTEParserEDGE_OR_NODE_END)
	}

	return localctx
}

// IKvPairContext is an interface to support dynamic dispatch.
type IKvPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValue() []IValueContext
	Value(i int) IValueContext
	KV_SEPARATOR() antlr.TerminalNode
	AllSeparator() []ISeparatorContext
	Separator(i int) ISeparatorContext

	// IsKvPairContext differentiates from other interfaces.
	IsKvPairContext()
}

type KvPairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKvPairContext() *KvPairContext {
	var p = new(KvPairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_kvPair
	return p
}

func (*KvPairContext) IsKvPairContext() {}

func NewKvPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KvPairContext {
	var p = new(KvPairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_kvPair

	return p
}

func (s *KvPairContext) GetParser() antlr.Parser { return s.parser }

func (s *KvPairContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *KvPairContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *KvPairContext) KV_SEPARATOR() antlr.TerminalNode {
	return s.GetToken(CTEParserKV_SEPARATOR, 0)
}

func (s *KvPairContext) AllSeparator() []ISeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISeparatorContext); ok {
			len++
		}
	}

	tst := make([]ISeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISeparatorContext); ok {
			tst[i] = t.(ISeparatorContext)
			i++
		}
	}

	return tst
}

func (s *KvPairContext) Separator(i int) ISeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *KvPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KvPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KvPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterKvPair(s)
	}
}

func (s *KvPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitKvPair(s)
	}
}

func (p *CTEParser) KvPair() (localctx IKvPairContext) {
	this := p
	_ = this

	localctx = NewKvPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CTEParserRULE_kvPair)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		p.Value()
	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(586)
			p.Separator()
		}

		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(592)
		p.Match(CTEParserKV_SEPARATOR)
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&56) != 0 {
		{
			p.SetState(593)
			p.Separator()
		}

		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(599)
		p.Value()
	}

	return localctx
}

// IRecordTypeBeginContext is an interface to support dynamic dispatch.
type IRecordTypeBeginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD_TYPE_BEGIN() antlr.TerminalNode

	// IsRecordTypeBeginContext differentiates from other interfaces.
	IsRecordTypeBeginContext()
}

type RecordTypeBeginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeBeginContext() *RecordTypeBeginContext {
	var p = new(RecordTypeBeginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_recordTypeBegin
	return p
}

func (*RecordTypeBeginContext) IsRecordTypeBeginContext() {}

func NewRecordTypeBeginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeBeginContext {
	var p = new(RecordTypeBeginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_recordTypeBegin

	return p
}

func (s *RecordTypeBeginContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeBeginContext) RECORD_TYPE_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserRECORD_TYPE_BEGIN, 0)
}

func (s *RecordTypeBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeBeginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeBeginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterRecordTypeBegin(s)
	}
}

func (s *RecordTypeBeginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitRecordTypeBegin(s)
	}
}

func (p *CTEParser) RecordTypeBegin() (localctx IRecordTypeBeginContext) {
	this := p
	_ = this

	localctx = NewRecordTypeBeginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CTEParserRULE_recordTypeBegin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.Match(CTEParserRECORD_TYPE_BEGIN)
	}

	return localctx
}

// IRecordBeginContext is an interface to support dynamic dispatch.
type IRecordBeginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD_BEGIN() antlr.TerminalNode

	// IsRecordBeginContext differentiates from other interfaces.
	IsRecordBeginContext()
}

type RecordBeginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordBeginContext() *RecordBeginContext {
	var p = new(RecordBeginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_recordBegin
	return p
}

func (*RecordBeginContext) IsRecordBeginContext() {}

func NewRecordBeginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordBeginContext {
	var p = new(RecordBeginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_recordBegin

	return p
}

func (s *RecordBeginContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordBeginContext) RECORD_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserRECORD_BEGIN, 0)
}

func (s *RecordBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordBeginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordBeginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterRecordBegin(s)
	}
}

func (s *RecordBeginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitRecordBegin(s)
	}
}

func (p *CTEParser) RecordBegin() (localctx IRecordBeginContext) {
	this := p
	_ = this

	localctx = NewRecordBeginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CTEParserRULE_recordBegin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.Match(CTEParserRECORD_BEGIN)
	}

	return localctx
}

// IArrayElemIntContext is an interface to support dynamic dispatch.
type IArrayElemIntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_I_ELEM_D() antlr.TerminalNode
	ARRAY_I_ELEM_B() antlr.TerminalNode
	ARRAY_I_ELEM_O() antlr.TerminalNode
	ARRAY_I_ELEM_H() antlr.TerminalNode

	// IsArrayElemIntContext differentiates from other interfaces.
	IsArrayElemIntContext()
}

type ArrayElemIntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemIntContext() *ArrayElemIntContext {
	var p = new(ArrayElemIntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemInt
	return p
}

func (*ArrayElemIntContext) IsArrayElemIntContext() {}

func NewArrayElemIntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemIntContext {
	var p = new(ArrayElemIntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemInt

	return p
}

func (s *ArrayElemIntContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemIntContext) ARRAY_I_ELEM_D() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_ELEM_D, 0)
}

func (s *ArrayElemIntContext) ARRAY_I_ELEM_B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_ELEM_B, 0)
}

func (s *ArrayElemIntContext) ARRAY_I_ELEM_O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_ELEM_O, 0)
}

func (s *ArrayElemIntContext) ARRAY_I_ELEM_H() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_ELEM_H, 0)
}

func (s *ArrayElemIntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemIntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemIntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemInt(s)
	}
}

func (s *ArrayElemIntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemInt(s)
	}
}

func (p *CTEParser) ArrayElemInt() (localctx IArrayElemIntContext) {
	this := p
	_ = this

	localctx = NewArrayElemIntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CTEParserRULE_arrayElemInt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArrayElemIntBContext is an interface to support dynamic dispatch.
type IArrayElemIntBContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_I_B_ELEM() antlr.TerminalNode

	// IsArrayElemIntBContext differentiates from other interfaces.
	IsArrayElemIntBContext()
}

type ArrayElemIntBContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemIntBContext() *ArrayElemIntBContext {
	var p = new(ArrayElemIntBContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemIntB
	return p
}

func (*ArrayElemIntBContext) IsArrayElemIntBContext() {}

func NewArrayElemIntBContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemIntBContext {
	var p = new(ArrayElemIntBContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemIntB

	return p
}

func (s *ArrayElemIntBContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemIntBContext) ARRAY_I_B_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_ELEM, 0)
}

func (s *ArrayElemIntBContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemIntBContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemIntBContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemIntB(s)
	}
}

func (s *ArrayElemIntBContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemIntB(s)
	}
}

func (p *CTEParser) ArrayElemIntB() (localctx IArrayElemIntBContext) {
	this := p
	_ = this

	localctx = NewArrayElemIntBContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CTEParserRULE_arrayElemIntB)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(CTEParserARRAY_I_B_ELEM)
	}

	return localctx
}

// IArrayElemIntOContext is an interface to support dynamic dispatch.
type IArrayElemIntOContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_I_O_ELEM() antlr.TerminalNode

	// IsArrayElemIntOContext differentiates from other interfaces.
	IsArrayElemIntOContext()
}

type ArrayElemIntOContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemIntOContext() *ArrayElemIntOContext {
	var p = new(ArrayElemIntOContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemIntO
	return p
}

func (*ArrayElemIntOContext) IsArrayElemIntOContext() {}

func NewArrayElemIntOContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemIntOContext {
	var p = new(ArrayElemIntOContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemIntO

	return p
}

func (s *ArrayElemIntOContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemIntOContext) ARRAY_I_O_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_ELEM, 0)
}

func (s *ArrayElemIntOContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemIntOContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemIntOContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemIntO(s)
	}
}

func (s *ArrayElemIntOContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemIntO(s)
	}
}

func (p *CTEParser) ArrayElemIntO() (localctx IArrayElemIntOContext) {
	this := p
	_ = this

	localctx = NewArrayElemIntOContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CTEParserRULE_arrayElemIntO)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(609)
		p.Match(CTEParserARRAY_I_O_ELEM)
	}

	return localctx
}

// IArrayElemIntXContext is an interface to support dynamic dispatch.
type IArrayElemIntXContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_I_X_ELEM() antlr.TerminalNode

	// IsArrayElemIntXContext differentiates from other interfaces.
	IsArrayElemIntXContext()
}

type ArrayElemIntXContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemIntXContext() *ArrayElemIntXContext {
	var p = new(ArrayElemIntXContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemIntX
	return p
}

func (*ArrayElemIntXContext) IsArrayElemIntXContext() {}

func NewArrayElemIntXContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemIntXContext {
	var p = new(ArrayElemIntXContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemIntX

	return p
}

func (s *ArrayElemIntXContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemIntXContext) ARRAY_I_X_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_ELEM, 0)
}

func (s *ArrayElemIntXContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemIntXContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemIntXContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemIntX(s)
	}
}

func (s *ArrayElemIntXContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemIntX(s)
	}
}

func (p *CTEParser) ArrayElemIntX() (localctx IArrayElemIntXContext) {
	this := p
	_ = this

	localctx = NewArrayElemIntXContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CTEParserRULE_arrayElemIntX)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(CTEParserARRAY_I_X_ELEM)
	}

	return localctx
}

// IArrayElemUintContext is an interface to support dynamic dispatch.
type IArrayElemUintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_U_ELEM_D() antlr.TerminalNode
	ARRAY_U_ELEM_B() antlr.TerminalNode
	ARRAY_U_ELEM_O() antlr.TerminalNode
	ARRAY_U_ELEM_H() antlr.TerminalNode

	// IsArrayElemUintContext differentiates from other interfaces.
	IsArrayElemUintContext()
}

type ArrayElemUintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemUintContext() *ArrayElemUintContext {
	var p = new(ArrayElemUintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemUint
	return p
}

func (*ArrayElemUintContext) IsArrayElemUintContext() {}

func NewArrayElemUintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemUintContext {
	var p = new(ArrayElemUintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemUint

	return p
}

func (s *ArrayElemUintContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemUintContext) ARRAY_U_ELEM_D() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_ELEM_D, 0)
}

func (s *ArrayElemUintContext) ARRAY_U_ELEM_B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_ELEM_B, 0)
}

func (s *ArrayElemUintContext) ARRAY_U_ELEM_O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_ELEM_O, 0)
}

func (s *ArrayElemUintContext) ARRAY_U_ELEM_H() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_ELEM_H, 0)
}

func (s *ArrayElemUintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemUintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemUintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemUint(s)
	}
}

func (s *ArrayElemUintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemUint(s)
	}
}

func (p *CTEParser) ArrayElemUint() (localctx IArrayElemUintContext) {
	this := p
	_ = this

	localctx = NewArrayElemUintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CTEParserRULE_arrayElemUint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArrayElemUintBContext is an interface to support dynamic dispatch.
type IArrayElemUintBContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_U_B_ELEM() antlr.TerminalNode

	// IsArrayElemUintBContext differentiates from other interfaces.
	IsArrayElemUintBContext()
}

type ArrayElemUintBContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemUintBContext() *ArrayElemUintBContext {
	var p = new(ArrayElemUintBContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemUintB
	return p
}

func (*ArrayElemUintBContext) IsArrayElemUintBContext() {}

func NewArrayElemUintBContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemUintBContext {
	var p = new(ArrayElemUintBContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemUintB

	return p
}

func (s *ArrayElemUintBContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemUintBContext) ARRAY_U_B_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_ELEM, 0)
}

func (s *ArrayElemUintBContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemUintBContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemUintBContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemUintB(s)
	}
}

func (s *ArrayElemUintBContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemUintB(s)
	}
}

func (p *CTEParser) ArrayElemUintB() (localctx IArrayElemUintBContext) {
	this := p
	_ = this

	localctx = NewArrayElemUintBContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CTEParserRULE_arrayElemUintB)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Match(CTEParserARRAY_U_B_ELEM)
	}

	return localctx
}

// IArrayElemUintOContext is an interface to support dynamic dispatch.
type IArrayElemUintOContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_U_O_ELEM() antlr.TerminalNode

	// IsArrayElemUintOContext differentiates from other interfaces.
	IsArrayElemUintOContext()
}

type ArrayElemUintOContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemUintOContext() *ArrayElemUintOContext {
	var p = new(ArrayElemUintOContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemUintO
	return p
}

func (*ArrayElemUintOContext) IsArrayElemUintOContext() {}

func NewArrayElemUintOContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemUintOContext {
	var p = new(ArrayElemUintOContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemUintO

	return p
}

func (s *ArrayElemUintOContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemUintOContext) ARRAY_U_O_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_ELEM, 0)
}

func (s *ArrayElemUintOContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemUintOContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemUintOContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemUintO(s)
	}
}

func (s *ArrayElemUintOContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemUintO(s)
	}
}

func (p *CTEParser) ArrayElemUintO() (localctx IArrayElemUintOContext) {
	this := p
	_ = this

	localctx = NewArrayElemUintOContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CTEParserRULE_arrayElemUintO)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(CTEParserARRAY_U_O_ELEM)
	}

	return localctx
}

// IArrayElemUintXContext is an interface to support dynamic dispatch.
type IArrayElemUintXContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_U_X_ELEM() antlr.TerminalNode

	// IsArrayElemUintXContext differentiates from other interfaces.
	IsArrayElemUintXContext()
}

type ArrayElemUintXContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemUintXContext() *ArrayElemUintXContext {
	var p = new(ArrayElemUintXContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemUintX
	return p
}

func (*ArrayElemUintXContext) IsArrayElemUintXContext() {}

func NewArrayElemUintXContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemUintXContext {
	var p = new(ArrayElemUintXContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemUintX

	return p
}

func (s *ArrayElemUintXContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemUintXContext) ARRAY_U_X_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_ELEM, 0)
}

func (s *ArrayElemUintXContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemUintXContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemUintXContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemUintX(s)
	}
}

func (s *ArrayElemUintXContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemUintX(s)
	}
}

func (p *CTEParser) ArrayElemUintX() (localctx IArrayElemUintXContext) {
	this := p
	_ = this

	localctx = NewArrayElemUintXContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CTEParserRULE_arrayElemUintX)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.Match(CTEParserARRAY_U_X_ELEM)
	}

	return localctx
}

// IArrayElemFloatContext is an interface to support dynamic dispatch.
type IArrayElemFloatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_F_ELEM_D() antlr.TerminalNode
	ARRAY_F_ELEM_H() antlr.TerminalNode

	// IsArrayElemFloatContext differentiates from other interfaces.
	IsArrayElemFloatContext()
}

type ArrayElemFloatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemFloatContext() *ArrayElemFloatContext {
	var p = new(ArrayElemFloatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemFloat
	return p
}

func (*ArrayElemFloatContext) IsArrayElemFloatContext() {}

func NewArrayElemFloatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemFloatContext {
	var p = new(ArrayElemFloatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemFloat

	return p
}

func (s *ArrayElemFloatContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemFloatContext) ARRAY_F_ELEM_D() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_ELEM_D, 0)
}

func (s *ArrayElemFloatContext) ARRAY_F_ELEM_H() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_ELEM_H, 0)
}

func (s *ArrayElemFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemFloatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemFloat(s)
	}
}

func (s *ArrayElemFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemFloat(s)
	}
}

func (p *CTEParser) ArrayElemFloat() (localctx IArrayElemFloatContext) {
	this := p
	_ = this

	localctx = NewArrayElemFloatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CTEParserRULE_arrayElemFloat)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserARRAY_F_ELEM_D || _la == CTEParserARRAY_F_ELEM_H) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArrayElemFloatXContext is an interface to support dynamic dispatch.
type IArrayElemFloatXContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_F_X_ELEM() antlr.TerminalNode

	// IsArrayElemFloatXContext differentiates from other interfaces.
	IsArrayElemFloatXContext()
}

type ArrayElemFloatXContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemFloatXContext() *ArrayElemFloatXContext {
	var p = new(ArrayElemFloatXContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemFloatX
	return p
}

func (*ArrayElemFloatXContext) IsArrayElemFloatXContext() {}

func NewArrayElemFloatXContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemFloatXContext {
	var p = new(ArrayElemFloatXContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemFloatX

	return p
}

func (s *ArrayElemFloatXContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemFloatXContext) ARRAY_F_X_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_ELEM, 0)
}

func (s *ArrayElemFloatXContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemFloatXContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemFloatXContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemFloatX(s)
	}
}

func (s *ArrayElemFloatXContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemFloatX(s)
	}
}

func (p *CTEParser) ArrayElemFloatX() (localctx IArrayElemFloatXContext) {
	this := p
	_ = this

	localctx = NewArrayElemFloatXContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CTEParserRULE_arrayElemFloatX)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Match(CTEParserARRAY_F_X_ELEM)
	}

	return localctx
}

// IArrayElemNanContext is an interface to support dynamic dispatch.
type IArrayElemNanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_F_NAN() antlr.TerminalNode
	ARRAY_F_X_NAN() antlr.TerminalNode

	// IsArrayElemNanContext differentiates from other interfaces.
	IsArrayElemNanContext()
}

type ArrayElemNanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemNanContext() *ArrayElemNanContext {
	var p = new(ArrayElemNanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemNan
	return p
}

func (*ArrayElemNanContext) IsArrayElemNanContext() {}

func NewArrayElemNanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemNanContext {
	var p = new(ArrayElemNanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemNan

	return p
}

func (s *ArrayElemNanContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemNanContext) ARRAY_F_NAN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_NAN, 0)
}

func (s *ArrayElemNanContext) ARRAY_F_X_NAN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_NAN, 0)
}

func (s *ArrayElemNanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemNanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemNanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemNan(s)
	}
}

func (s *ArrayElemNanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemNan(s)
	}
}

func (p *CTEParser) ArrayElemNan() (localctx IArrayElemNanContext) {
	this := p
	_ = this

	localctx = NewArrayElemNanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CTEParserRULE_arrayElemNan)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserARRAY_F_NAN || _la == CTEParserARRAY_F_X_NAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArrayElemSnanContext is an interface to support dynamic dispatch.
type IArrayElemSnanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_F_SNAN() antlr.TerminalNode
	ARRAY_F_X_SNAN() antlr.TerminalNode

	// IsArrayElemSnanContext differentiates from other interfaces.
	IsArrayElemSnanContext()
}

type ArrayElemSnanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemSnanContext() *ArrayElemSnanContext {
	var p = new(ArrayElemSnanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemSnan
	return p
}

func (*ArrayElemSnanContext) IsArrayElemSnanContext() {}

func NewArrayElemSnanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemSnanContext {
	var p = new(ArrayElemSnanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemSnan

	return p
}

func (s *ArrayElemSnanContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemSnanContext) ARRAY_F_SNAN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_SNAN, 0)
}

func (s *ArrayElemSnanContext) ARRAY_F_X_SNAN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_SNAN, 0)
}

func (s *ArrayElemSnanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemSnanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemSnanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemSnan(s)
	}
}

func (s *ArrayElemSnanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemSnan(s)
	}
}

func (p *CTEParser) ArrayElemSnan() (localctx IArrayElemSnanContext) {
	this := p
	_ = this

	localctx = NewArrayElemSnanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CTEParserRULE_arrayElemSnan)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserARRAY_F_SNAN || _la == CTEParserARRAY_F_X_SNAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArrayElemInfContext is an interface to support dynamic dispatch.
type IArrayElemInfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_F_INF() antlr.TerminalNode
	ARRAY_F_X_INF() antlr.TerminalNode

	// IsArrayElemInfContext differentiates from other interfaces.
	IsArrayElemInfContext()
}

type ArrayElemInfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemInfContext() *ArrayElemInfContext {
	var p = new(ArrayElemInfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemInf
	return p
}

func (*ArrayElemInfContext) IsArrayElemInfContext() {}

func NewArrayElemInfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemInfContext {
	var p = new(ArrayElemInfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemInf

	return p
}

func (s *ArrayElemInfContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemInfContext) ARRAY_F_INF() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_INF, 0)
}

func (s *ArrayElemInfContext) ARRAY_F_X_INF() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_INF, 0)
}

func (s *ArrayElemInfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemInfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemInfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemInf(s)
	}
}

func (s *ArrayElemInfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemInf(s)
	}
}

func (p *CTEParser) ArrayElemInf() (localctx IArrayElemInfContext) {
	this := p
	_ = this

	localctx = NewArrayElemInfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CTEParserRULE_arrayElemInf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserARRAY_F_INF || _la == CTEParserARRAY_F_X_INF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArrayElemNinfContext is an interface to support dynamic dispatch.
type IArrayElemNinfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_F_NINF() antlr.TerminalNode
	ARRAY_F_X_NINF() antlr.TerminalNode

	// IsArrayElemNinfContext differentiates from other interfaces.
	IsArrayElemNinfContext()
}

type ArrayElemNinfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemNinfContext() *ArrayElemNinfContext {
	var p = new(ArrayElemNinfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemNinf
	return p
}

func (*ArrayElemNinfContext) IsArrayElemNinfContext() {}

func NewArrayElemNinfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemNinfContext {
	var p = new(ArrayElemNinfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemNinf

	return p
}

func (s *ArrayElemNinfContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemNinfContext) ARRAY_F_NINF() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_NINF, 0)
}

func (s *ArrayElemNinfContext) ARRAY_F_X_NINF() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_NINF, 0)
}

func (s *ArrayElemNinfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemNinfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemNinfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemNinf(s)
	}
}

func (s *ArrayElemNinfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemNinf(s)
	}
}

func (p *CTEParser) ArrayElemNinf() (localctx IArrayElemNinfContext) {
	this := p
	_ = this

	localctx = NewArrayElemNinfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CTEParserRULE_arrayElemNinf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CTEParserARRAY_F_NINF || _la == CTEParserARRAY_F_X_NINF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArrayElemUidContext is an interface to support dynamic dispatch.
type IArrayElemUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_UID_ELEM() antlr.TerminalNode

	// IsArrayElemUidContext differentiates from other interfaces.
	IsArrayElemUidContext()
}

type ArrayElemUidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemUidContext() *ArrayElemUidContext {
	var p = new(ArrayElemUidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemUid
	return p
}

func (*ArrayElemUidContext) IsArrayElemUidContext() {}

func NewArrayElemUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemUidContext {
	var p = new(ArrayElemUidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemUid

	return p
}

func (s *ArrayElemUidContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemUidContext) ARRAY_UID_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_UID_ELEM, 0)
}

func (s *ArrayElemUidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemUidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemUidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemUid(s)
	}
}

func (s *ArrayElemUidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemUid(s)
	}
}

func (p *CTEParser) ArrayElemUid() (localctx IArrayElemUidContext) {
	this := p
	_ = this

	localctx = NewArrayElemUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CTEParserRULE_arrayElemUid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(CTEParserARRAY_UID_ELEM)
	}

	return localctx
}

// IArrayElemBitsContext is an interface to support dynamic dispatch.
type IArrayElemBitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BIT_BITS() antlr.TerminalNode

	// IsArrayElemBitsContext differentiates from other interfaces.
	IsArrayElemBitsContext()
}

type ArrayElemBitsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemBitsContext() *ArrayElemBitsContext {
	var p = new(ArrayElemBitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemBits
	return p
}

func (*ArrayElemBitsContext) IsArrayElemBitsContext() {}

func NewArrayElemBitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemBitsContext {
	var p = new(ArrayElemBitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemBits

	return p
}

func (s *ArrayElemBitsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemBitsContext) ARRAY_BIT_BITS() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BIT_BITS, 0)
}

func (s *ArrayElemBitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemBitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemBitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemBits(s)
	}
}

func (s *ArrayElemBitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemBits(s)
	}
}

func (p *CTEParser) ArrayElemBits() (localctx IArrayElemBitsContext) {
	this := p
	_ = this

	localctx = NewArrayElemBitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CTEParserRULE_arrayElemBits)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Match(CTEParserARRAY_BIT_BITS)
	}

	return localctx
}

// IArrayElemByteXContext is an interface to support dynamic dispatch.
type IArrayElemByteXContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BYTES_ELEM() antlr.TerminalNode

	// IsArrayElemByteXContext differentiates from other interfaces.
	IsArrayElemByteXContext()
}

type ArrayElemByteXContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElemByteXContext() *ArrayElemByteXContext {
	var p = new(ArrayElemByteXContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayElemByteX
	return p
}

func (*ArrayElemByteXContext) IsArrayElemByteXContext() {}

func NewArrayElemByteXContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElemByteXContext {
	var p = new(ArrayElemByteXContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayElemByteX

	return p
}

func (s *ArrayElemByteXContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElemByteXContext) BYTES_ELEM() antlr.TerminalNode {
	return s.GetToken(CTEParserBYTES_ELEM, 0)
}

func (s *ArrayElemByteXContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElemByteXContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElemByteXContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayElemByteX(s)
	}
}

func (s *ArrayElemByteXContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayElemByteX(s)
	}
}

func (p *CTEParser) ArrayElemByteX() (localctx IArrayElemByteXContext) {
	this := p
	_ = this

	localctx = NewArrayElemByteXContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CTEParserRULE_arrayElemByteX)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(CTEParserBYTES_ELEM)
	}

	return localctx
}

// IArrayI8Context is an interface to support dynamic dispatch.
type IArrayI8Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_I8_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_I8() antlr.TerminalNode
	ARRAY_I_END() antlr.TerminalNode
	ARRAY_TYPE_I8B() antlr.TerminalNode
	ARRAY_I_B_END() antlr.TerminalNode
	ARRAY_TYPE_I8O() antlr.TerminalNode
	ARRAY_I_O_END() antlr.TerminalNode
	ARRAY_TYPE_I8X() antlr.TerminalNode
	ARRAY_I_X_END() antlr.TerminalNode
	AllARRAY_I_WSL() []antlr.TerminalNode
	ARRAY_I_WSL(i int) antlr.TerminalNode
	AllArrayElemInt() []IArrayElemIntContext
	ArrayElemInt(i int) IArrayElemIntContext
	AllARRAY_I_B_WSL() []antlr.TerminalNode
	ARRAY_I_B_WSL(i int) antlr.TerminalNode
	AllArrayElemIntB() []IArrayElemIntBContext
	ArrayElemIntB(i int) IArrayElemIntBContext
	AllARRAY_I_O_WSL() []antlr.TerminalNode
	ARRAY_I_O_WSL(i int) antlr.TerminalNode
	AllArrayElemIntO() []IArrayElemIntOContext
	ArrayElemIntO(i int) IArrayElemIntOContext
	AllARRAY_I_X_WSL() []antlr.TerminalNode
	ARRAY_I_X_WSL(i int) antlr.TerminalNode
	AllArrayElemIntX() []IArrayElemIntXContext
	ArrayElemIntX(i int) IArrayElemIntXContext

	// IsArrayI8Context differentiates from other interfaces.
	IsArrayI8Context()
}

type ArrayI8Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayI8Context() *ArrayI8Context {
	var p = new(ArrayI8Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayI8
	return p
}

func (*ArrayI8Context) IsArrayI8Context() {}

func NewArrayI8Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayI8Context {
	var p = new(ArrayI8Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayI8

	return p
}

func (s *ArrayI8Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayI8Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayI8Context) ARRAY_TYPE_I8_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I8_EMPTY, 0)
}

func (s *ArrayI8Context) ARRAY_TYPE_I8() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I8, 0)
}

func (s *ArrayI8Context) ARRAY_I_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_END, 0)
}

func (s *ArrayI8Context) ARRAY_TYPE_I8B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I8B, 0)
}

func (s *ArrayI8Context) ARRAY_I_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_END, 0)
}

func (s *ArrayI8Context) ARRAY_TYPE_I8O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I8O, 0)
}

func (s *ArrayI8Context) ARRAY_I_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_END, 0)
}

func (s *ArrayI8Context) ARRAY_TYPE_I8X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I8X, 0)
}

func (s *ArrayI8Context) ARRAY_I_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_END, 0)
}

func (s *ArrayI8Context) AllARRAY_I_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_WSL)
}

func (s *ArrayI8Context) ARRAY_I_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_WSL, i)
}

func (s *ArrayI8Context) AllArrayElemInt() []IArrayElemIntContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntContext); ok {
			tst[i] = t.(IArrayElemIntContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI8Context) ArrayElemInt(i int) IArrayElemIntContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntContext)
}

func (s *ArrayI8Context) AllARRAY_I_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_B_WSL)
}

func (s *ArrayI8Context) ARRAY_I_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_WSL, i)
}

func (s *ArrayI8Context) AllArrayElemIntB() []IArrayElemIntBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntBContext); ok {
			tst[i] = t.(IArrayElemIntBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI8Context) ArrayElemIntB(i int) IArrayElemIntBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntBContext)
}

func (s *ArrayI8Context) AllARRAY_I_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_O_WSL)
}

func (s *ArrayI8Context) ARRAY_I_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_WSL, i)
}

func (s *ArrayI8Context) AllArrayElemIntO() []IArrayElemIntOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntOContext); ok {
			tst[i] = t.(IArrayElemIntOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI8Context) ArrayElemIntO(i int) IArrayElemIntOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntOContext)
}

func (s *ArrayI8Context) AllARRAY_I_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_X_WSL)
}

func (s *ArrayI8Context) ARRAY_I_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_WSL, i)
}

func (s *ArrayI8Context) AllArrayElemIntX() []IArrayElemIntXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntXContext); ok {
			tst[i] = t.(IArrayElemIntXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI8Context) ArrayElemIntX(i int) IArrayElemIntXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntXContext)
}

func (s *ArrayI8Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayI8Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayI8Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayI8(s)
	}
}

func (s *ArrayI8Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayI8(s)
	}
}

func (p *CTEParser) ArrayI8() (localctx IArrayI8Context) {
	this := p
	_ = this

	localctx = NewArrayI8Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CTEParserRULE_arrayI8)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_I8, CTEParserARRAY_TYPE_I8B, CTEParserARRAY_TYPE_I8O, CTEParserARRAY_TYPE_I8X:
		p.SetState(712)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_I8:
			{
				p.SetState(640)
				p.Match(CTEParserARRAY_TYPE_I8)
			}
			p.SetState(642)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_WSL {
				{
					p.SetState(641)
					p.Match(CTEParserARRAY_I_WSL)
				}

			}
			p.SetState(655)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&15) != 0 {
				{
					p.SetState(644)
					p.ArrayElemInt()
				}
				p.SetState(649)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(645)
							p.Match(CTEParserARRAY_I_WSL)
						}
						{
							p.SetState(646)
							p.ArrayElemInt()
						}

					}
					p.SetState(651)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())
				}
				p.SetState(653)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_WSL {
					{
						p.SetState(652)
						p.Match(CTEParserARRAY_I_WSL)
					}

				}

			}
			{
				p.SetState(657)
				p.Match(CTEParserARRAY_I_END)
			}

		case CTEParserARRAY_TYPE_I8B:
			{
				p.SetState(658)
				p.Match(CTEParserARRAY_TYPE_I8B)
			}
			p.SetState(660)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_WSL {
				{
					p.SetState(659)
					p.Match(CTEParserARRAY_I_B_WSL)
				}

			}
			p.SetState(673)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_ELEM {
				{
					p.SetState(662)
					p.ArrayElemIntB()
				}
				p.SetState(667)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(663)
							p.Match(CTEParserARRAY_I_B_WSL)
						}
						{
							p.SetState(664)
							p.ArrayElemIntB()
						}

					}
					p.SetState(669)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
				}
				p.SetState(671)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_B_WSL {
					{
						p.SetState(670)
						p.Match(CTEParserARRAY_I_B_WSL)
					}

				}

			}
			{
				p.SetState(675)
				p.Match(CTEParserARRAY_I_B_END)
			}

		case CTEParserARRAY_TYPE_I8O:
			{
				p.SetState(676)
				p.Match(CTEParserARRAY_TYPE_I8O)
			}
			p.SetState(678)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_WSL {
				{
					p.SetState(677)
					p.Match(CTEParserARRAY_I_O_WSL)
				}

			}
			p.SetState(691)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_ELEM {
				{
					p.SetState(680)
					p.ArrayElemIntO()
				}
				p.SetState(685)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(681)
							p.Match(CTEParserARRAY_I_O_WSL)
						}
						{
							p.SetState(682)
							p.ArrayElemIntO()
						}

					}
					p.SetState(687)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
				}
				p.SetState(689)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_O_WSL {
					{
						p.SetState(688)
						p.Match(CTEParserARRAY_I_O_WSL)
					}

				}

			}
			{
				p.SetState(693)
				p.Match(CTEParserARRAY_I_O_END)
			}

		case CTEParserARRAY_TYPE_I8X:
			{
				p.SetState(694)
				p.Match(CTEParserARRAY_TYPE_I8X)
			}
			p.SetState(696)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_WSL {
				{
					p.SetState(695)
					p.Match(CTEParserARRAY_I_X_WSL)
				}

			}
			p.SetState(709)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_ELEM {
				{
					p.SetState(698)
					p.ArrayElemIntX()
				}
				p.SetState(703)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(699)
							p.Match(CTEParserARRAY_I_X_WSL)
						}
						{
							p.SetState(700)
							p.ArrayElemIntX()
						}

					}
					p.SetState(705)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
				}
				p.SetState(707)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_X_WSL {
					{
						p.SetState(706)
						p.Match(CTEParserARRAY_I_X_WSL)
					}

				}

			}
			{
				p.SetState(711)
				p.Match(CTEParserARRAY_I_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_I8_EMPTY:
		{
			p.SetState(714)
			p.Match(CTEParserARRAY_TYPE_I8_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayI16Context is an interface to support dynamic dispatch.
type IArrayI16Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_I16_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_I16() antlr.TerminalNode
	ARRAY_I_END() antlr.TerminalNode
	ARRAY_TYPE_I16B() antlr.TerminalNode
	ARRAY_I_B_END() antlr.TerminalNode
	ARRAY_TYPE_I16O() antlr.TerminalNode
	ARRAY_I_O_END() antlr.TerminalNode
	ARRAY_TYPE_I16X() antlr.TerminalNode
	ARRAY_I_X_END() antlr.TerminalNode
	AllARRAY_I_WSL() []antlr.TerminalNode
	ARRAY_I_WSL(i int) antlr.TerminalNode
	AllArrayElemInt() []IArrayElemIntContext
	ArrayElemInt(i int) IArrayElemIntContext
	AllARRAY_I_B_WSL() []antlr.TerminalNode
	ARRAY_I_B_WSL(i int) antlr.TerminalNode
	AllArrayElemIntB() []IArrayElemIntBContext
	ArrayElemIntB(i int) IArrayElemIntBContext
	AllARRAY_I_O_WSL() []antlr.TerminalNode
	ARRAY_I_O_WSL(i int) antlr.TerminalNode
	AllArrayElemIntO() []IArrayElemIntOContext
	ArrayElemIntO(i int) IArrayElemIntOContext
	AllARRAY_I_X_WSL() []antlr.TerminalNode
	ARRAY_I_X_WSL(i int) antlr.TerminalNode
	AllArrayElemIntX() []IArrayElemIntXContext
	ArrayElemIntX(i int) IArrayElemIntXContext

	// IsArrayI16Context differentiates from other interfaces.
	IsArrayI16Context()
}

type ArrayI16Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayI16Context() *ArrayI16Context {
	var p = new(ArrayI16Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayI16
	return p
}

func (*ArrayI16Context) IsArrayI16Context() {}

func NewArrayI16Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayI16Context {
	var p = new(ArrayI16Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayI16

	return p
}

func (s *ArrayI16Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayI16Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayI16Context) ARRAY_TYPE_I16_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I16_EMPTY, 0)
}

func (s *ArrayI16Context) ARRAY_TYPE_I16() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I16, 0)
}

func (s *ArrayI16Context) ARRAY_I_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_END, 0)
}

func (s *ArrayI16Context) ARRAY_TYPE_I16B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I16B, 0)
}

func (s *ArrayI16Context) ARRAY_I_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_END, 0)
}

func (s *ArrayI16Context) ARRAY_TYPE_I16O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I16O, 0)
}

func (s *ArrayI16Context) ARRAY_I_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_END, 0)
}

func (s *ArrayI16Context) ARRAY_TYPE_I16X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I16X, 0)
}

func (s *ArrayI16Context) ARRAY_I_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_END, 0)
}

func (s *ArrayI16Context) AllARRAY_I_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_WSL)
}

func (s *ArrayI16Context) ARRAY_I_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_WSL, i)
}

func (s *ArrayI16Context) AllArrayElemInt() []IArrayElemIntContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntContext); ok {
			tst[i] = t.(IArrayElemIntContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI16Context) ArrayElemInt(i int) IArrayElemIntContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntContext)
}

func (s *ArrayI16Context) AllARRAY_I_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_B_WSL)
}

func (s *ArrayI16Context) ARRAY_I_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_WSL, i)
}

func (s *ArrayI16Context) AllArrayElemIntB() []IArrayElemIntBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntBContext); ok {
			tst[i] = t.(IArrayElemIntBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI16Context) ArrayElemIntB(i int) IArrayElemIntBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntBContext)
}

func (s *ArrayI16Context) AllARRAY_I_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_O_WSL)
}

func (s *ArrayI16Context) ARRAY_I_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_WSL, i)
}

func (s *ArrayI16Context) AllArrayElemIntO() []IArrayElemIntOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntOContext); ok {
			tst[i] = t.(IArrayElemIntOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI16Context) ArrayElemIntO(i int) IArrayElemIntOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntOContext)
}

func (s *ArrayI16Context) AllARRAY_I_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_X_WSL)
}

func (s *ArrayI16Context) ARRAY_I_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_WSL, i)
}

func (s *ArrayI16Context) AllArrayElemIntX() []IArrayElemIntXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntXContext); ok {
			tst[i] = t.(IArrayElemIntXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI16Context) ArrayElemIntX(i int) IArrayElemIntXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntXContext)
}

func (s *ArrayI16Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayI16Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayI16Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayI16(s)
	}
}

func (s *ArrayI16Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayI16(s)
	}
}

func (p *CTEParser) ArrayI16() (localctx IArrayI16Context) {
	this := p
	_ = this

	localctx = NewArrayI16Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CTEParserRULE_arrayI16)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(793)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_I16, CTEParserARRAY_TYPE_I16B, CTEParserARRAY_TYPE_I16O, CTEParserARRAY_TYPE_I16X:
		p.SetState(790)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_I16:
			{
				p.SetState(718)
				p.Match(CTEParserARRAY_TYPE_I16)
			}
			p.SetState(720)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_WSL {
				{
					p.SetState(719)
					p.Match(CTEParserARRAY_I_WSL)
				}

			}
			p.SetState(733)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&15) != 0 {
				{
					p.SetState(722)
					p.ArrayElemInt()
				}
				p.SetState(727)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(723)
							p.Match(CTEParserARRAY_I_WSL)
						}
						{
							p.SetState(724)
							p.ArrayElemInt()
						}

					}
					p.SetState(729)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext())
				}
				p.SetState(731)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_WSL {
					{
						p.SetState(730)
						p.Match(CTEParserARRAY_I_WSL)
					}

				}

			}
			{
				p.SetState(735)
				p.Match(CTEParserARRAY_I_END)
			}

		case CTEParserARRAY_TYPE_I16B:
			{
				p.SetState(736)
				p.Match(CTEParserARRAY_TYPE_I16B)
			}
			p.SetState(738)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_WSL {
				{
					p.SetState(737)
					p.Match(CTEParserARRAY_I_B_WSL)
				}

			}
			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_ELEM {
				{
					p.SetState(740)
					p.ArrayElemIntB()
				}
				p.SetState(745)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(741)
							p.Match(CTEParserARRAY_I_B_WSL)
						}
						{
							p.SetState(742)
							p.ArrayElemIntB()
						}

					}
					p.SetState(747)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
				}
				p.SetState(749)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_B_WSL {
					{
						p.SetState(748)
						p.Match(CTEParserARRAY_I_B_WSL)
					}

				}

			}
			{
				p.SetState(753)
				p.Match(CTEParserARRAY_I_B_END)
			}

		case CTEParserARRAY_TYPE_I16O:
			{
				p.SetState(754)
				p.Match(CTEParserARRAY_TYPE_I16O)
			}
			p.SetState(756)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_WSL {
				{
					p.SetState(755)
					p.Match(CTEParserARRAY_I_O_WSL)
				}

			}
			p.SetState(769)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_ELEM {
				{
					p.SetState(758)
					p.ArrayElemIntO()
				}
				p.SetState(763)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(759)
							p.Match(CTEParserARRAY_I_O_WSL)
						}
						{
							p.SetState(760)
							p.ArrayElemIntO()
						}

					}
					p.SetState(765)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
				}
				p.SetState(767)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_O_WSL {
					{
						p.SetState(766)
						p.Match(CTEParserARRAY_I_O_WSL)
					}

				}

			}
			{
				p.SetState(771)
				p.Match(CTEParserARRAY_I_O_END)
			}

		case CTEParserARRAY_TYPE_I16X:
			{
				p.SetState(772)
				p.Match(CTEParserARRAY_TYPE_I16X)
			}
			p.SetState(774)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_WSL {
				{
					p.SetState(773)
					p.Match(CTEParserARRAY_I_X_WSL)
				}

			}
			p.SetState(787)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_ELEM {
				{
					p.SetState(776)
					p.ArrayElemIntX()
				}
				p.SetState(781)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(777)
							p.Match(CTEParserARRAY_I_X_WSL)
						}
						{
							p.SetState(778)
							p.ArrayElemIntX()
						}

					}
					p.SetState(783)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())
				}
				p.SetState(785)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_X_WSL {
					{
						p.SetState(784)
						p.Match(CTEParserARRAY_I_X_WSL)
					}

				}

			}
			{
				p.SetState(789)
				p.Match(CTEParserARRAY_I_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_I16_EMPTY:
		{
			p.SetState(792)
			p.Match(CTEParserARRAY_TYPE_I16_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayI32Context is an interface to support dynamic dispatch.
type IArrayI32Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_I32_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_I32() antlr.TerminalNode
	ARRAY_I_END() antlr.TerminalNode
	ARRAY_TYPE_I32B() antlr.TerminalNode
	ARRAY_I_B_END() antlr.TerminalNode
	ARRAY_TYPE_I32O() antlr.TerminalNode
	ARRAY_I_O_END() antlr.TerminalNode
	ARRAY_TYPE_I32X() antlr.TerminalNode
	ARRAY_I_X_END() antlr.TerminalNode
	AllARRAY_I_WSL() []antlr.TerminalNode
	ARRAY_I_WSL(i int) antlr.TerminalNode
	AllArrayElemInt() []IArrayElemIntContext
	ArrayElemInt(i int) IArrayElemIntContext
	AllARRAY_I_B_WSL() []antlr.TerminalNode
	ARRAY_I_B_WSL(i int) antlr.TerminalNode
	AllArrayElemIntB() []IArrayElemIntBContext
	ArrayElemIntB(i int) IArrayElemIntBContext
	AllARRAY_I_O_WSL() []antlr.TerminalNode
	ARRAY_I_O_WSL(i int) antlr.TerminalNode
	AllArrayElemIntO() []IArrayElemIntOContext
	ArrayElemIntO(i int) IArrayElemIntOContext
	AllARRAY_I_X_WSL() []antlr.TerminalNode
	ARRAY_I_X_WSL(i int) antlr.TerminalNode
	AllArrayElemIntX() []IArrayElemIntXContext
	ArrayElemIntX(i int) IArrayElemIntXContext

	// IsArrayI32Context differentiates from other interfaces.
	IsArrayI32Context()
}

type ArrayI32Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayI32Context() *ArrayI32Context {
	var p = new(ArrayI32Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayI32
	return p
}

func (*ArrayI32Context) IsArrayI32Context() {}

func NewArrayI32Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayI32Context {
	var p = new(ArrayI32Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayI32

	return p
}

func (s *ArrayI32Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayI32Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayI32Context) ARRAY_TYPE_I32_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I32_EMPTY, 0)
}

func (s *ArrayI32Context) ARRAY_TYPE_I32() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I32, 0)
}

func (s *ArrayI32Context) ARRAY_I_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_END, 0)
}

func (s *ArrayI32Context) ARRAY_TYPE_I32B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I32B, 0)
}

func (s *ArrayI32Context) ARRAY_I_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_END, 0)
}

func (s *ArrayI32Context) ARRAY_TYPE_I32O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I32O, 0)
}

func (s *ArrayI32Context) ARRAY_I_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_END, 0)
}

func (s *ArrayI32Context) ARRAY_TYPE_I32X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I32X, 0)
}

func (s *ArrayI32Context) ARRAY_I_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_END, 0)
}

func (s *ArrayI32Context) AllARRAY_I_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_WSL)
}

func (s *ArrayI32Context) ARRAY_I_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_WSL, i)
}

func (s *ArrayI32Context) AllArrayElemInt() []IArrayElemIntContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntContext); ok {
			tst[i] = t.(IArrayElemIntContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI32Context) ArrayElemInt(i int) IArrayElemIntContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntContext)
}

func (s *ArrayI32Context) AllARRAY_I_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_B_WSL)
}

func (s *ArrayI32Context) ARRAY_I_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_WSL, i)
}

func (s *ArrayI32Context) AllArrayElemIntB() []IArrayElemIntBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntBContext); ok {
			tst[i] = t.(IArrayElemIntBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI32Context) ArrayElemIntB(i int) IArrayElemIntBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntBContext)
}

func (s *ArrayI32Context) AllARRAY_I_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_O_WSL)
}

func (s *ArrayI32Context) ARRAY_I_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_WSL, i)
}

func (s *ArrayI32Context) AllArrayElemIntO() []IArrayElemIntOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntOContext); ok {
			tst[i] = t.(IArrayElemIntOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI32Context) ArrayElemIntO(i int) IArrayElemIntOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntOContext)
}

func (s *ArrayI32Context) AllARRAY_I_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_X_WSL)
}

func (s *ArrayI32Context) ARRAY_I_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_WSL, i)
}

func (s *ArrayI32Context) AllArrayElemIntX() []IArrayElemIntXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntXContext); ok {
			tst[i] = t.(IArrayElemIntXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI32Context) ArrayElemIntX(i int) IArrayElemIntXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntXContext)
}

func (s *ArrayI32Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayI32Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayI32Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayI32(s)
	}
}

func (s *ArrayI32Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayI32(s)
	}
}

func (p *CTEParser) ArrayI32() (localctx IArrayI32Context) {
	this := p
	_ = this

	localctx = NewArrayI32Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CTEParserRULE_arrayI32)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(871)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_I32, CTEParserARRAY_TYPE_I32B, CTEParserARRAY_TYPE_I32O, CTEParserARRAY_TYPE_I32X:
		p.SetState(868)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_I32:
			{
				p.SetState(796)
				p.Match(CTEParserARRAY_TYPE_I32)
			}
			p.SetState(798)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_WSL {
				{
					p.SetState(797)
					p.Match(CTEParserARRAY_I_WSL)
				}

			}
			p.SetState(811)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&15) != 0 {
				{
					p.SetState(800)
					p.ArrayElemInt()
				}
				p.SetState(805)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(801)
							p.Match(CTEParserARRAY_I_WSL)
						}
						{
							p.SetState(802)
							p.ArrayElemInt()
						}

					}
					p.SetState(807)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())
				}
				p.SetState(809)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_WSL {
					{
						p.SetState(808)
						p.Match(CTEParserARRAY_I_WSL)
					}

				}

			}
			{
				p.SetState(813)
				p.Match(CTEParserARRAY_I_END)
			}

		case CTEParserARRAY_TYPE_I32B:
			{
				p.SetState(814)
				p.Match(CTEParserARRAY_TYPE_I32B)
			}
			p.SetState(816)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_WSL {
				{
					p.SetState(815)
					p.Match(CTEParserARRAY_I_B_WSL)
				}

			}
			p.SetState(829)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_ELEM {
				{
					p.SetState(818)
					p.ArrayElemIntB()
				}
				p.SetState(823)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(819)
							p.Match(CTEParserARRAY_I_B_WSL)
						}
						{
							p.SetState(820)
							p.ArrayElemIntB()
						}

					}
					p.SetState(825)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
				}
				p.SetState(827)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_B_WSL {
					{
						p.SetState(826)
						p.Match(CTEParserARRAY_I_B_WSL)
					}

				}

			}
			{
				p.SetState(831)
				p.Match(CTEParserARRAY_I_B_END)
			}

		case CTEParserARRAY_TYPE_I32O:
			{
				p.SetState(832)
				p.Match(CTEParserARRAY_TYPE_I32O)
			}
			p.SetState(834)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_WSL {
				{
					p.SetState(833)
					p.Match(CTEParserARRAY_I_O_WSL)
				}

			}
			p.SetState(847)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_ELEM {
				{
					p.SetState(836)
					p.ArrayElemIntO()
				}
				p.SetState(841)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(837)
							p.Match(CTEParserARRAY_I_O_WSL)
						}
						{
							p.SetState(838)
							p.ArrayElemIntO()
						}

					}
					p.SetState(843)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
				}
				p.SetState(845)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_O_WSL {
					{
						p.SetState(844)
						p.Match(CTEParserARRAY_I_O_WSL)
					}

				}

			}
			{
				p.SetState(849)
				p.Match(CTEParserARRAY_I_O_END)
			}

		case CTEParserARRAY_TYPE_I32X:
			{
				p.SetState(850)
				p.Match(CTEParserARRAY_TYPE_I32X)
			}
			p.SetState(852)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_WSL {
				{
					p.SetState(851)
					p.Match(CTEParserARRAY_I_X_WSL)
				}

			}
			p.SetState(865)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_ELEM {
				{
					p.SetState(854)
					p.ArrayElemIntX()
				}
				p.SetState(859)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(855)
							p.Match(CTEParserARRAY_I_X_WSL)
						}
						{
							p.SetState(856)
							p.ArrayElemIntX()
						}

					}
					p.SetState(861)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
				}
				p.SetState(863)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_X_WSL {
					{
						p.SetState(862)
						p.Match(CTEParserARRAY_I_X_WSL)
					}

				}

			}
			{
				p.SetState(867)
				p.Match(CTEParserARRAY_I_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_I32_EMPTY:
		{
			p.SetState(870)
			p.Match(CTEParserARRAY_TYPE_I32_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayI64Context is an interface to support dynamic dispatch.
type IArrayI64Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_I64_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_I64() antlr.TerminalNode
	ARRAY_I_END() antlr.TerminalNode
	ARRAY_TYPE_I64B() antlr.TerminalNode
	ARRAY_I_B_END() antlr.TerminalNode
	ARRAY_TYPE_I64O() antlr.TerminalNode
	ARRAY_I_O_END() antlr.TerminalNode
	ARRAY_TYPE_I64X() antlr.TerminalNode
	ARRAY_I_X_END() antlr.TerminalNode
	AllARRAY_I_WSL() []antlr.TerminalNode
	ARRAY_I_WSL(i int) antlr.TerminalNode
	AllArrayElemInt() []IArrayElemIntContext
	ArrayElemInt(i int) IArrayElemIntContext
	AllARRAY_I_B_WSL() []antlr.TerminalNode
	ARRAY_I_B_WSL(i int) antlr.TerminalNode
	AllArrayElemIntB() []IArrayElemIntBContext
	ArrayElemIntB(i int) IArrayElemIntBContext
	AllARRAY_I_O_WSL() []antlr.TerminalNode
	ARRAY_I_O_WSL(i int) antlr.TerminalNode
	AllArrayElemIntO() []IArrayElemIntOContext
	ArrayElemIntO(i int) IArrayElemIntOContext
	AllARRAY_I_X_WSL() []antlr.TerminalNode
	ARRAY_I_X_WSL(i int) antlr.TerminalNode
	AllArrayElemIntX() []IArrayElemIntXContext
	ArrayElemIntX(i int) IArrayElemIntXContext

	// IsArrayI64Context differentiates from other interfaces.
	IsArrayI64Context()
}

type ArrayI64Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayI64Context() *ArrayI64Context {
	var p = new(ArrayI64Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayI64
	return p
}

func (*ArrayI64Context) IsArrayI64Context() {}

func NewArrayI64Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayI64Context {
	var p = new(ArrayI64Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayI64

	return p
}

func (s *ArrayI64Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayI64Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayI64Context) ARRAY_TYPE_I64_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I64_EMPTY, 0)
}

func (s *ArrayI64Context) ARRAY_TYPE_I64() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I64, 0)
}

func (s *ArrayI64Context) ARRAY_I_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_END, 0)
}

func (s *ArrayI64Context) ARRAY_TYPE_I64B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I64B, 0)
}

func (s *ArrayI64Context) ARRAY_I_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_END, 0)
}

func (s *ArrayI64Context) ARRAY_TYPE_I64O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I64O, 0)
}

func (s *ArrayI64Context) ARRAY_I_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_END, 0)
}

func (s *ArrayI64Context) ARRAY_TYPE_I64X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_I64X, 0)
}

func (s *ArrayI64Context) ARRAY_I_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_END, 0)
}

func (s *ArrayI64Context) AllARRAY_I_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_WSL)
}

func (s *ArrayI64Context) ARRAY_I_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_WSL, i)
}

func (s *ArrayI64Context) AllArrayElemInt() []IArrayElemIntContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntContext); ok {
			tst[i] = t.(IArrayElemIntContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI64Context) ArrayElemInt(i int) IArrayElemIntContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntContext)
}

func (s *ArrayI64Context) AllARRAY_I_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_B_WSL)
}

func (s *ArrayI64Context) ARRAY_I_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_B_WSL, i)
}

func (s *ArrayI64Context) AllArrayElemIntB() []IArrayElemIntBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntBContext); ok {
			tst[i] = t.(IArrayElemIntBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI64Context) ArrayElemIntB(i int) IArrayElemIntBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntBContext)
}

func (s *ArrayI64Context) AllARRAY_I_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_O_WSL)
}

func (s *ArrayI64Context) ARRAY_I_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_O_WSL, i)
}

func (s *ArrayI64Context) AllArrayElemIntO() []IArrayElemIntOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntOContext); ok {
			tst[i] = t.(IArrayElemIntOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI64Context) ArrayElemIntO(i int) IArrayElemIntOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntOContext)
}

func (s *ArrayI64Context) AllARRAY_I_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_I_X_WSL)
}

func (s *ArrayI64Context) ARRAY_I_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_I_X_WSL, i)
}

func (s *ArrayI64Context) AllArrayElemIntX() []IArrayElemIntXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemIntXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemIntXContext); ok {
			tst[i] = t.(IArrayElemIntXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayI64Context) ArrayElemIntX(i int) IArrayElemIntXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemIntXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemIntXContext)
}

func (s *ArrayI64Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayI64Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayI64Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayI64(s)
	}
}

func (s *ArrayI64Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayI64(s)
	}
}

func (p *CTEParser) ArrayI64() (localctx IArrayI64Context) {
	this := p
	_ = this

	localctx = NewArrayI64Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CTEParserRULE_arrayI64)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(949)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_I64, CTEParserARRAY_TYPE_I64B, CTEParserARRAY_TYPE_I64O, CTEParserARRAY_TYPE_I64X:
		p.SetState(946)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_I64:
			{
				p.SetState(874)
				p.Match(CTEParserARRAY_TYPE_I64)
			}
			p.SetState(876)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_WSL {
				{
					p.SetState(875)
					p.Match(CTEParserARRAY_I_WSL)
				}

			}
			p.SetState(889)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&15) != 0 {
				{
					p.SetState(878)
					p.ArrayElemInt()
				}
				p.SetState(883)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(879)
							p.Match(CTEParserARRAY_I_WSL)
						}
						{
							p.SetState(880)
							p.ArrayElemInt()
						}

					}
					p.SetState(885)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext())
				}
				p.SetState(887)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_WSL {
					{
						p.SetState(886)
						p.Match(CTEParserARRAY_I_WSL)
					}

				}

			}
			{
				p.SetState(891)
				p.Match(CTEParserARRAY_I_END)
			}

		case CTEParserARRAY_TYPE_I64B:
			{
				p.SetState(892)
				p.Match(CTEParserARRAY_TYPE_I64B)
			}
			p.SetState(894)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_WSL {
				{
					p.SetState(893)
					p.Match(CTEParserARRAY_I_B_WSL)
				}

			}
			p.SetState(907)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_B_ELEM {
				{
					p.SetState(896)
					p.ArrayElemIntB()
				}
				p.SetState(901)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(897)
							p.Match(CTEParserARRAY_I_B_WSL)
						}
						{
							p.SetState(898)
							p.ArrayElemIntB()
						}

					}
					p.SetState(903)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
				}
				p.SetState(905)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_B_WSL {
					{
						p.SetState(904)
						p.Match(CTEParserARRAY_I_B_WSL)
					}

				}

			}
			{
				p.SetState(909)
				p.Match(CTEParserARRAY_I_B_END)
			}

		case CTEParserARRAY_TYPE_I64O:
			{
				p.SetState(910)
				p.Match(CTEParserARRAY_TYPE_I64O)
			}
			p.SetState(912)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_WSL {
				{
					p.SetState(911)
					p.Match(CTEParserARRAY_I_O_WSL)
				}

			}
			p.SetState(925)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_O_ELEM {
				{
					p.SetState(914)
					p.ArrayElemIntO()
				}
				p.SetState(919)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(915)
							p.Match(CTEParserARRAY_I_O_WSL)
						}
						{
							p.SetState(916)
							p.ArrayElemIntO()
						}

					}
					p.SetState(921)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
				}
				p.SetState(923)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_O_WSL {
					{
						p.SetState(922)
						p.Match(CTEParserARRAY_I_O_WSL)
					}

				}

			}
			{
				p.SetState(927)
				p.Match(CTEParserARRAY_I_O_END)
			}

		case CTEParserARRAY_TYPE_I64X:
			{
				p.SetState(928)
				p.Match(CTEParserARRAY_TYPE_I64X)
			}
			p.SetState(930)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_WSL {
				{
					p.SetState(929)
					p.Match(CTEParserARRAY_I_X_WSL)
				}

			}
			p.SetState(943)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_I_X_ELEM {
				{
					p.SetState(932)
					p.ArrayElemIntX()
				}
				p.SetState(937)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(933)
							p.Match(CTEParserARRAY_I_X_WSL)
						}
						{
							p.SetState(934)
							p.ArrayElemIntX()
						}

					}
					p.SetState(939)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())
				}
				p.SetState(941)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_I_X_WSL {
					{
						p.SetState(940)
						p.Match(CTEParserARRAY_I_X_WSL)
					}

				}

			}
			{
				p.SetState(945)
				p.Match(CTEParserARRAY_I_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_I64_EMPTY:
		{
			p.SetState(948)
			p.Match(CTEParserARRAY_TYPE_I64_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayU8Context is an interface to support dynamic dispatch.
type IArrayU8Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_U8_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_U8() antlr.TerminalNode
	ARRAY_U_END() antlr.TerminalNode
	ARRAY_TYPE_U8B() antlr.TerminalNode
	ARRAY_U_B_END() antlr.TerminalNode
	ARRAY_TYPE_U8O() antlr.TerminalNode
	ARRAY_U_O_END() antlr.TerminalNode
	ARRAY_TYPE_U8X() antlr.TerminalNode
	ARRAY_U_X_END() antlr.TerminalNode
	AllARRAY_U_WSL() []antlr.TerminalNode
	ARRAY_U_WSL(i int) antlr.TerminalNode
	AllArrayElemUint() []IArrayElemUintContext
	ArrayElemUint(i int) IArrayElemUintContext
	AllARRAY_U_B_WSL() []antlr.TerminalNode
	ARRAY_U_B_WSL(i int) antlr.TerminalNode
	AllArrayElemUintB() []IArrayElemUintBContext
	ArrayElemUintB(i int) IArrayElemUintBContext
	AllARRAY_U_O_WSL() []antlr.TerminalNode
	ARRAY_U_O_WSL(i int) antlr.TerminalNode
	AllArrayElemUintO() []IArrayElemUintOContext
	ArrayElemUintO(i int) IArrayElemUintOContext
	AllARRAY_U_X_WSL() []antlr.TerminalNode
	ARRAY_U_X_WSL(i int) antlr.TerminalNode
	AllArrayElemUintX() []IArrayElemUintXContext
	ArrayElemUintX(i int) IArrayElemUintXContext

	// IsArrayU8Context differentiates from other interfaces.
	IsArrayU8Context()
}

type ArrayU8Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayU8Context() *ArrayU8Context {
	var p = new(ArrayU8Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayU8
	return p
}

func (*ArrayU8Context) IsArrayU8Context() {}

func NewArrayU8Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayU8Context {
	var p = new(ArrayU8Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayU8

	return p
}

func (s *ArrayU8Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayU8Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayU8Context) ARRAY_TYPE_U8_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U8_EMPTY, 0)
}

func (s *ArrayU8Context) ARRAY_TYPE_U8() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U8, 0)
}

func (s *ArrayU8Context) ARRAY_U_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_END, 0)
}

func (s *ArrayU8Context) ARRAY_TYPE_U8B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U8B, 0)
}

func (s *ArrayU8Context) ARRAY_U_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_END, 0)
}

func (s *ArrayU8Context) ARRAY_TYPE_U8O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U8O, 0)
}

func (s *ArrayU8Context) ARRAY_U_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_END, 0)
}

func (s *ArrayU8Context) ARRAY_TYPE_U8X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U8X, 0)
}

func (s *ArrayU8Context) ARRAY_U_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_END, 0)
}

func (s *ArrayU8Context) AllARRAY_U_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_WSL)
}

func (s *ArrayU8Context) ARRAY_U_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_WSL, i)
}

func (s *ArrayU8Context) AllArrayElemUint() []IArrayElemUintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintContext); ok {
			tst[i] = t.(IArrayElemUintContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU8Context) ArrayElemUint(i int) IArrayElemUintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintContext)
}

func (s *ArrayU8Context) AllARRAY_U_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_B_WSL)
}

func (s *ArrayU8Context) ARRAY_U_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_WSL, i)
}

func (s *ArrayU8Context) AllArrayElemUintB() []IArrayElemUintBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintBContext); ok {
			tst[i] = t.(IArrayElemUintBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU8Context) ArrayElemUintB(i int) IArrayElemUintBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintBContext)
}

func (s *ArrayU8Context) AllARRAY_U_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_O_WSL)
}

func (s *ArrayU8Context) ARRAY_U_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_WSL, i)
}

func (s *ArrayU8Context) AllArrayElemUintO() []IArrayElemUintOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintOContext); ok {
			tst[i] = t.(IArrayElemUintOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU8Context) ArrayElemUintO(i int) IArrayElemUintOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintOContext)
}

func (s *ArrayU8Context) AllARRAY_U_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_X_WSL)
}

func (s *ArrayU8Context) ARRAY_U_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_WSL, i)
}

func (s *ArrayU8Context) AllArrayElemUintX() []IArrayElemUintXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintXContext); ok {
			tst[i] = t.(IArrayElemUintXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU8Context) ArrayElemUintX(i int) IArrayElemUintXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintXContext)
}

func (s *ArrayU8Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayU8Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayU8Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayU8(s)
	}
}

func (s *ArrayU8Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayU8(s)
	}
}

func (p *CTEParser) ArrayU8() (localctx IArrayU8Context) {
	this := p
	_ = this

	localctx = NewArrayU8Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CTEParserRULE_arrayU8)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(951)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_U8, CTEParserARRAY_TYPE_U8B, CTEParserARRAY_TYPE_U8O, CTEParserARRAY_TYPE_U8X:
		p.SetState(1024)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_U8:
			{
				p.SetState(952)
				p.Match(CTEParserARRAY_TYPE_U8)
			}
			p.SetState(954)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_WSL {
				{
					p.SetState(953)
					p.Match(CTEParserARRAY_U_WSL)
				}

			}
			p.SetState(967)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&15) != 0 {
				{
					p.SetState(956)
					p.ArrayElemUint()
				}
				p.SetState(961)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(957)
							p.Match(CTEParserARRAY_U_WSL)
						}
						{
							p.SetState(958)
							p.ArrayElemUint()
						}

					}
					p.SetState(963)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())
				}
				p.SetState(965)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_WSL {
					{
						p.SetState(964)
						p.Match(CTEParserARRAY_U_WSL)
					}

				}

			}
			{
				p.SetState(969)
				p.Match(CTEParserARRAY_U_END)
			}

		case CTEParserARRAY_TYPE_U8B:
			{
				p.SetState(970)
				p.Match(CTEParserARRAY_TYPE_U8B)
			}
			p.SetState(972)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_WSL {
				{
					p.SetState(971)
					p.Match(CTEParserARRAY_U_B_WSL)
				}

			}
			p.SetState(985)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_ELEM {
				{
					p.SetState(974)
					p.ArrayElemUintB()
				}
				p.SetState(979)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(975)
							p.Match(CTEParserARRAY_U_B_WSL)
						}
						{
							p.SetState(976)
							p.ArrayElemUintB()
						}

					}
					p.SetState(981)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())
				}
				p.SetState(983)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_B_WSL {
					{
						p.SetState(982)
						p.Match(CTEParserARRAY_U_B_WSL)
					}

				}

			}
			{
				p.SetState(987)
				p.Match(CTEParserARRAY_U_B_END)
			}

		case CTEParserARRAY_TYPE_U8O:
			{
				p.SetState(988)
				p.Match(CTEParserARRAY_TYPE_U8O)
			}
			p.SetState(990)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_WSL {
				{
					p.SetState(989)
					p.Match(CTEParserARRAY_U_O_WSL)
				}

			}
			p.SetState(1003)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_ELEM {
				{
					p.SetState(992)
					p.ArrayElemUintO()
				}
				p.SetState(997)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(993)
							p.Match(CTEParserARRAY_U_O_WSL)
						}
						{
							p.SetState(994)
							p.ArrayElemUintO()
						}

					}
					p.SetState(999)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
				}
				p.SetState(1001)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_O_WSL {
					{
						p.SetState(1000)
						p.Match(CTEParserARRAY_U_O_WSL)
					}

				}

			}
			{
				p.SetState(1005)
				p.Match(CTEParserARRAY_U_O_END)
			}

		case CTEParserARRAY_TYPE_U8X:
			{
				p.SetState(1006)
				p.Match(CTEParserARRAY_TYPE_U8X)
			}
			p.SetState(1008)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_WSL {
				{
					p.SetState(1007)
					p.Match(CTEParserARRAY_U_X_WSL)
				}

			}
			p.SetState(1021)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_ELEM {
				{
					p.SetState(1010)
					p.ArrayElemUintX()
				}
				p.SetState(1015)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1011)
							p.Match(CTEParserARRAY_U_X_WSL)
						}
						{
							p.SetState(1012)
							p.ArrayElemUintX()
						}

					}
					p.SetState(1017)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
				}
				p.SetState(1019)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_X_WSL {
					{
						p.SetState(1018)
						p.Match(CTEParserARRAY_U_X_WSL)
					}

				}

			}
			{
				p.SetState(1023)
				p.Match(CTEParserARRAY_U_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_U8_EMPTY:
		{
			p.SetState(1026)
			p.Match(CTEParserARRAY_TYPE_U8_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayU16Context is an interface to support dynamic dispatch.
type IArrayU16Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_U16_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_U16() antlr.TerminalNode
	ARRAY_U_END() antlr.TerminalNode
	ARRAY_TYPE_U16B() antlr.TerminalNode
	ARRAY_U_B_END() antlr.TerminalNode
	ARRAY_TYPE_U16O() antlr.TerminalNode
	ARRAY_U_O_END() antlr.TerminalNode
	ARRAY_TYPE_U16X() antlr.TerminalNode
	ARRAY_U_X_END() antlr.TerminalNode
	AllARRAY_U_WSL() []antlr.TerminalNode
	ARRAY_U_WSL(i int) antlr.TerminalNode
	AllArrayElemUint() []IArrayElemUintContext
	ArrayElemUint(i int) IArrayElemUintContext
	AllARRAY_U_B_WSL() []antlr.TerminalNode
	ARRAY_U_B_WSL(i int) antlr.TerminalNode
	AllArrayElemUintB() []IArrayElemUintBContext
	ArrayElemUintB(i int) IArrayElemUintBContext
	AllARRAY_U_O_WSL() []antlr.TerminalNode
	ARRAY_U_O_WSL(i int) antlr.TerminalNode
	AllArrayElemUintO() []IArrayElemUintOContext
	ArrayElemUintO(i int) IArrayElemUintOContext
	AllARRAY_U_X_WSL() []antlr.TerminalNode
	ARRAY_U_X_WSL(i int) antlr.TerminalNode
	AllArrayElemUintX() []IArrayElemUintXContext
	ArrayElemUintX(i int) IArrayElemUintXContext

	// IsArrayU16Context differentiates from other interfaces.
	IsArrayU16Context()
}

type ArrayU16Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayU16Context() *ArrayU16Context {
	var p = new(ArrayU16Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayU16
	return p
}

func (*ArrayU16Context) IsArrayU16Context() {}

func NewArrayU16Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayU16Context {
	var p = new(ArrayU16Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayU16

	return p
}

func (s *ArrayU16Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayU16Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayU16Context) ARRAY_TYPE_U16_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U16_EMPTY, 0)
}

func (s *ArrayU16Context) ARRAY_TYPE_U16() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U16, 0)
}

func (s *ArrayU16Context) ARRAY_U_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_END, 0)
}

func (s *ArrayU16Context) ARRAY_TYPE_U16B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U16B, 0)
}

func (s *ArrayU16Context) ARRAY_U_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_END, 0)
}

func (s *ArrayU16Context) ARRAY_TYPE_U16O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U16O, 0)
}

func (s *ArrayU16Context) ARRAY_U_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_END, 0)
}

func (s *ArrayU16Context) ARRAY_TYPE_U16X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U16X, 0)
}

func (s *ArrayU16Context) ARRAY_U_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_END, 0)
}

func (s *ArrayU16Context) AllARRAY_U_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_WSL)
}

func (s *ArrayU16Context) ARRAY_U_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_WSL, i)
}

func (s *ArrayU16Context) AllArrayElemUint() []IArrayElemUintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintContext); ok {
			tst[i] = t.(IArrayElemUintContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU16Context) ArrayElemUint(i int) IArrayElemUintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintContext)
}

func (s *ArrayU16Context) AllARRAY_U_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_B_WSL)
}

func (s *ArrayU16Context) ARRAY_U_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_WSL, i)
}

func (s *ArrayU16Context) AllArrayElemUintB() []IArrayElemUintBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintBContext); ok {
			tst[i] = t.(IArrayElemUintBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU16Context) ArrayElemUintB(i int) IArrayElemUintBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintBContext)
}

func (s *ArrayU16Context) AllARRAY_U_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_O_WSL)
}

func (s *ArrayU16Context) ARRAY_U_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_WSL, i)
}

func (s *ArrayU16Context) AllArrayElemUintO() []IArrayElemUintOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintOContext); ok {
			tst[i] = t.(IArrayElemUintOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU16Context) ArrayElemUintO(i int) IArrayElemUintOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintOContext)
}

func (s *ArrayU16Context) AllARRAY_U_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_X_WSL)
}

func (s *ArrayU16Context) ARRAY_U_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_WSL, i)
}

func (s *ArrayU16Context) AllArrayElemUintX() []IArrayElemUintXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintXContext); ok {
			tst[i] = t.(IArrayElemUintXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU16Context) ArrayElemUintX(i int) IArrayElemUintXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintXContext)
}

func (s *ArrayU16Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayU16Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayU16Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayU16(s)
	}
}

func (s *ArrayU16Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayU16(s)
	}
}

func (p *CTEParser) ArrayU16() (localctx IArrayU16Context) {
	this := p
	_ = this

	localctx = NewArrayU16Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CTEParserRULE_arrayU16)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_U16, CTEParserARRAY_TYPE_U16B, CTEParserARRAY_TYPE_U16O, CTEParserARRAY_TYPE_U16X:
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_U16:
			{
				p.SetState(1030)
				p.Match(CTEParserARRAY_TYPE_U16)
			}
			p.SetState(1032)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_WSL {
				{
					p.SetState(1031)
					p.Match(CTEParserARRAY_U_WSL)
				}

			}
			p.SetState(1045)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&15) != 0 {
				{
					p.SetState(1034)
					p.ArrayElemUint()
				}
				p.SetState(1039)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1035)
							p.Match(CTEParserARRAY_U_WSL)
						}
						{
							p.SetState(1036)
							p.ArrayElemUint()
						}

					}
					p.SetState(1041)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())
				}
				p.SetState(1043)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_WSL {
					{
						p.SetState(1042)
						p.Match(CTEParserARRAY_U_WSL)
					}

				}

			}
			{
				p.SetState(1047)
				p.Match(CTEParserARRAY_U_END)
			}

		case CTEParserARRAY_TYPE_U16B:
			{
				p.SetState(1048)
				p.Match(CTEParserARRAY_TYPE_U16B)
			}
			p.SetState(1050)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_WSL {
				{
					p.SetState(1049)
					p.Match(CTEParserARRAY_U_B_WSL)
				}

			}
			p.SetState(1063)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_ELEM {
				{
					p.SetState(1052)
					p.ArrayElemUintB()
				}
				p.SetState(1057)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1053)
							p.Match(CTEParserARRAY_U_B_WSL)
						}
						{
							p.SetState(1054)
							p.ArrayElemUintB()
						}

					}
					p.SetState(1059)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
				}
				p.SetState(1061)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_B_WSL {
					{
						p.SetState(1060)
						p.Match(CTEParserARRAY_U_B_WSL)
					}

				}

			}
			{
				p.SetState(1065)
				p.Match(CTEParserARRAY_U_B_END)
			}

		case CTEParserARRAY_TYPE_U16O:
			{
				p.SetState(1066)
				p.Match(CTEParserARRAY_TYPE_U16O)
			}
			p.SetState(1068)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_WSL {
				{
					p.SetState(1067)
					p.Match(CTEParserARRAY_U_O_WSL)
				}

			}
			p.SetState(1081)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_ELEM {
				{
					p.SetState(1070)
					p.ArrayElemUintO()
				}
				p.SetState(1075)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1071)
							p.Match(CTEParserARRAY_U_O_WSL)
						}
						{
							p.SetState(1072)
							p.ArrayElemUintO()
						}

					}
					p.SetState(1077)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())
				}
				p.SetState(1079)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_O_WSL {
					{
						p.SetState(1078)
						p.Match(CTEParserARRAY_U_O_WSL)
					}

				}

			}
			{
				p.SetState(1083)
				p.Match(CTEParserARRAY_U_O_END)
			}

		case CTEParserARRAY_TYPE_U16X:
			{
				p.SetState(1084)
				p.Match(CTEParserARRAY_TYPE_U16X)
			}
			p.SetState(1086)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_WSL {
				{
					p.SetState(1085)
					p.Match(CTEParserARRAY_U_X_WSL)
				}

			}
			p.SetState(1099)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_ELEM {
				{
					p.SetState(1088)
					p.ArrayElemUintX()
				}
				p.SetState(1093)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1089)
							p.Match(CTEParserARRAY_U_X_WSL)
						}
						{
							p.SetState(1090)
							p.ArrayElemUintX()
						}

					}
					p.SetState(1095)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
				}
				p.SetState(1097)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_X_WSL {
					{
						p.SetState(1096)
						p.Match(CTEParserARRAY_U_X_WSL)
					}

				}

			}
			{
				p.SetState(1101)
				p.Match(CTEParserARRAY_U_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_U16_EMPTY:
		{
			p.SetState(1104)
			p.Match(CTEParserARRAY_TYPE_U16_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayU32Context is an interface to support dynamic dispatch.
type IArrayU32Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_U32_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_U32() antlr.TerminalNode
	ARRAY_U_END() antlr.TerminalNode
	ARRAY_TYPE_U32B() antlr.TerminalNode
	ARRAY_U_B_END() antlr.TerminalNode
	ARRAY_TYPE_U32O() antlr.TerminalNode
	ARRAY_U_O_END() antlr.TerminalNode
	ARRAY_TYPE_U32X() antlr.TerminalNode
	ARRAY_U_X_END() antlr.TerminalNode
	AllARRAY_U_WSL() []antlr.TerminalNode
	ARRAY_U_WSL(i int) antlr.TerminalNode
	AllArrayElemUint() []IArrayElemUintContext
	ArrayElemUint(i int) IArrayElemUintContext
	AllARRAY_U_B_WSL() []antlr.TerminalNode
	ARRAY_U_B_WSL(i int) antlr.TerminalNode
	AllArrayElemUintB() []IArrayElemUintBContext
	ArrayElemUintB(i int) IArrayElemUintBContext
	AllARRAY_U_O_WSL() []antlr.TerminalNode
	ARRAY_U_O_WSL(i int) antlr.TerminalNode
	AllArrayElemUintO() []IArrayElemUintOContext
	ArrayElemUintO(i int) IArrayElemUintOContext
	AllARRAY_U_X_WSL() []antlr.TerminalNode
	ARRAY_U_X_WSL(i int) antlr.TerminalNode
	AllArrayElemUintX() []IArrayElemUintXContext
	ArrayElemUintX(i int) IArrayElemUintXContext

	// IsArrayU32Context differentiates from other interfaces.
	IsArrayU32Context()
}

type ArrayU32Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayU32Context() *ArrayU32Context {
	var p = new(ArrayU32Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayU32
	return p
}

func (*ArrayU32Context) IsArrayU32Context() {}

func NewArrayU32Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayU32Context {
	var p = new(ArrayU32Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayU32

	return p
}

func (s *ArrayU32Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayU32Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayU32Context) ARRAY_TYPE_U32_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U32_EMPTY, 0)
}

func (s *ArrayU32Context) ARRAY_TYPE_U32() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U32, 0)
}

func (s *ArrayU32Context) ARRAY_U_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_END, 0)
}

func (s *ArrayU32Context) ARRAY_TYPE_U32B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U32B, 0)
}

func (s *ArrayU32Context) ARRAY_U_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_END, 0)
}

func (s *ArrayU32Context) ARRAY_TYPE_U32O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U32O, 0)
}

func (s *ArrayU32Context) ARRAY_U_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_END, 0)
}

func (s *ArrayU32Context) ARRAY_TYPE_U32X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U32X, 0)
}

func (s *ArrayU32Context) ARRAY_U_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_END, 0)
}

func (s *ArrayU32Context) AllARRAY_U_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_WSL)
}

func (s *ArrayU32Context) ARRAY_U_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_WSL, i)
}

func (s *ArrayU32Context) AllArrayElemUint() []IArrayElemUintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintContext); ok {
			tst[i] = t.(IArrayElemUintContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU32Context) ArrayElemUint(i int) IArrayElemUintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintContext)
}

func (s *ArrayU32Context) AllARRAY_U_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_B_WSL)
}

func (s *ArrayU32Context) ARRAY_U_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_WSL, i)
}

func (s *ArrayU32Context) AllArrayElemUintB() []IArrayElemUintBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintBContext); ok {
			tst[i] = t.(IArrayElemUintBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU32Context) ArrayElemUintB(i int) IArrayElemUintBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintBContext)
}

func (s *ArrayU32Context) AllARRAY_U_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_O_WSL)
}

func (s *ArrayU32Context) ARRAY_U_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_WSL, i)
}

func (s *ArrayU32Context) AllArrayElemUintO() []IArrayElemUintOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintOContext); ok {
			tst[i] = t.(IArrayElemUintOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU32Context) ArrayElemUintO(i int) IArrayElemUintOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintOContext)
}

func (s *ArrayU32Context) AllARRAY_U_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_X_WSL)
}

func (s *ArrayU32Context) ARRAY_U_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_WSL, i)
}

func (s *ArrayU32Context) AllArrayElemUintX() []IArrayElemUintXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintXContext); ok {
			tst[i] = t.(IArrayElemUintXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU32Context) ArrayElemUintX(i int) IArrayElemUintXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintXContext)
}

func (s *ArrayU32Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayU32Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayU32Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayU32(s)
	}
}

func (s *ArrayU32Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayU32(s)
	}
}

func (p *CTEParser) ArrayU32() (localctx IArrayU32Context) {
	this := p
	_ = this

	localctx = NewArrayU32Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CTEParserRULE_arrayU32)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1107)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_U32, CTEParserARRAY_TYPE_U32B, CTEParserARRAY_TYPE_U32O, CTEParserARRAY_TYPE_U32X:
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_U32:
			{
				p.SetState(1108)
				p.Match(CTEParserARRAY_TYPE_U32)
			}
			p.SetState(1110)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_WSL {
				{
					p.SetState(1109)
					p.Match(CTEParserARRAY_U_WSL)
				}

			}
			p.SetState(1123)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&15) != 0 {
				{
					p.SetState(1112)
					p.ArrayElemUint()
				}
				p.SetState(1117)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1113)
							p.Match(CTEParserARRAY_U_WSL)
						}
						{
							p.SetState(1114)
							p.ArrayElemUint()
						}

					}
					p.SetState(1119)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())
				}
				p.SetState(1121)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_WSL {
					{
						p.SetState(1120)
						p.Match(CTEParserARRAY_U_WSL)
					}

				}

			}
			{
				p.SetState(1125)
				p.Match(CTEParserARRAY_U_END)
			}

		case CTEParserARRAY_TYPE_U32B:
			{
				p.SetState(1126)
				p.Match(CTEParserARRAY_TYPE_U32B)
			}
			p.SetState(1128)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_WSL {
				{
					p.SetState(1127)
					p.Match(CTEParserARRAY_U_B_WSL)
				}

			}
			p.SetState(1141)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_ELEM {
				{
					p.SetState(1130)
					p.ArrayElemUintB()
				}
				p.SetState(1135)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1131)
							p.Match(CTEParserARRAY_U_B_WSL)
						}
						{
							p.SetState(1132)
							p.ArrayElemUintB()
						}

					}
					p.SetState(1137)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())
				}
				p.SetState(1139)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_B_WSL {
					{
						p.SetState(1138)
						p.Match(CTEParserARRAY_U_B_WSL)
					}

				}

			}
			{
				p.SetState(1143)
				p.Match(CTEParserARRAY_U_B_END)
			}

		case CTEParserARRAY_TYPE_U32O:
			{
				p.SetState(1144)
				p.Match(CTEParserARRAY_TYPE_U32O)
			}
			p.SetState(1146)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_WSL {
				{
					p.SetState(1145)
					p.Match(CTEParserARRAY_U_O_WSL)
				}

			}
			p.SetState(1159)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_ELEM {
				{
					p.SetState(1148)
					p.ArrayElemUintO()
				}
				p.SetState(1153)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1149)
							p.Match(CTEParserARRAY_U_O_WSL)
						}
						{
							p.SetState(1150)
							p.ArrayElemUintO()
						}

					}
					p.SetState(1155)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
				}
				p.SetState(1157)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_O_WSL {
					{
						p.SetState(1156)
						p.Match(CTEParserARRAY_U_O_WSL)
					}

				}

			}
			{
				p.SetState(1161)
				p.Match(CTEParserARRAY_U_O_END)
			}

		case CTEParserARRAY_TYPE_U32X:
			{
				p.SetState(1162)
				p.Match(CTEParserARRAY_TYPE_U32X)
			}
			p.SetState(1164)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_WSL {
				{
					p.SetState(1163)
					p.Match(CTEParserARRAY_U_X_WSL)
				}

			}
			p.SetState(1177)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_ELEM {
				{
					p.SetState(1166)
					p.ArrayElemUintX()
				}
				p.SetState(1171)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1167)
							p.Match(CTEParserARRAY_U_X_WSL)
						}
						{
							p.SetState(1168)
							p.ArrayElemUintX()
						}

					}
					p.SetState(1173)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())
				}
				p.SetState(1175)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_X_WSL {
					{
						p.SetState(1174)
						p.Match(CTEParserARRAY_U_X_WSL)
					}

				}

			}
			{
				p.SetState(1179)
				p.Match(CTEParserARRAY_U_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_U32_EMPTY:
		{
			p.SetState(1182)
			p.Match(CTEParserARRAY_TYPE_U32_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayU64Context is an interface to support dynamic dispatch.
type IArrayU64Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_U64_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_U64() antlr.TerminalNode
	ARRAY_U_END() antlr.TerminalNode
	ARRAY_TYPE_U64B() antlr.TerminalNode
	ARRAY_U_B_END() antlr.TerminalNode
	ARRAY_TYPE_U64O() antlr.TerminalNode
	ARRAY_U_O_END() antlr.TerminalNode
	ARRAY_TYPE_U64X() antlr.TerminalNode
	ARRAY_U_X_END() antlr.TerminalNode
	AllARRAY_U_WSL() []antlr.TerminalNode
	ARRAY_U_WSL(i int) antlr.TerminalNode
	AllArrayElemUint() []IArrayElemUintContext
	ArrayElemUint(i int) IArrayElemUintContext
	AllARRAY_U_B_WSL() []antlr.TerminalNode
	ARRAY_U_B_WSL(i int) antlr.TerminalNode
	AllArrayElemUintB() []IArrayElemUintBContext
	ArrayElemUintB(i int) IArrayElemUintBContext
	AllARRAY_U_O_WSL() []antlr.TerminalNode
	ARRAY_U_O_WSL(i int) antlr.TerminalNode
	AllArrayElemUintO() []IArrayElemUintOContext
	ArrayElemUintO(i int) IArrayElemUintOContext
	AllARRAY_U_X_WSL() []antlr.TerminalNode
	ARRAY_U_X_WSL(i int) antlr.TerminalNode
	AllArrayElemUintX() []IArrayElemUintXContext
	ArrayElemUintX(i int) IArrayElemUintXContext

	// IsArrayU64Context differentiates from other interfaces.
	IsArrayU64Context()
}

type ArrayU64Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayU64Context() *ArrayU64Context {
	var p = new(ArrayU64Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayU64
	return p
}

func (*ArrayU64Context) IsArrayU64Context() {}

func NewArrayU64Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayU64Context {
	var p = new(ArrayU64Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayU64

	return p
}

func (s *ArrayU64Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayU64Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayU64Context) ARRAY_TYPE_U64_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U64_EMPTY, 0)
}

func (s *ArrayU64Context) ARRAY_TYPE_U64() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U64, 0)
}

func (s *ArrayU64Context) ARRAY_U_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_END, 0)
}

func (s *ArrayU64Context) ARRAY_TYPE_U64B() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U64B, 0)
}

func (s *ArrayU64Context) ARRAY_U_B_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_END, 0)
}

func (s *ArrayU64Context) ARRAY_TYPE_U64O() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U64O, 0)
}

func (s *ArrayU64Context) ARRAY_U_O_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_END, 0)
}

func (s *ArrayU64Context) ARRAY_TYPE_U64X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_U64X, 0)
}

func (s *ArrayU64Context) ARRAY_U_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_END, 0)
}

func (s *ArrayU64Context) AllARRAY_U_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_WSL)
}

func (s *ArrayU64Context) ARRAY_U_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_WSL, i)
}

func (s *ArrayU64Context) AllArrayElemUint() []IArrayElemUintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintContext); ok {
			tst[i] = t.(IArrayElemUintContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU64Context) ArrayElemUint(i int) IArrayElemUintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintContext)
}

func (s *ArrayU64Context) AllARRAY_U_B_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_B_WSL)
}

func (s *ArrayU64Context) ARRAY_U_B_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_B_WSL, i)
}

func (s *ArrayU64Context) AllArrayElemUintB() []IArrayElemUintBContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintBContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintBContext); ok {
			tst[i] = t.(IArrayElemUintBContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU64Context) ArrayElemUintB(i int) IArrayElemUintBContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintBContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintBContext)
}

func (s *ArrayU64Context) AllARRAY_U_O_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_O_WSL)
}

func (s *ArrayU64Context) ARRAY_U_O_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_O_WSL, i)
}

func (s *ArrayU64Context) AllArrayElemUintO() []IArrayElemUintOContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintOContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintOContext); ok {
			tst[i] = t.(IArrayElemUintOContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU64Context) ArrayElemUintO(i int) IArrayElemUintOContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintOContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintOContext)
}

func (s *ArrayU64Context) AllARRAY_U_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_U_X_WSL)
}

func (s *ArrayU64Context) ARRAY_U_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_U_X_WSL, i)
}

func (s *ArrayU64Context) AllArrayElemUintX() []IArrayElemUintXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUintXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUintXContext); ok {
			tst[i] = t.(IArrayElemUintXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayU64Context) ArrayElemUintX(i int) IArrayElemUintXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUintXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUintXContext)
}

func (s *ArrayU64Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayU64Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayU64Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayU64(s)
	}
}

func (s *ArrayU64Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayU64(s)
	}
}

func (p *CTEParser) ArrayU64() (localctx IArrayU64Context) {
	this := p
	_ = this

	localctx = NewArrayU64Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CTEParserRULE_arrayU64)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1185)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_U64, CTEParserARRAY_TYPE_U64B, CTEParserARRAY_TYPE_U64O, CTEParserARRAY_TYPE_U64X:
		p.SetState(1258)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_U64:
			{
				p.SetState(1186)
				p.Match(CTEParserARRAY_TYPE_U64)
			}
			p.SetState(1188)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_WSL {
				{
					p.SetState(1187)
					p.Match(CTEParserARRAY_U_WSL)
				}

			}
			p.SetState(1201)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&15) != 0 {
				{
					p.SetState(1190)
					p.ArrayElemUint()
				}
				p.SetState(1195)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1191)
							p.Match(CTEParserARRAY_U_WSL)
						}
						{
							p.SetState(1192)
							p.ArrayElemUint()
						}

					}
					p.SetState(1197)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext())
				}
				p.SetState(1199)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_WSL {
					{
						p.SetState(1198)
						p.Match(CTEParserARRAY_U_WSL)
					}

				}

			}
			{
				p.SetState(1203)
				p.Match(CTEParserARRAY_U_END)
			}

		case CTEParserARRAY_TYPE_U64B:
			{
				p.SetState(1204)
				p.Match(CTEParserARRAY_TYPE_U64B)
			}
			p.SetState(1206)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_WSL {
				{
					p.SetState(1205)
					p.Match(CTEParserARRAY_U_B_WSL)
				}

			}
			p.SetState(1219)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_B_ELEM {
				{
					p.SetState(1208)
					p.ArrayElemUintB()
				}
				p.SetState(1213)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1209)
							p.Match(CTEParserARRAY_U_B_WSL)
						}
						{
							p.SetState(1210)
							p.ArrayElemUintB()
						}

					}
					p.SetState(1215)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())
				}
				p.SetState(1217)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_B_WSL {
					{
						p.SetState(1216)
						p.Match(CTEParserARRAY_U_B_WSL)
					}

				}

			}
			{
				p.SetState(1221)
				p.Match(CTEParserARRAY_U_B_END)
			}

		case CTEParserARRAY_TYPE_U64O:
			{
				p.SetState(1222)
				p.Match(CTEParserARRAY_TYPE_U64O)
			}
			p.SetState(1224)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_WSL {
				{
					p.SetState(1223)
					p.Match(CTEParserARRAY_U_O_WSL)
				}

			}
			p.SetState(1237)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_O_ELEM {
				{
					p.SetState(1226)
					p.ArrayElemUintO()
				}
				p.SetState(1231)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1227)
							p.Match(CTEParserARRAY_U_O_WSL)
						}
						{
							p.SetState(1228)
							p.ArrayElemUintO()
						}

					}
					p.SetState(1233)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())
				}
				p.SetState(1235)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_O_WSL {
					{
						p.SetState(1234)
						p.Match(CTEParserARRAY_U_O_WSL)
					}

				}

			}
			{
				p.SetState(1239)
				p.Match(CTEParserARRAY_U_O_END)
			}

		case CTEParserARRAY_TYPE_U64X:
			{
				p.SetState(1240)
				p.Match(CTEParserARRAY_TYPE_U64X)
			}
			p.SetState(1242)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_WSL {
				{
					p.SetState(1241)
					p.Match(CTEParserARRAY_U_X_WSL)
				}

			}
			p.SetState(1255)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_U_X_ELEM {
				{
					p.SetState(1244)
					p.ArrayElemUintX()
				}
				p.SetState(1249)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1245)
							p.Match(CTEParserARRAY_U_X_WSL)
						}
						{
							p.SetState(1246)
							p.ArrayElemUintX()
						}

					}
					p.SetState(1251)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext())
				}
				p.SetState(1253)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_U_X_WSL {
					{
						p.SetState(1252)
						p.Match(CTEParserARRAY_U_X_WSL)
					}

				}

			}
			{
				p.SetState(1257)
				p.Match(CTEParserARRAY_U_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_U64_EMPTY:
		{
			p.SetState(1260)
			p.Match(CTEParserARRAY_TYPE_U64_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayF16Context is an interface to support dynamic dispatch.
type IArrayF16Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_F16_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_F16() antlr.TerminalNode
	ARRAY_F_END() antlr.TerminalNode
	ARRAY_TYPE_F16X() antlr.TerminalNode
	ARRAY_F_X_END() antlr.TerminalNode
	AllARRAY_F_WSL() []antlr.TerminalNode
	ARRAY_F_WSL(i int) antlr.TerminalNode
	AllARRAY_F_X_WSL() []antlr.TerminalNode
	ARRAY_F_X_WSL(i int) antlr.TerminalNode
	AllArrayElemFloat() []IArrayElemFloatContext
	ArrayElemFloat(i int) IArrayElemFloatContext
	AllArrayElemNan() []IArrayElemNanContext
	ArrayElemNan(i int) IArrayElemNanContext
	AllArrayElemSnan() []IArrayElemSnanContext
	ArrayElemSnan(i int) IArrayElemSnanContext
	AllArrayElemInf() []IArrayElemInfContext
	ArrayElemInf(i int) IArrayElemInfContext
	AllArrayElemNinf() []IArrayElemNinfContext
	ArrayElemNinf(i int) IArrayElemNinfContext
	AllArrayElemFloatX() []IArrayElemFloatXContext
	ArrayElemFloatX(i int) IArrayElemFloatXContext

	// IsArrayF16Context differentiates from other interfaces.
	IsArrayF16Context()
}

type ArrayF16Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayF16Context() *ArrayF16Context {
	var p = new(ArrayF16Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayF16
	return p
}

func (*ArrayF16Context) IsArrayF16Context() {}

func NewArrayF16Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayF16Context {
	var p = new(ArrayF16Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayF16

	return p
}

func (s *ArrayF16Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayF16Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayF16Context) ARRAY_TYPE_F16_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F16_EMPTY, 0)
}

func (s *ArrayF16Context) ARRAY_TYPE_F16() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F16, 0)
}

func (s *ArrayF16Context) ARRAY_F_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_END, 0)
}

func (s *ArrayF16Context) ARRAY_TYPE_F16X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F16X, 0)
}

func (s *ArrayF16Context) ARRAY_F_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_END, 0)
}

func (s *ArrayF16Context) AllARRAY_F_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_F_WSL)
}

func (s *ArrayF16Context) ARRAY_F_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_WSL, i)
}

func (s *ArrayF16Context) AllARRAY_F_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_F_X_WSL)
}

func (s *ArrayF16Context) ARRAY_F_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_WSL, i)
}

func (s *ArrayF16Context) AllArrayElemFloat() []IArrayElemFloatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemFloatContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemFloatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemFloatContext); ok {
			tst[i] = t.(IArrayElemFloatContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF16Context) ArrayElemFloat(i int) IArrayElemFloatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemFloatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemFloatContext)
}

func (s *ArrayF16Context) AllArrayElemNan() []IArrayElemNanContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemNanContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemNanContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemNanContext); ok {
			tst[i] = t.(IArrayElemNanContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF16Context) ArrayElemNan(i int) IArrayElemNanContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemNanContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemNanContext)
}

func (s *ArrayF16Context) AllArrayElemSnan() []IArrayElemSnanContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemSnanContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemSnanContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemSnanContext); ok {
			tst[i] = t.(IArrayElemSnanContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF16Context) ArrayElemSnan(i int) IArrayElemSnanContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemSnanContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemSnanContext)
}

func (s *ArrayF16Context) AllArrayElemInf() []IArrayElemInfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemInfContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemInfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemInfContext); ok {
			tst[i] = t.(IArrayElemInfContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF16Context) ArrayElemInf(i int) IArrayElemInfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemInfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemInfContext)
}

func (s *ArrayF16Context) AllArrayElemNinf() []IArrayElemNinfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemNinfContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemNinfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemNinfContext); ok {
			tst[i] = t.(IArrayElemNinfContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF16Context) ArrayElemNinf(i int) IArrayElemNinfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemNinfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemNinfContext)
}

func (s *ArrayF16Context) AllArrayElemFloatX() []IArrayElemFloatXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemFloatXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemFloatXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemFloatXContext); ok {
			tst[i] = t.(IArrayElemFloatXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF16Context) ArrayElemFloatX(i int) IArrayElemFloatXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemFloatXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemFloatXContext)
}

func (s *ArrayF16Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayF16Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayF16Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayF16(s)
	}
}

func (s *ArrayF16Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayF16(s)
	}
}

func (p *CTEParser) ArrayF16() (localctx IArrayF16Context) {
	this := p
	_ = this

	localctx = NewArrayF16Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CTEParserRULE_arrayF16)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1263)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_F16, CTEParserARRAY_TYPE_F16X:
		p.SetState(1324)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_F16:
			{
				p.SetState(1264)
				p.Match(CTEParserARRAY_TYPE_F16)
			}
			p.SetState(1266)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_F_WSL {
				{
					p.SetState(1265)
					p.Match(CTEParserARRAY_F_WSL)
				}

			}
			p.SetState(1291)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&7743) != 0 {
				p.SetState(1273)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CTEParserARRAY_F_ELEM_D, CTEParserARRAY_F_ELEM_H:
					{
						p.SetState(1268)
						p.ArrayElemFloat()
					}

				case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
					{
						p.SetState(1269)
						p.ArrayElemNan()
					}

				case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
					{
						p.SetState(1270)
						p.ArrayElemSnan()
					}

				case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
					{
						p.SetState(1271)
						p.ArrayElemInf()
					}

				case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
					{
						p.SetState(1272)
						p.ArrayElemNinf()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				p.SetState(1285)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1275)
							p.Match(CTEParserARRAY_F_WSL)
						}
						p.SetState(1281)
						p.GetErrorHandler().Sync(p)

						switch p.GetTokenStream().LA(1) {
						case CTEParserARRAY_F_ELEM_D, CTEParserARRAY_F_ELEM_H:
							{
								p.SetState(1276)
								p.ArrayElemFloat()
							}

						case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
							{
								p.SetState(1277)
								p.ArrayElemNan()
							}

						case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
							{
								p.SetState(1278)
								p.ArrayElemSnan()
							}

						case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
							{
								p.SetState(1279)
								p.ArrayElemInf()
							}

						case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
							{
								p.SetState(1280)
								p.ArrayElemNinf()
							}

						default:
							panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						}

					}
					p.SetState(1287)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext())
				}
				p.SetState(1289)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_F_WSL {
					{
						p.SetState(1288)
						p.Match(CTEParserARRAY_F_WSL)
					}

				}

			}
			{
				p.SetState(1293)
				p.Match(CTEParserARRAY_F_END)
			}

		case CTEParserARRAY_TYPE_F16X:
			{
				p.SetState(1294)
				p.Match(CTEParserARRAY_TYPE_F16X)
			}
			p.SetState(1296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_F_X_WSL {
				{
					p.SetState(1295)
					p.Match(CTEParserARRAY_F_X_WSL)
				}

			}
			p.SetState(1321)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&1999) != 0 {
				p.SetState(1303)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CTEParserARRAY_F_X_ELEM:
					{
						p.SetState(1298)
						p.ArrayElemFloatX()
					}

				case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
					{
						p.SetState(1299)
						p.ArrayElemNan()
					}

				case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
					{
						p.SetState(1300)
						p.ArrayElemSnan()
					}

				case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
					{
						p.SetState(1301)
						p.ArrayElemInf()
					}

				case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
					{
						p.SetState(1302)
						p.ArrayElemNinf()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				p.SetState(1315)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1305)
							p.Match(CTEParserARRAY_F_X_WSL)
						}
						p.SetState(1311)
						p.GetErrorHandler().Sync(p)

						switch p.GetTokenStream().LA(1) {
						case CTEParserARRAY_F_X_ELEM:
							{
								p.SetState(1306)
								p.ArrayElemFloatX()
							}

						case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
							{
								p.SetState(1307)
								p.ArrayElemNan()
							}

						case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
							{
								p.SetState(1308)
								p.ArrayElemSnan()
							}

						case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
							{
								p.SetState(1309)
								p.ArrayElemInf()
							}

						case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
							{
								p.SetState(1310)
								p.ArrayElemNinf()
							}

						default:
							panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						}

					}
					p.SetState(1317)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())
				}
				p.SetState(1319)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_F_X_WSL {
					{
						p.SetState(1318)
						p.Match(CTEParserARRAY_F_X_WSL)
					}

				}

			}
			{
				p.SetState(1323)
				p.Match(CTEParserARRAY_F_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_F16_EMPTY:
		{
			p.SetState(1326)
			p.Match(CTEParserARRAY_TYPE_F16_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayF32Context is an interface to support dynamic dispatch.
type IArrayF32Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_F32_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_F32() antlr.TerminalNode
	ARRAY_F_END() antlr.TerminalNode
	ARRAY_TYPE_F32X() antlr.TerminalNode
	ARRAY_F_X_END() antlr.TerminalNode
	AllARRAY_F_WSL() []antlr.TerminalNode
	ARRAY_F_WSL(i int) antlr.TerminalNode
	AllARRAY_F_X_WSL() []antlr.TerminalNode
	ARRAY_F_X_WSL(i int) antlr.TerminalNode
	AllArrayElemFloat() []IArrayElemFloatContext
	ArrayElemFloat(i int) IArrayElemFloatContext
	AllArrayElemNan() []IArrayElemNanContext
	ArrayElemNan(i int) IArrayElemNanContext
	AllArrayElemSnan() []IArrayElemSnanContext
	ArrayElemSnan(i int) IArrayElemSnanContext
	AllArrayElemInf() []IArrayElemInfContext
	ArrayElemInf(i int) IArrayElemInfContext
	AllArrayElemNinf() []IArrayElemNinfContext
	ArrayElemNinf(i int) IArrayElemNinfContext
	AllArrayElemFloatX() []IArrayElemFloatXContext
	ArrayElemFloatX(i int) IArrayElemFloatXContext

	// IsArrayF32Context differentiates from other interfaces.
	IsArrayF32Context()
}

type ArrayF32Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayF32Context() *ArrayF32Context {
	var p = new(ArrayF32Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayF32
	return p
}

func (*ArrayF32Context) IsArrayF32Context() {}

func NewArrayF32Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayF32Context {
	var p = new(ArrayF32Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayF32

	return p
}

func (s *ArrayF32Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayF32Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayF32Context) ARRAY_TYPE_F32_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F32_EMPTY, 0)
}

func (s *ArrayF32Context) ARRAY_TYPE_F32() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F32, 0)
}

func (s *ArrayF32Context) ARRAY_F_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_END, 0)
}

func (s *ArrayF32Context) ARRAY_TYPE_F32X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F32X, 0)
}

func (s *ArrayF32Context) ARRAY_F_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_END, 0)
}

func (s *ArrayF32Context) AllARRAY_F_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_F_WSL)
}

func (s *ArrayF32Context) ARRAY_F_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_WSL, i)
}

func (s *ArrayF32Context) AllARRAY_F_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_F_X_WSL)
}

func (s *ArrayF32Context) ARRAY_F_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_WSL, i)
}

func (s *ArrayF32Context) AllArrayElemFloat() []IArrayElemFloatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemFloatContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemFloatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemFloatContext); ok {
			tst[i] = t.(IArrayElemFloatContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF32Context) ArrayElemFloat(i int) IArrayElemFloatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemFloatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemFloatContext)
}

func (s *ArrayF32Context) AllArrayElemNan() []IArrayElemNanContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemNanContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemNanContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemNanContext); ok {
			tst[i] = t.(IArrayElemNanContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF32Context) ArrayElemNan(i int) IArrayElemNanContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemNanContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemNanContext)
}

func (s *ArrayF32Context) AllArrayElemSnan() []IArrayElemSnanContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemSnanContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemSnanContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemSnanContext); ok {
			tst[i] = t.(IArrayElemSnanContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF32Context) ArrayElemSnan(i int) IArrayElemSnanContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemSnanContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemSnanContext)
}

func (s *ArrayF32Context) AllArrayElemInf() []IArrayElemInfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemInfContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemInfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemInfContext); ok {
			tst[i] = t.(IArrayElemInfContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF32Context) ArrayElemInf(i int) IArrayElemInfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemInfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemInfContext)
}

func (s *ArrayF32Context) AllArrayElemNinf() []IArrayElemNinfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemNinfContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemNinfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemNinfContext); ok {
			tst[i] = t.(IArrayElemNinfContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF32Context) ArrayElemNinf(i int) IArrayElemNinfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemNinfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemNinfContext)
}

func (s *ArrayF32Context) AllArrayElemFloatX() []IArrayElemFloatXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemFloatXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemFloatXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemFloatXContext); ok {
			tst[i] = t.(IArrayElemFloatXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF32Context) ArrayElemFloatX(i int) IArrayElemFloatXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemFloatXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemFloatXContext)
}

func (s *ArrayF32Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayF32Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayF32Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayF32(s)
	}
}

func (s *ArrayF32Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayF32(s)
	}
}

func (p *CTEParser) ArrayF32() (localctx IArrayF32Context) {
	this := p
	_ = this

	localctx = NewArrayF32Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CTEParserRULE_arrayF32)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1329)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_F32, CTEParserARRAY_TYPE_F32X:
		p.SetState(1390)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_F32:
			{
				p.SetState(1330)
				p.Match(CTEParserARRAY_TYPE_F32)
			}
			p.SetState(1332)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_F_WSL {
				{
					p.SetState(1331)
					p.Match(CTEParserARRAY_F_WSL)
				}

			}
			p.SetState(1357)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&7743) != 0 {
				p.SetState(1339)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CTEParserARRAY_F_ELEM_D, CTEParserARRAY_F_ELEM_H:
					{
						p.SetState(1334)
						p.ArrayElemFloat()
					}

				case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
					{
						p.SetState(1335)
						p.ArrayElemNan()
					}

				case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
					{
						p.SetState(1336)
						p.ArrayElemSnan()
					}

				case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
					{
						p.SetState(1337)
						p.ArrayElemInf()
					}

				case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
					{
						p.SetState(1338)
						p.ArrayElemNinf()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				p.SetState(1351)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1341)
							p.Match(CTEParserARRAY_F_WSL)
						}
						p.SetState(1347)
						p.GetErrorHandler().Sync(p)

						switch p.GetTokenStream().LA(1) {
						case CTEParserARRAY_F_ELEM_D, CTEParserARRAY_F_ELEM_H:
							{
								p.SetState(1342)
								p.ArrayElemFloat()
							}

						case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
							{
								p.SetState(1343)
								p.ArrayElemNan()
							}

						case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
							{
								p.SetState(1344)
								p.ArrayElemSnan()
							}

						case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
							{
								p.SetState(1345)
								p.ArrayElemInf()
							}

						case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
							{
								p.SetState(1346)
								p.ArrayElemNinf()
							}

						default:
							panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						}

					}
					p.SetState(1353)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext())
				}
				p.SetState(1355)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_F_WSL {
					{
						p.SetState(1354)
						p.Match(CTEParserARRAY_F_WSL)
					}

				}

			}
			{
				p.SetState(1359)
				p.Match(CTEParserARRAY_F_END)
			}

		case CTEParserARRAY_TYPE_F32X:
			{
				p.SetState(1360)
				p.Match(CTEParserARRAY_TYPE_F32X)
			}
			p.SetState(1362)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_F_X_WSL {
				{
					p.SetState(1361)
					p.Match(CTEParserARRAY_F_X_WSL)
				}

			}
			p.SetState(1387)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&1999) != 0 {
				p.SetState(1369)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CTEParserARRAY_F_X_ELEM:
					{
						p.SetState(1364)
						p.ArrayElemFloatX()
					}

				case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
					{
						p.SetState(1365)
						p.ArrayElemNan()
					}

				case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
					{
						p.SetState(1366)
						p.ArrayElemSnan()
					}

				case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
					{
						p.SetState(1367)
						p.ArrayElemInf()
					}

				case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
					{
						p.SetState(1368)
						p.ArrayElemNinf()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				p.SetState(1381)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1371)
							p.Match(CTEParserARRAY_F_X_WSL)
						}
						p.SetState(1377)
						p.GetErrorHandler().Sync(p)

						switch p.GetTokenStream().LA(1) {
						case CTEParserARRAY_F_X_ELEM:
							{
								p.SetState(1372)
								p.ArrayElemFloatX()
							}

						case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
							{
								p.SetState(1373)
								p.ArrayElemNan()
							}

						case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
							{
								p.SetState(1374)
								p.ArrayElemSnan()
							}

						case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
							{
								p.SetState(1375)
								p.ArrayElemInf()
							}

						case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
							{
								p.SetState(1376)
								p.ArrayElemNinf()
							}

						default:
							panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						}

					}
					p.SetState(1383)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext())
				}
				p.SetState(1385)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_F_X_WSL {
					{
						p.SetState(1384)
						p.Match(CTEParserARRAY_F_X_WSL)
					}

				}

			}
			{
				p.SetState(1389)
				p.Match(CTEParserARRAY_F_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_F32_EMPTY:
		{
			p.SetState(1392)
			p.Match(CTEParserARRAY_TYPE_F32_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayF64Context is an interface to support dynamic dispatch.
type IArrayF64Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_F64_EMPTY() antlr.TerminalNode
	ARRAY_TYPE_F64() antlr.TerminalNode
	ARRAY_F_END() antlr.TerminalNode
	ARRAY_TYPE_F64X() antlr.TerminalNode
	ARRAY_F_X_END() antlr.TerminalNode
	AllARRAY_F_WSL() []antlr.TerminalNode
	ARRAY_F_WSL(i int) antlr.TerminalNode
	AllARRAY_F_X_WSL() []antlr.TerminalNode
	ARRAY_F_X_WSL(i int) antlr.TerminalNode
	AllArrayElemFloat() []IArrayElemFloatContext
	ArrayElemFloat(i int) IArrayElemFloatContext
	AllArrayElemNan() []IArrayElemNanContext
	ArrayElemNan(i int) IArrayElemNanContext
	AllArrayElemSnan() []IArrayElemSnanContext
	ArrayElemSnan(i int) IArrayElemSnanContext
	AllArrayElemInf() []IArrayElemInfContext
	ArrayElemInf(i int) IArrayElemInfContext
	AllArrayElemNinf() []IArrayElemNinfContext
	ArrayElemNinf(i int) IArrayElemNinfContext
	AllArrayElemFloatX() []IArrayElemFloatXContext
	ArrayElemFloatX(i int) IArrayElemFloatXContext

	// IsArrayF64Context differentiates from other interfaces.
	IsArrayF64Context()
}

type ArrayF64Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayF64Context() *ArrayF64Context {
	var p = new(ArrayF64Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayF64
	return p
}

func (*ArrayF64Context) IsArrayF64Context() {}

func NewArrayF64Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayF64Context {
	var p = new(ArrayF64Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayF64

	return p
}

func (s *ArrayF64Context) GetParser() antlr.Parser { return s.parser }

func (s *ArrayF64Context) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayF64Context) ARRAY_TYPE_F64_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F64_EMPTY, 0)
}

func (s *ArrayF64Context) ARRAY_TYPE_F64() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F64, 0)
}

func (s *ArrayF64Context) ARRAY_F_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_END, 0)
}

func (s *ArrayF64Context) ARRAY_TYPE_F64X() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_F64X, 0)
}

func (s *ArrayF64Context) ARRAY_F_X_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_END, 0)
}

func (s *ArrayF64Context) AllARRAY_F_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_F_WSL)
}

func (s *ArrayF64Context) ARRAY_F_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_WSL, i)
}

func (s *ArrayF64Context) AllARRAY_F_X_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_F_X_WSL)
}

func (s *ArrayF64Context) ARRAY_F_X_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_F_X_WSL, i)
}

func (s *ArrayF64Context) AllArrayElemFloat() []IArrayElemFloatContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemFloatContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemFloatContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemFloatContext); ok {
			tst[i] = t.(IArrayElemFloatContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF64Context) ArrayElemFloat(i int) IArrayElemFloatContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemFloatContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemFloatContext)
}

func (s *ArrayF64Context) AllArrayElemNan() []IArrayElemNanContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemNanContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemNanContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemNanContext); ok {
			tst[i] = t.(IArrayElemNanContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF64Context) ArrayElemNan(i int) IArrayElemNanContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemNanContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemNanContext)
}

func (s *ArrayF64Context) AllArrayElemSnan() []IArrayElemSnanContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemSnanContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemSnanContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemSnanContext); ok {
			tst[i] = t.(IArrayElemSnanContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF64Context) ArrayElemSnan(i int) IArrayElemSnanContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemSnanContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemSnanContext)
}

func (s *ArrayF64Context) AllArrayElemInf() []IArrayElemInfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemInfContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemInfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemInfContext); ok {
			tst[i] = t.(IArrayElemInfContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF64Context) ArrayElemInf(i int) IArrayElemInfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemInfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemInfContext)
}

func (s *ArrayF64Context) AllArrayElemNinf() []IArrayElemNinfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemNinfContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemNinfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemNinfContext); ok {
			tst[i] = t.(IArrayElemNinfContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF64Context) ArrayElemNinf(i int) IArrayElemNinfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemNinfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemNinfContext)
}

func (s *ArrayF64Context) AllArrayElemFloatX() []IArrayElemFloatXContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemFloatXContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemFloatXContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemFloatXContext); ok {
			tst[i] = t.(IArrayElemFloatXContext)
			i++
		}
	}

	return tst
}

func (s *ArrayF64Context) ArrayElemFloatX(i int) IArrayElemFloatXContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemFloatXContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemFloatXContext)
}

func (s *ArrayF64Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayF64Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayF64Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayF64(s)
	}
}

func (s *ArrayF64Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayF64(s)
	}
}

func (p *CTEParser) ArrayF64() (localctx IArrayF64Context) {
	this := p
	_ = this

	localctx = NewArrayF64Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CTEParserRULE_arrayF64)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1395)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_F64, CTEParserARRAY_TYPE_F64X:
		p.SetState(1456)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CTEParserARRAY_TYPE_F64:
			{
				p.SetState(1396)
				p.Match(CTEParserARRAY_TYPE_F64)
			}
			p.SetState(1398)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_F_WSL {
				{
					p.SetState(1397)
					p.Match(CTEParserARRAY_F_WSL)
				}

			}
			p.SetState(1423)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&7743) != 0 {
				p.SetState(1405)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CTEParserARRAY_F_ELEM_D, CTEParserARRAY_F_ELEM_H:
					{
						p.SetState(1400)
						p.ArrayElemFloat()
					}

				case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
					{
						p.SetState(1401)
						p.ArrayElemNan()
					}

				case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
					{
						p.SetState(1402)
						p.ArrayElemSnan()
					}

				case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
					{
						p.SetState(1403)
						p.ArrayElemInf()
					}

				case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
					{
						p.SetState(1404)
						p.ArrayElemNinf()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				p.SetState(1417)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1407)
							p.Match(CTEParserARRAY_F_WSL)
						}
						p.SetState(1413)
						p.GetErrorHandler().Sync(p)

						switch p.GetTokenStream().LA(1) {
						case CTEParserARRAY_F_ELEM_D, CTEParserARRAY_F_ELEM_H:
							{
								p.SetState(1408)
								p.ArrayElemFloat()
							}

						case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
							{
								p.SetState(1409)
								p.ArrayElemNan()
							}

						case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
							{
								p.SetState(1410)
								p.ArrayElemSnan()
							}

						case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
							{
								p.SetState(1411)
								p.ArrayElemInf()
							}

						case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
							{
								p.SetState(1412)
								p.ArrayElemNinf()
							}

						default:
							panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						}

					}
					p.SetState(1419)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())
				}
				p.SetState(1421)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_F_WSL {
					{
						p.SetState(1420)
						p.Match(CTEParserARRAY_F_WSL)
					}

				}

			}
			{
				p.SetState(1425)
				p.Match(CTEParserARRAY_F_END)
			}

		case CTEParserARRAY_TYPE_F64X:
			{
				p.SetState(1426)
				p.Match(CTEParserARRAY_TYPE_F64X)
			}
			p.SetState(1428)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_F_X_WSL {
				{
					p.SetState(1427)
					p.Match(CTEParserARRAY_F_X_WSL)
				}

			}
			p.SetState(1453)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&1999) != 0 {
				p.SetState(1435)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CTEParserARRAY_F_X_ELEM:
					{
						p.SetState(1430)
						p.ArrayElemFloatX()
					}

				case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
					{
						p.SetState(1431)
						p.ArrayElemNan()
					}

				case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
					{
						p.SetState(1432)
						p.ArrayElemSnan()
					}

				case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
					{
						p.SetState(1433)
						p.ArrayElemInf()
					}

				case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
					{
						p.SetState(1434)
						p.ArrayElemNinf()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				p.SetState(1447)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1437)
							p.Match(CTEParserARRAY_F_X_WSL)
						}
						p.SetState(1443)
						p.GetErrorHandler().Sync(p)

						switch p.GetTokenStream().LA(1) {
						case CTEParserARRAY_F_X_ELEM:
							{
								p.SetState(1438)
								p.ArrayElemFloatX()
							}

						case CTEParserARRAY_F_NAN, CTEParserARRAY_F_X_NAN:
							{
								p.SetState(1439)
								p.ArrayElemNan()
							}

						case CTEParserARRAY_F_SNAN, CTEParserARRAY_F_X_SNAN:
							{
								p.SetState(1440)
								p.ArrayElemSnan()
							}

						case CTEParserARRAY_F_INF, CTEParserARRAY_F_X_INF:
							{
								p.SetState(1441)
								p.ArrayElemInf()
							}

						case CTEParserARRAY_F_NINF, CTEParserARRAY_F_X_NINF:
							{
								p.SetState(1442)
								p.ArrayElemNinf()
							}

						default:
							panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						}

					}
					p.SetState(1449)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext())
				}
				p.SetState(1451)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CTEParserARRAY_F_X_WSL {
					{
						p.SetState(1450)
						p.Match(CTEParserARRAY_F_X_WSL)
					}

				}

			}
			{
				p.SetState(1455)
				p.Match(CTEParserARRAY_F_X_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case CTEParserARRAY_TYPE_F64_EMPTY:
		{
			p.SetState(1458)
			p.Match(CTEParserARRAY_TYPE_F64_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayUidContext is an interface to support dynamic dispatch.
type IArrayUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_UID() antlr.TerminalNode
	ARRAY_UID_END() antlr.TerminalNode
	ARRAY_TYPE_UID_EMPTY() antlr.TerminalNode
	AllARRAY_UID_WSL() []antlr.TerminalNode
	ARRAY_UID_WSL(i int) antlr.TerminalNode
	AllArrayElemUid() []IArrayElemUidContext
	ArrayElemUid(i int) IArrayElemUidContext

	// IsArrayUidContext differentiates from other interfaces.
	IsArrayUidContext()
}

type ArrayUidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayUidContext() *ArrayUidContext {
	var p = new(ArrayUidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayUid
	return p
}

func (*ArrayUidContext) IsArrayUidContext() {}

func NewArrayUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayUidContext {
	var p = new(ArrayUidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayUid

	return p
}

func (s *ArrayUidContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayUidContext) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayUidContext) ARRAY_TYPE_UID() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_UID, 0)
}

func (s *ArrayUidContext) ARRAY_UID_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_UID_END, 0)
}

func (s *ArrayUidContext) ARRAY_TYPE_UID_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_UID_EMPTY, 0)
}

func (s *ArrayUidContext) AllARRAY_UID_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_UID_WSL)
}

func (s *ArrayUidContext) ARRAY_UID_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_UID_WSL, i)
}

func (s *ArrayUidContext) AllArrayElemUid() []IArrayElemUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemUidContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemUidContext); ok {
			tst[i] = t.(IArrayElemUidContext)
			i++
		}
	}

	return tst
}

func (s *ArrayUidContext) ArrayElemUid(i int) IArrayElemUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemUidContext)
}

func (s *ArrayUidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayUidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayUidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayUid(s)
	}
}

func (s *ArrayUidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayUid(s)
	}
}

func (p *CTEParser) ArrayUid() (localctx IArrayUidContext) {
	this := p
	_ = this

	localctx = NewArrayUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CTEParserRULE_arrayUid)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1461)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_UID:
		{
			p.SetState(1462)
			p.Match(CTEParserARRAY_TYPE_UID)
		}
		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CTEParserARRAY_UID_WSL {
			{
				p.SetState(1463)
				p.Match(CTEParserARRAY_UID_WSL)
			}

		}
		p.SetState(1477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CTEParserARRAY_UID_ELEM {
			{
				p.SetState(1466)
				p.ArrayElemUid()
			}
			p.SetState(1471)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1467)
						p.Match(CTEParserARRAY_UID_WSL)
					}
					{
						p.SetState(1468)
						p.ArrayElemUid()
					}

				}
				p.SetState(1473)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())
			}
			p.SetState(1475)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CTEParserARRAY_UID_WSL {
				{
					p.SetState(1474)
					p.Match(CTEParserARRAY_UID_WSL)
				}

			}

		}
		{
			p.SetState(1479)
			p.Match(CTEParserARRAY_UID_END)
		}

	case CTEParserARRAY_TYPE_UID_EMPTY:
		{
			p.SetState(1480)
			p.Match(CTEParserARRAY_TYPE_UID_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayBitContext is an interface to support dynamic dispatch.
type IArrayBitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_BEGIN() antlr.TerminalNode
	ARRAY_TYPE_BIT() antlr.TerminalNode
	ARRAY_BIT_END() antlr.TerminalNode
	ARRAY_TYPE_BIT_EMPTY() antlr.TerminalNode
	AllARRAY_BIT_WSL() []antlr.TerminalNode
	ARRAY_BIT_WSL(i int) antlr.TerminalNode
	AllArrayElemBits() []IArrayElemBitsContext
	ArrayElemBits(i int) IArrayElemBitsContext

	// IsArrayBitContext differentiates from other interfaces.
	IsArrayBitContext()
}

type ArrayBitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayBitContext() *ArrayBitContext {
	var p = new(ArrayBitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CTEParserRULE_arrayBit
	return p
}

func (*ArrayBitContext) IsArrayBitContext() {}

func NewArrayBitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayBitContext {
	var p = new(ArrayBitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CTEParserRULE_arrayBit

	return p
}

func (s *ArrayBitContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayBitContext) ARRAY_BEGIN() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BEGIN, 0)
}

func (s *ArrayBitContext) ARRAY_TYPE_BIT() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_BIT, 0)
}

func (s *ArrayBitContext) ARRAY_BIT_END() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BIT_END, 0)
}

func (s *ArrayBitContext) ARRAY_TYPE_BIT_EMPTY() antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_TYPE_BIT_EMPTY, 0)
}

func (s *ArrayBitContext) AllARRAY_BIT_WSL() []antlr.TerminalNode {
	return s.GetTokens(CTEParserARRAY_BIT_WSL)
}

func (s *ArrayBitContext) ARRAY_BIT_WSL(i int) antlr.TerminalNode {
	return s.GetToken(CTEParserARRAY_BIT_WSL, i)
}

func (s *ArrayBitContext) AllArrayElemBits() []IArrayElemBitsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElemBitsContext); ok {
			len++
		}
	}

	tst := make([]IArrayElemBitsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElemBitsContext); ok {
			tst[i] = t.(IArrayElemBitsContext)
			i++
		}
	}

	return tst
}

func (s *ArrayBitContext) ArrayElemBits(i int) IArrayElemBitsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElemBitsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElemBitsContext)
}

func (s *ArrayBitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayBitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayBitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.EnterArrayBit(s)
	}
}

func (s *ArrayBitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CTEParserListener); ok {
		listenerT.ExitArrayBit(s)
	}
}

func (p *CTEParser) ArrayBit() (localctx IArrayBitContext) {
	this := p
	_ = this

	localctx = NewArrayBitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CTEParserRULE_arrayBit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Match(CTEParserARRAY_BEGIN)
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CTEParserARRAY_TYPE_BIT:
		{
			p.SetState(1484)
			p.Match(CTEParserARRAY_TYPE_BIT)
		}
		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CTEParserARRAY_BIT_BITS || _la == CTEParserARRAY_BIT_WSL {
			p.SetState(1487)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case CTEParserARRAY_BIT_WSL:
				{
					p.SetState(1485)
					p.Match(CTEParserARRAY_BIT_WSL)
				}

			case CTEParserARRAY_BIT_BITS:
				{
					p.SetState(1486)
					p.ArrayElemBits()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1491)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1492)
			p.Match(CTEParserARRAY_BIT_END)
		}

	case CTEParserARRAY_TYPE_BIT_EMPTY:
		{
			p.SetState(1493)
			p.Match(CTEParserARRAY_TYPE_BIT_EMPTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}
